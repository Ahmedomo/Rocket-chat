[35m.github/history.json[m[36m:[m          "title": "[FIX] Allow username change if LDAP is enabled but their username is not linked to[1;31m an L[mDAP field",
[35m.yarn/plugins/@yarnpkg/plugin-workspace-tools.cjs[m[36m:[m`,CHAR_NO_BREAK_SPACE:"\xA0",CHAR_PERCENT:"%",CHAR_PLUS:"+",CHAR_QUESTION_MARK:"?",CHAR_RIGHT_ANGLE_BRACKET:">",CHAR_RIGHT_CURLY_BRACE:"}",CHAR_RIGHT_SQUARE_BRACKET:"]",CHAR_SEMICOLON:";",CHAR_SINGLE_QUOTE:"'",CHAR_SPACE:" ",CHAR_TAB:"	",CHAR_UNDERSCORE:"_",CHAR_VERTICAL_LINE:"|",CHAR_ZERO_WIDTH_NOBREAK_SPACE:"\uFEFF"}});var Pt=K((hs,Nt)=>{"use strict";var en=ke(),{MAX_LENGTH:It,CHAR_BACKSLASH:qe,CHAR_BACKTICK:tn,CHAR_COMMA:rn,CHAR_DOT:nn,CHAR_LEFT_PARENTHESES:sn,CHAR_RIGHT_PARENTHESES:an,CHAR_LEFT_CURLY_BRACE:on,CHAR_RIGHT_CURLY_BRACE:cn,CHAR_LEFT_SQUARE_BRACKET:Bt,CHAR_RIGHT_SQUARE_BRACKET:Mt,CHAR_DOUBLE_QUOTE:un,CHAR_SINGLE_QUOTE:ln,CHAR_NO_BREAK_SPACE:pn,CHAR_ZERO_WIDTH_NOBREAK_SPACE:fn}=Ot(),hn=(e,t={})=>{if(typeof e!="string")throw new TypeError("Expected a string");let r=t||{},n=typeof r.maxLength=="number"?Math.min(It,r.maxLength):It;if(e.length>n)throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${n})`);let s={type:"root",input:e,nodes:[]},a=[s],i=s,o=s,h=0,g=e.length,f=0,A=0,p,k={},y=()=>e[f++],R=_=>{if(_.type==="text"&&o.type==="dot"&&(o.type="text"),o&&o.type==="text"&&_.type==="text"){o.value+=_.value;return}return i.nodes.push(_),_.parent=i,_.prev=o,o=_,_};for(R({type:"bos"});f<g;)if(i=a[a.length-1],p=y(),!(p===fn||p===pn)){if(p===qe){R({type:"text",value:(t.keepEscaping?p:"")+y()});continue}if(p===Mt){R({type:"text",value:"\\"+p});continue}if(p===Bt){h++;let _=!0,x;for(;f<g&&(x=y());){if(p+=x,x===Bt){h++;continue}if(x===qe){p+=y();continue}if(x===Mt&&(h--,h===0))break}R({type:"text",value:p});continue}if(p===sn){i=R({type:"paren",nodes:[]}),a.push(i),R({type:"text",value:p});continue}if(p===an){if(i.type!=="paren"){R({type:"text",value:p});continue}i=a.pop(),R({type:"text",value:p}),i=a[a.length-1];continue}if(p===un||p===ln||p===tn){let _=p,x;for(t.keepQuotes!==!0&&(p="");f<g&&(x=y());){if(x===qe){p+=x+y();continue}if(x===_){t.keepQuotes===!0&&(p+=x);break}p+=x}R({type:"text",value:p});continue}if(p===on){A++;let _=o.value&&o.value.slice(-1)==="$"||i.dollar===!0;i=R({type:"brace",open:!0,close:!1,dollar:_,depth:A,commas:0,ranges:0,nodes:[]}),a.push(i),R({type:"open",value:p});continue}if(p===cn){if(i.type!=="brace"){R({type:"text",value:p});continue}let _="close";i=a.pop(),i.close=!0,R({type:_,value:p}),A--,i=a[a.length-1];continue}if(p===rn&&A>0){if(i.ranges>0){i.ranges=0;let _=i.nodes.shift();i.nodes=[_,{type:"text",value:en(i)}]}R({type:"comma",value:p}),i.commas++;continue}if(p===nn&&A>0&&i.commas===0){let _=i.nodes;if(A===0||_.length===0){R({type:"text",value:p});continue}if(o.type==="dot"){if(i.range=[],o.value+=p,o.type="range",i.nodes.length!==3&&i.nodes.length!==5){i.invalid=!0,i.ranges=0,o.type="text";continue}i.ranges++,i.args=[];continue}if(o.type==="range"){_.pop();let x=_[_.length-1];x.value+=o.value+p,o=x,i.ranges--;continue}R({type:"dot",value:p});continue}R({type:"text",value:p})}do if(i=a.pop(),i.type!=="root"){i.nodes.forEach(T=>{T.nodes||(T.type==="open"&&(T.isOpen=!0),T.type==="close"&&(T.isClose=!0),T.nodes||(T.type="text"),T.invalid=!0)});let _=a[a.length-1],x=_.nodes.indexOf(i);_.nodes.splice(x,1,...i.nodes)}while(a.length>0);return R({type:"eos"}),s};Nt.exports=hn});var Gt=K((ds,Dt)=>{"use strict";var Ut=ke(),dn=Ht(),gn=Tt(),mn=Pt(),V=(e,t={})=>{let r=[];if(Array.isArray(e))for(let n of e){let s=V.create(n,t);Array.isArray(s)?r.push(...s):r.push(s)}else r=[].concat(V.create(e,t));return t&&t.expand===!0&&t.nodupes===!0&&(r=[...new Set(r)]),r};V.parse=(e,t={})=>mn(e,t);V.stringify=(e,t={})=>typeof e=="string"?Ut(V.parse(e,t),t):Ut(e,t);V.compile=(e,t={})=>(typeof e=="string"&&(e=V.parse(e,t)),dn(e,t));V.expand=(e,t={})=>{typeof e=="string"&&(e=V.parse(e,t));let r=gn(e,t);return t.noempty===!0&&(r=r.filter(Boolean)),t.nodupes===!0&&(r=[...new Set(r)]),r};V.create=(e,t={})=>e===""||e.length<3?[e]:t.expand!==!0?V.compile(e,t):V.expand(e,t);Dt.exports=V});var ye=K((gs,qt)=>{"use strict";var An=require("path"),ie="\\\\/",Kt=`[^${ie}]`,ce="\\.",Rn="\\+",yn="\\?",Le="\\/",bn="(?=.)",Wt="[^/]",Ke=`(?:${Le}|$)`,jt=`(?:^|${Le})`,We=`${ce}{1,2}${Ke}`,_n=`(?!${ce})`,En=`(?!${jt}${We})`,xn=`(?!${ce}{0,1}${Ke})`,Cn=`(?!${We})`,wn=`[^.${Le}]`,Sn=`${Wt}*?`,Ft={DOT_LITERAL:ce,PLUS_LITERAL:Rn,QMARK_LITERAL:yn,SLASH_LITERAL:Le,ONE_CHAR:bn,QMARK:Wt,END_ANCHOR:Ke,DOTS_SLASH:We,NO_DOT:_n,NO_DOTS:En,NO_DOT_SLASH:xn,NO_DOTS_SLASH:Cn,QMARK_NO_DOT:wn,STAR:Sn,START_ANCHOR:jt},vn=Q(B({},Ft),{SLASH_LITERAL:`[${ie}]`,QMARK:Kt,STAR:`${Kt}*?`,DOTS_SLASH:`${ce}{1,2}(?:[${ie}]|$)`,NO_DOT:`(?!${ce})`,NO_DOTS:`(?!(?:^|[${ie}])${ce}{1,2}(?:[${ie}]|$))`,NO_DOT_SLASH:`(?!${ce}{0,1}(?:[${ie}]|$))`,NO_DOTS_SLASH:`(?!${ce}{1,2}(?:[${ie}]|$))`,QMARK_NO_DOT:`[^.${ie}]`,START_ANCHOR:`(?:^|[${ie}])`,END_ANCHOR:`(?:[${ie}]|$)`}),Hn={alnum:"a-zA-Z0-9",alpha:"a-zA-Z",ascii:"\\x00-\\x7F",blank:" \\t",cntrl:"\\x00-\\x1F\\x7F",digit:"0-9",graph:"\\x21-\\x7E",lower:"a-z",print:"\\x20-\\x7E ",punct:"\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",space:" \\t\\r\\n\\v\\f",upper:"A-Z",word:"A-Za-z0-9_",xdigit:"A-Fa-f0-9"};qt.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:Hn,REGEX_BACKSLASH:/\\(?![*+?^${}(|)[\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\].,$*+?^{}()|\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\?)((\W)(\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\[.*?[^\\]\]|\\(?=.))/g,REPLACEMENTS:{"***":"*","**/**":"**","**/**/**":"**"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:An.sep,extglobChars(e){return{"!":{type:"negate",open:"(?:(?!(?:",close:`))${e.STAR})`},"?":{type:"qmark",open:"(?:",close:")?"},"+":{type:"plus",open:"(?:",close:")+"},"*":{type:"star",open:"(?:",close:")*"},"@":{type:"at",open:"(?:",close:")"}}},globChars(e){return e===!0?vn:Ft}}});var be=K(Z=>{"use strict";var $n=require("path"),kn=process.platform==="win32",{REGEX_BACKSLASH:Tn,REGEX_REMOVE_BACKSLASH:Ln,REGEX_SPECIAL_CHARS:On,REGEX_SPECIAL_CHARS_GLOBAL:Nn}=ye();Z.isObject=e=>e!==null&&typeof e=="object"&&!Array.isArray(e);Z.hasRegexChars=e=>On.test(e);Z.isRegexChar=e=>e.length===1&&Z.hasRegexChars(e);Z.escapeRegex=e=>e.replace(Nn,"\\$1");Z.toPosixSlashes=e=>e.replace(Tn,"/");Z.removeBackslashes=e=>e.replace(Ln,t=>t==="\\"?"":t);Z.supportsLookbehinds=()=>{let e=process.version.slice(1).split(".").map(Number);return e.length===3&&e[0]>=9||e[0]===8&&e[1]>=10};Z.isWindows=e=>e&&typeof e.windows=="boolean"?e.windows:kn===!0||$n.sep==="\\";Z.escapeLast=(e,t,r)=>{let n=e.lastIndexOf(t,r);return n===-1?e:e[n-1]==="\\"?Z.escapeLast(e,t,n-1):`${e.slice(0,n)}\\${e.slice(n)}`};Z.removePrefix=(e,t={})=>{let r=e;return r.startsWith("./")&&(r=r.slice(2),t.prefix="./"),r};Z.wrapOutput=(e,t={},r={})=>{let n=r.contains?"":"^",s=r.contains?"":"$",a=`${n}(?:${e})${s}`;return t.negated===!0&&(a=`(?:^(?!${a}).*$)`),a}});var er=K((As,Qt)=>{"use strict";var Xt=be(),{CHAR_ASTERISK:je,CHAR_AT:In,CHAR_BACKWARD_SLASH:_e,CHAR_COMMA:Bn,CHAR_DOT:Fe,CHAR_EXCLAMATION_MARK:Qe,CHAR_FORWARD_SLASH:Zt,CHAR_LEFT_CURLY_BRACE:Xe,CHAR_LEFT_PARENTHESES:Ze,CHAR_LEFT_SQUARE_BRACKET:Mn,CHAR_PLUS:Pn,CHAR_QUESTION_MARK:Yt,CHAR_RIGHT_CURLY_BRACE:Dn,CHAR_RIGHT_PARENTHESES:zt,CHAR_RIGHT_SQUARE_BRACKET:Un}=ye(),Vt=e=>e===Zt||e===_e,Jt=e=>{e.isPrefix!==!0&&(e.depth=e.isGlobstar?Infinity:1)},Gn=(e,t)=>{let r=t||{},n=e.length-1,s=r.parts===!0||r.scanToEnd===!0,a=[],i=[],o=[],h=e,g=-1,f=0,A=0,p=!1,k=!1,y=!1,R=!1,_=!1,x=!1,T=!1,O=!1,W=!1,G=!1,ne=0,E,b,C={value:"",depth:0,isGlob:!1},M=()=>g>=n,l=()=>h.charCodeAt(g+1),H=()=>(E=b,h.charCodeAt(++g));for(;g<n;){b=H();let I;if(b===_e){T=C.backslashes=!0,b=H(),b===Xe&&(x=!0);continue}if(x===!0||b===Xe){for(ne++;M()!==!0&&(b=H());){if(b===_e){T=C.backslashes=!0,H();continue}if(b===Xe){ne++;continue}if(x!==!0&&b===Fe&&(b=H())===Fe){if(p=C.isBrace=!0,y=C.isGlob=!0,G=!0,s===!0)continue;break}if(x!==!0&&b===Bn){if(p=C.isBrace=!0,y=C.isGlob=!0,G=!0,s===!0)continue;break}if(b===Dn&&(ne--,ne===0)){x=!1,p=C.isBrace=!0,G=!0;break}}if(s===!0)continue;break}if(b===Zt){if(a.push(g),i.push(C),C={value:"",depth:0,isGlob:!1},G===!0)continue;if(E===Fe&&g===f+1){f+=2;continue}A=g+1;continue}if(r.noext!==!0&&(b===Pn||b===In||b===je||b===Yt||b===Qe)===!0&&l()===Ze){if(y=C.isGlob=!0,R=C.isExtglob=!0,G=!0,b===Qe&&g===f&&(W=!0),s===!0){for(;M()!==!0&&(b=H());){if(b===_e){T=C.backslashes=!0,b=H();continue}if(b===zt){y=C.isGlob=!0,G=!0;break}}continue}break}if(b===je){if(E===je&&(_=C.isGlobstar=!0),y=C.isGlob=!0,G=!0,s===!0)continue;break}if(b===Yt){if(y=C.isGlob=!0,G=!0,s===!0)continue;break}if(b===Mn){for(;M()!==!0&&(I=H());){if(I===_e){T=C.backslashes=!0,H();continue}if(I===Un){k=C.isBracket=!0,y=C.isGlob=!0,G=!0;break}}if(s===!0)continue;break}if(r.nonegate!==!0&&b===Qe&&g===f){O=C.negated=!0,f++;continue}if(r.noparen!==!0&&b===Ze){if(y=C.isGlob=!0,s===!0){for(;M()!==!0&&(b=H());){if(b===Ze){T=C.backslashes=!0,b=H();continue}if(b===zt){G=!0;break}}continue}break}if(y===!0){if(G=!0,s===!0)continue;break}}r.noext===!0&&(R=!1,y=!1);let w=h,j="",c="";f>0&&(j=h.slice(0,f),h=h.slice(f),A-=f),w&&y===!0&&A>0?(w=h.slice(0,A),c=h.slice(A)):y===!0?(w="",c=h):w=h,w&&w!==""&&w!=="/"&&w!==h&&Vt(w.charCodeAt(w.length-1))&&(w=w.slice(0,-1)),r.unescape===!0&&(c&&(c=Xt.removeBackslashes(c)),w&&T===!0&&(w=Xt.removeBackslashes(w)));let u={prefix:j,input:e,start:f,base:w,glob:c,isBrace:p,isBracket:k,isGlob:y,isExtglob:R,isGlobstar:_,negated:O,negatedExtglob:W};if(r.tokens===!0&&(u.maxDepth=0,Vt(b)||i.push(C),u.tokens=i),r.parts===!0||r.tokens===!0){let I;for(let $=0;$<a.length;$++){let ee=I?I+1:f,se=a[$],z=e.slice(ee,se);r.tokens&&($===0&&f!==0?(i[$].isPrefix=!0,i[$].value=j):i[$].value=z,Jt(i[$]),u.maxDepth+=i[$].depth),($!==0||z!=="")&&o.push(z),I=se}if(I&&I+1<e.length){let $=e.slice(I+1);o.push($),r.tokens&&(i[i.length-1].value=$,Jt(i[i.length-1]),u.maxDepth+=i[i.length-1].depth)}u.slashes=a,u.parts=o}return u};Qt.exports=Gn});var sr=K((Rs,tr)=>{"use strict";var Oe=ye(),J=be(),{MAX_LENGTH:Ne,POSIX_REGEX_SOURCE:qn,REGEX_NON_SPECIAL_CHARS:Kn,REGEX_SPECIAL_CHARS_BACKREF:Wn,REPLACEMENTS:rr}=Oe,jn=(e,t)=>{if(typeof t.expandRange=="function")return t.expandRange(...e,t);e.sort();let r=`[${e.join("-")}]`;try{new RegExp(r)}catch(n){return e.map(s=>J.escapeRegex(s)).join("..")}return r},de=(e,t)=>`Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,nr=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");e=rr[e]||e;let r=B({},t),n=typeof r.maxLength=="number"?Math.min(Ne,r.maxLength):Ne,s=e.length;if(s>n)throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${n}`);let a={type:"bos",value:"",output:r.prepend||""},i=[a],o=r.capture?"":"?:",h=J.isWindows(t),g=Oe.globChars(h),f=Oe.extglobChars(g),{DOT_LITERAL:A,PLUS_LITERAL:p,SLASH_LITERAL:k,ONE_CHAR:y,DOTS_SLASH:R,NO_DOT:_,NO_DOT_SLASH:x,NO_DOTS_SLASH:T,QMARK:O,QMARK_NO_DOT:W,STAR:G,START_ANCHOR:ne}=g,E=m=>`(${o}(?:(?!${ne}${m.dot?R:A}).)*?)`,b=r.dot?"":_,C=r.dot?O:W,M=r.bash===!0?E(r):G;r.capture&&(M=`(${M})`),typeof r.noext=="boolean"&&(r.noextglob=r.noext);let l={input:e,index:-1,start:0,dot:r.dot===!0,consumed:"",output:"",prefix:"",backtrack:!1,negated:!1,brackets:0,braces:0,parens:0,quotes:0,globstar:!1,tokens:i};e=J.removePrefix(e,l),s=e.length;let H=[],w=[],j=[],c=a,u,I=()=>l.index===s-1,$=l.peek=(m=1)=>e[l.index+m],ee=l.advance=()=>e[++l.index]||"",se=()=>e.slice(l.index+1),z=(m="",L=0)=>{l.consumed+=m,l.index+=L},Ce=m=>{l.output+=m.output!=null?m.output:m.value,z(m.value)},xr=()=>{let m=1;for(;$()==="!"&&($(2)!=="("||$(3)==="?");)ee(),l.start++,m++;return m%2==0?!1:(l.negated=!0,l.start++,!0)},we=m=>{l[m]++,j.push(m)},ue=m=>{l[m]--,j.pop()},v=m=>{if(c.type==="globstar"){let L=l.braces>0&&(m.type==="comma"||m.type==="brace"),d=m.extglob===!0||H.length&&(m.type==="pipe"||m.type==="paren");m.type!=="slash"&&m.type!=="paren"&&!L&&!d&&(l.output=l.output.slice(0,-c.output.length),c.type="star",c.value="*",c.output=M,l.output+=c.output)}if(H.length&&m.type!=="paren"&&(H[H.length-1].inner+=m.value),(m.value||m.output)&&Ce(m),c&&c.type==="text"&&m.type==="text"){c.value+=m.value,c.output=(c.output||"")+m.value;return}m.prev=c,i.push(m),c=m},Se=(m,L)=>{let d=Q(B({},f[L]),{conditions:1,inner:""});d.prev=c,d.parens=l.parens,d.output=l.output;let S=(r.capture?"(":"")+d.open;we("parens"),v({type:m,value:L,output:l.output?"":y}),v({type:"paren",extglob:!0,value:ee(),output:S}),H.push(d)},Cr=m=>{let L=m.close+(r.capture?")":""),d;if(m.type==="negate"){let S=M;m.inner&&m.inner.length>1&&m.inner.includes("/")&&(S=E(r)),(S!==M||I()||/^\)+$/.test(se()))&&(L=m.close=`)$))${S}`),m.inner.includes("*")&&(d=se())&&/^\.[^\\/.]+$/.test(d)&&(L=m.close=`)${d})${S})`),m.prev.type==="bos"&&(l.negatedExtglob=!0)}v({type:"paren",extglob:!0,value:u,output:L}),ue("parens")};if(r.fastpaths!==!1&&!/(^[*!]|[/()[\]{}"])/.test(e)){let m=!1,L=e.replace(Wn,(d,S,P,F,q,Me)=>F==="\\"?(m=!0,d):F==="?"?S?S+F+(q?O.repeat(q.length):""):Me===0?C+(q?O.repeat(q.length):""):O.repeat(P.length):F==="."?A.repeat(P.length):F==="*"?S?S+F+(q?M:""):M:S?d:`\\${d}`);return m===!0&&(r.unescape===!0?L=L.replace(/\\/g,""):L=L.replace(/\\+/g,d=>d.length%2==0?"\\\\":d?"\\":"")),L===e&&r.contains===!0?(l.output=e,l):(l.output=J.wrapOutput(L,l,t),l)}for(;!I();){if(u=ee(),u==="\0")continue;if(u==="\\"){let d=$();if(d==="/"&&r.bash!==!0||d==="."||d===";")continue;if(!d){u+="\\",v({type:"text",value:u});continue}let S=/^\\+/.exec(se()),P=0;if(S&&S[0].length>2&&(P=S[0].length,l.index+=P,P%2!=0&&(u+="\\")),r.unescape===!0?u=ee():u+=ee(),l.brackets===0){v({type:"text",value:u});continue}}if(l.brackets>0&&(u!=="]"||c.value==="["||c.value==="[^")){if(r.posix!==!1&&u===":"){let d=c.value.slice(1);if(d.includes("[")&&(c.posix=!0,d.includes(":"))){let S=c.value.lastIndexOf("["),P=c.value.slice(0,S),F=c.value.slice(S+2),q=qn[F];if(q){c.value=P+q,l.backtrack=!0,ee(),!a.output&&i.indexOf(c)===1&&(a.output=y);continue}}}(u==="["&&$()!==":"||u==="-"&&$()==="]")&&(u=`\\${u}`),u==="]"&&(c.value==="["||c.value==="[^")&&(u=`\\${u}`),r.posix===!0&&u==="!"&&c.value==="["&&(u="^"),c.value+=u,Ce({value:u});continue}if(l.quotes===1&&u!=='"'){u=J.escapeRegex(u),c.value+=u,Ce({value:u});continue}if(u==='"'){l.quotes=l.quotes===1?0:1,r.keepQuotes===!0&&v({type:"text",value:u});continue}if(u==="("){we("parens"),v({type:"paren",value:u});continue}if(u===")"){if(l.parens===0&&r.strictBrackets===!0)throw new SyntaxError(de("opening","("));let d=H[H.length-1];if(d&&l.parens===d.parens+1){Cr(H.pop());continue}v({type:"paren",value:u,output:l.parens?")":"\\)"}),ue("parens");continue}if(u==="["){if(r.nobracket===!0||!se().includes("]")){if(r.nobracket!==!0&&r.strictBrackets===!0)throw new SyntaxError(de("closing","]"));u=`\\${u}`}else we("brackets");v({type:"bracket",value:u});continue}if(u==="]"){if(r.nobracket===!0||c&&c.type==="bracket"&&c.value.length===1){v({type:"text",value:u,output:`\\${u}`});continue}if(l.brackets===0){if(r.strictBrackets===!0)throw new SyntaxError(de("opening","["));v({type:"text",value:u,output:`\\${u}`});continue}ue("brackets");let d=c.value.slice(1);if(c.posix!==!0&&d[0]==="^"&&!d.includes("/")&&(u=`/${u}`),c.value+=u,Ce({value:u}),r.literalBrackets===!1||J.hasRegexChars(d))continue;let S=J.escapeRegex(c.value);if(l.output=l.output.slice(0,-c.value.length),r.literalBrackets===!0){l.output+=S,c.value=S;continue}c.value=`(${o}${S}|${c.value})`,l.output+=c.value;continue}if(u==="{"&&r.nobrace!==!0){we("braces");let d={type:"brace",value:u,output:"(",outputIndex:l.output.length,tokensIndex:l.tokens.length};w.push(d),v(d);continue}if(u==="}"){let d=w[w.length-1];if(r.nobrace===!0||!d){v({type:"text",value:u,output:u});continue}let S=")";if(d.dots===!0){let P=i.slice(),F=[];for(let q=P.length-1;q>=0&&(i.pop(),P[q].type!=="brace");q--)P[q].type!=="dots"&&F.unshift(P[q].value);S=jn(F,r),l.backtrack=!0}if(d.comma!==!0&&d.dots!==!0){let P=l.output.slice(0,d.outputIndex),F=l.tokens.slice(d.tokensIndex);d.value=d.output="\\{",u=S="\\}",l.output=P;for(let q of F)l.output+=q.output||q.value}v({type:"brace",value:u,output:S}),ue("braces"),w.pop();continue}if(u==="|"){H.length>0&&H[H.length-1].conditions++,v({type:"text",value:u});continue}if(u===","){let d=u,S=w[w.length-1];S&&j[j.length-1]==="braces"&&(S.comma=!0,d="|"),v({type:"comma",value:u,output:d});continue}if(u==="/"){if(c.type==="dot"&&l.index===l.start+1){l.start=l.index+1,l.consumed="",l.output="",i.pop(),c=a;continue}v({type:"slash",value:u,output:k});continue}if(u==="."){if(l.braces>0&&c.type==="dot"){c.value==="."&&(c.output=A);let d=w[w.length-1];c.type="dots",c.output+=u,c.value+=u,d.dots=!0;continue}if(l.braces+l.parens===0&&c.type!=="bos"&&c.type!=="slash"){v({type:"text",value:u,output:A});continue}v({type:"dot",value:u,output:A});continue}if(u==="?"){if(!(c&&c.value==="(")&&r.noextglob!==!0&&$()==="("&&$(2)!=="?"){Se("qmark",u);continue}if(c&&c.type==="paren"){let S=$(),P=u;if(S==="<"&&!J.supportsLookbehinds())throw new Error("Node.js v10 or higher is required for regex lookbehinds");(c.value==="("&&!/[!=<:]/.test(S)||S==="<"&&!/<([!=]|\w+>)/.test(se()))&&(P=`\\${u}`),v({type:"text",value:u,output:P});continue}if(r.dot!==!0&&(c.type==="slash"||c.type==="bos")){v({type:"qmark",value:u,output:W});continue}v({type:"qmark",value:u,output:O});continue}if(u==="!"){if(r.noextglob!==!0&&$()==="("&&($(2)!=="?"||!/[!=<:]/.test($(3)))){Se("negate",u);continue}if(r.nonegate!==!0&&l.index===0){xr();continue}}if(u==="+"){if(r.noextglob!==!0&&$()==="("&&$(2)!=="?"){Se("plus",u);continue}if(c&&c.value==="("||r.regex===!1){v({type:"plus",value:u,output:p});continue}if(c&&(c.type==="bracket"||c.type==="paren"||c.type==="brace")||l.parens>0){v({type:"plus",value:u});continue}v({type:"plus",value:p});continue}if(u==="@"){if(r.noextglob!==!0&&$()==="("&&$(2)!=="?"){v({type:"at",extglob:!0,value:u,output:""});continue}v({type:"text",value:u});continue}if(u!=="*"){(u==="$"||u==="^")&&(u=`\\${u}`);let d=Kn.exec(se());d&&(u+=d[0],l.index+=d[0].length),v({type:"text",value:u});continue}if(c&&(c.type==="globstar"||c.star===!0)){c.type="star",c.star=!0,c.value+=u,c.output=M,l.backtrack=!0,l.globstar=!0,z(u);continue}let m=se();if(r.noextglob!==!0&&/^\([^?]/.test(m)){Se("star",u);continue}if(c.type==="star"){if(r.noglobstar===!0){z(u);continue}let d=c.prev,S=d.prev,P=d.type==="slash"||d.type==="bos",F=S&&(S.type==="star"||S.type==="globstar");if(r.bash===!0&&(!P||m[0]&&m[0]!=="/")){v({type:"star",value:u,output:""});continue}let q=l.braces>0&&(d.type==="comma"||d.type==="brace"),Me=H.length&&(d.type==="pipe"||d.type==="paren");if(!P&&d.type!=="paren"&&!q&&!Me){v({type:"star",value:u,output:""});continue}for(;m.slice(0,3)==="/**";){let ve=e[l.index+4];if(ve&&ve!=="/")break;m=m.slice(3),z("/**",3)}if(d.type==="bos"&&I()){c.type="globstar",c.value+=u,c.output=E(r),l.output=c.output,l.globstar=!0,z(u);continue}if(d.type==="slash"&&d.prev.type!=="bos"&&!F&&I()){l.output=l.output.slice(0,-(d.output+c.output).length),d.output=`(?:${d.output}`,c.type="globstar",c.output=E(r)+(r.strictSlashes?")":"|$)"),c.value+=u,l.globstar=!0,l.output+=d.output+c.output,z(u);continue}if(d.type==="slash"&&d.prev.type!=="bos"&&m[0]==="/"){let ve=m[1]!==void 0?"|$":"";l.output=l.output.slice(0,-(d.output+c.output).length),d.output=`(?:${d.output}`,c.type="globstar",c.output=`${E(r)}${k}|${k}${ve})`,c.value+=u,l.output+=d.output+c.output,l.globstar=!0,z(u+ee()),v({type:"slash",value:"/",output:""});continue}if(d.type==="bos"&&m[0]==="/"){c.type="globstar",c.value+=u,c.output=`(?:^|${k}|${E(r)}${k})`,l.output=c.output,l.globstar=!0,z(u+ee()),v({type:"slash",value:"/",output:""});continue}l.output=l.output.slice(0,-c.output.length),c.type="globstar",c.output=E(r),c.value+=u,l.output+=c.output,l.globstar=!0,z(u);continue}let L={type:"star",value:u,output:M};if(r.bash===!0){L.output=".*?",(c.type==="bos"||c.type==="slash")&&(L.output=b+L.output),v(L);continue}if(c&&(c.type==="bracket"||c.type==="paren")&&r.regex===!0){L.output=u,v(L);continue}(l.index===l.start||c.type==="slash"||c.type==="dot")&&(c.type==="dot"?(l.output+=x,c.output+=x):r.dot===!0?(l.output+=T,c.output+=T):(l.output+=b,c.output+=b),$()!=="*"&&(l.output+=y,c.output+=y)),v(L)}for(;l.brackets>0;){if(r.strictBrackets===!0)throw new SyntaxError(de("closing","]"));l.output=J.escapeLast(l.output,"["),ue("brackets")}for(;l.parens>0;){if(r.strictBrackets===!0)throw new SyntaxError(de("closing",")"));l.output=J.escapeLast(l.output,"("),ue("parens")}for(;l.braces>0;){if(r.strictBrackets===!0)throw new SyntaxError(de("closing","}"));l.output=J.escapeLast(l.output,"{"),ue("braces")}if(r.strictSlashes!==!0&&(c.type==="star"||c.type==="bracket")&&v({type:"maybe_slash",value:"",output:`${k}?`}),l.backtrack===!0){l.output="";for(let m of l.tokens)l.output+=m.output!=null?m.output:m.value,m.suffix&&(l.output+=m.suffix)}return l};nr.fastpaths=(e,t)=>{let r=B({},t),n=typeof r.maxLength=="number"?Math.min(Ne,r.maxLength):Ne,s=e.length;if(s>n)throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${n}`);e=rr[e]||e;let a=J.isWindows(t),{DOT_LITERAL:i,SLASH_LITERAL:o,ONE_CHAR:h,DOTS_SLASH:g,NO_DOT:f,NO_DOTS:A,NO_DOTS_SLASH:p,STAR:k,START_ANCHOR:y}=Oe.globChars(a),R=r.dot?A:f,_=r.dot?p:f,x=r.capture?"":"?:",T={negated:!1,prefix:""},O=r.bash===!0?".*?":k;r.capture&&(O=`(${O})`);let W=b=>b.noglobstar===!0?O:`(${x}(?:(?!${y}${b.dot?g:i}).)*?)`,G=b=>{switch(b){case"*":return`${R}${h}${O}`;case".*":return`${i}${h}${O}`;case"*.*":return`${R}${O}${i}${h}${O}`;case"*/*":return`${R}${O}${o}${h}${_}${O}`;case"**":return R+W(r);case"**/*":return`(?:${R}${W(r)}${o})?${_}${h}${O}`;case"**/*.*":return`(?:${R}${W(r)}${o})?${_}${O}${i}${h}${O}`;case"**/.*":return`(?:${R}${W(r)}${o})?${i}${h}${O}`;default:{let C=/^(.*?)\.(\w+)$/.exec(b);if(!C)return;let M=G(C[1]);return M?M+i+C[2]:void 0}}},ne=J.removePrefix(e,T),E=G(ne);return E&&r.strictSlashes!==!0&&(E+=`${o}?`),E};tr.exports=nr});var ir=K((ys,ar)=>{"use strict";var Fn=require("path"),Qn=er(),Ye=sr(),ze=be(),Xn=ye(),Zn=e=>e&&typeof e=="object"&&!Array.isArray(e),D=(e,t,r=!1)=>{if(Array.isArray(e)){let f=e.map(p=>D(p,t,r));return p=>{for(let k of f){let y=k(p);if(y)return y}return!1}}let n=Zn(e)&&e.tokens&&e.input;if(e===""||typeof e!="string"&&!n)throw new TypeError("Expected pattern to be a non-empty string");let s=t||{},a=ze.isWindows(t),i=n?D.compileRe(e,t):D.makeRe(e,t,!1,!0),o=i.state;delete i.state;let h=()=>!1;if(s.ignore){let f=Q(B({},t),{ignore:null,onMatch:null,onResult:null});h=D(s.ignore,f,r)}let g=(f,A=!1)=>{let{isMatch:p,match:k,output:y}=D.test(f,i,t,{glob:e,posix:a}),R={glob:e,state:o,regex:i,posix:a,input:f,output:y,match:k,isMatch:p};return typeof s.onResult=="function"&&s.onResult(R),p===!1?(R.isMatch=!1,A?R:!1):h(f)?(typeof s.onIgnore=="function"&&s.onIgnore(R),R.isMatch=!1,A?R:!1):(typeof s.onMatch=="function"&&s.onMatch(R),A?R:!0)};return r&&(g.state=o),g};D.test=(e,t,r,{glob:n,posix:s}={})=>{if(typeof e!="string")throw new TypeError("Expected input to be a string");if(e==="")return{isMatch:!1,output:""};let a=r||{},i=a.format||(s?ze.toPosixSlashes:null),o=e===n,h=o&&i?i(e):e;return o===!1&&(h=i?i(e):e,o=h===n),(o===!1||a.capture===!0)&&(a.matchBase===!0||a.basename===!0?o=D.matchBase(e,t,r,s):o=t.exec(h)),{isMatch:Boolean(o),match:o,output:h}};D.matchBase=(e,t,r,n=ze.isWindows(r))=>(t instanceof RegExp?t:D.makeRe(t,r)).test(Fn.basename(e));D.isMatch=(e,t,r)=>D(t,r)(e);D.parse=(e,t)=>Array.isArray(e)?e.map(r=>D.parse(r,t)):Ye(e,Q(B({},t),{fastpaths:!1}));D.scan=(e,t)=>Qn(e,t);D.compileRe=(e,t,r=!1,n=!1)=>{if(r===!0)return e.output;let s=t||{},a=s.contains?"":"^",i=s.contains?"":"$",o=`${a}(?:${e.output})${i}`;e&&e.negated===!0&&(o=`^(?!${o}).*$`);let h=D.toRegex(o,t);return n===!0&&(h.state=e),h};D.makeRe=(e,t={},r=!1,n=!1)=>{if(!e||typeof e!="string")throw new TypeError("Expected a non-empty string");let s={negated:!1,fastpaths:!0};return t.fastpaths!==!1&&(e[0]==="."||e[0]==="*")&&(s.output=Ye.fastpaths(e,t)),s.output||(s=Ye(e,t)),D.compileRe(s,t,r,n)};D.toRegex=(e,t)=>{try{let r=t||{};return new RegExp(e,r.flags||(r.nocase?"i":""))}catch(r){if(t&&t.debug===!0)throw r;return/$^/}};D.constants=Xn;ar.exports=D});var cr=K((bs,or)=>{"use strict";or.exports=ir()});var hr=K((_s,ur)=>{"use strict";var lr=require("util"),pr=Gt(),oe=cr(),Ve=be(),fr=e=>e===""||e==="./",N=(e,t,r)=>{t=[].concat(t),e=[].concat(e);let n=new Set,s=new Set,a=new Set,i=0,o=f=>{a.add(f.output),r&&r.onResult&&r.onResult(f)};for(let f=0;f<t.length;f++){let A=oe(String(t[f]),Q(B({},r),{onResult:o}),!0),p=A.state.negated||A.state.negatedExtglob;p&&i++;for(let k of e){let y=A(k,!0);!(p?!y.isMatch:y.isMatch)||(p?n.add(y.output):(n.delete(y.output),s.add(y.output)))}}let g=(i===t.length?[...a]:[...s]).filter(f=>!n.has(f));if(r&&g.length===0){if(r.failglob===!0)throw new Error(`No matches found for "${t.join(", ")}"`);if(r.nonull===!0||r.nullglob===!0)return r.unescape?t.map(f=>f.replace(/\\/g,"")):t}return g};N.match=N;N.matcher=(e,t)=>oe(e,t);N.isMatch=(e,t,r)=>oe(t,r)(e);N.any=N.isMatch;N.not=(e,t,r={})=>{t=[].concat(t).map(String);let n=new Set,s=[],a=o=>{r.onResult&&r.onResult(o),s.push(o.output)},i=N(e,t,Q(B({},r),{onResult:a}));for(let o of s)i.includes(o)||n.add(o);return[...n]};N.contains=(e,t,r)=>{if(typeof e!="string")throw new TypeError(`Expected a string: "${lr.inspect(e)}"`);if(Array.isArray(t))return t.some(n=>N.contains(e,n,r));if(typeof t=="string"){if(fr(e)||fr(t))return!1;if(e.includes(t)||e.startsWith("./")&&e.slice(2).includes(t))return!0}return N.isMatch(e,t,Q(B({},r),{contains:!0}))};N.matchKeys=(e,t,r)=>{if(!Ve.isObject(e))throw new TypeError("Expected the first argument to be an object");let n=N(Object.keys(e),t,r),s={};for(let a of n)s[a]=e[a];return s};N.some=(e,t,r)=>{let n=[].concat(e);for(let s of[].concat(t)){let a=oe(String(s),r);if(n.some(i=>a(i)))return!0}return!1};N.every=(e,t,r)=>{let n=[].concat(e);for(let s of[].concat(t)){let a=oe(String(s),r);if(!n.every(i=>a(i)))return!1}return!0};N.all=(e,t,r)=>{if(typeof e!="string")throw new TypeError(`Expected a string: "${lr.inspect(e)}"`);return[].concat(t).every(n=>oe(n,r)(e))};N.capture=(e,t,r)=>{let n=Ve.isWindows(r),a=oe.makeRe(String(e),Q(B({},r),{capture:!0})).exec(n?Ve.toPosixSlashes(t):t);if(a)return a.slice(1).map(i=>i===void 0?"":i)};N.makeRe=(...e)=>oe.makeRe(...e);N.scan=(...e)=>oe.scan(...e);N.parse=(e,t)=>{let r=[];for(let n of[].concat(e||[]))for(let s of pr(String(n),t))r.push(oe.parse(s,t));return r};N.braces=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");return t&&t.nobrace===!0||!/\{.*\}/.test(e)?[e]:pr(e,t)};N.braceExpand=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");return N.braces(e,Q(B({},t),{expand:!0}))};ur.exports=N});var gr=K((Es,dr)=>{"use strict";dr.exports=(e,...t)=>new Promise(r=>{r(e(...t))})});var Ar=K((xs,Je)=>{"use strict";var Yn=gr(),mr=e=>{if(e<1)throw new TypeError("Expected `concurrency` to be a number from 1 and up");let t=[],r=0,n=()=>{r--,t.length>0&&t.shift()()},s=(o,h,...g)=>{r++;let f=Yn(o,...g);h(f),f.then(n,n)},a=(o,h,...g)=>{r<e?s(o,h,...g):t.push(s.bind(null,o,h,...g))},i=(o,...h)=>new Promise(g=>a(o,g,...h));return Object.defineProperties(i,{activeCount:{get:()=>r},pendingCount:{get:()=>t.length}}),i};Je.exports=mr;Je.exports.default=mr});var Vn={};Or(Vn,{default:()=>es});var He=X(require("@yarnpkg/cli")),ae=X(require("@yarnpkg/core")),nt=X(require("@yarnpkg/core")),le=X(require("clipanion")),Ae=class extends He.BaseCommand{constructor(){super(...arguments);this.json=le.Option.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.production=le.Option.Boolean("--production",!1,{description:"Only install regular dependencies by omitting dev dependencies"});this.all=le.Option.Boolean("-A,--all",!1,{description:"Install the entire project"});this.workspaces=le.Option.Rest()}async execute(){let t=await ae.Configuration.find(this.context.cwd,this.context.plugins),{project:r,workspace:n}=await ae.Project.find(t,this.context.cwd),s=await ae.Cache.find(t);await r.restoreInstallState({restoreResolutions:!1});let a;if(this.all)a=new Set(r.workspaces);else if(this.workspaces.length===0){if(!n)throw new He.WorkspaceRequiredError(r.cwd,this.context.cwd);a=new Set([n])}else a=new Set(this.workspaces.map(o=>r.getWorkspaceByIdent(nt.structUtils.parseIdent(o))));for(let o of a)for(let h of this.production?["dependencies"]:ae.Manifest.hardDependencies)for(let g of o.manifest.getForScope(h).values()){let f=r.tryWorkspaceByDescriptor(g);f!==null&&a.add(f)}for(let o of r.workspaces)a.has(o)?this.production&&o.manifest.devDependencies.clear():(o.manifest.installConfig=o.manifest.installConfig||{},o.manifest.installConfig.selfReferences=!1,o.manifest.dependencies.clear(),o.manifest.devDependencies.clear(),o.manifest.peerDependencies.clear(),o.manifest.scripts.clear());return(await ae.StreamReport.start({configuration:t,json:this.json,stdout:this.context.stdout,includeLogs:!0},async o=>{await r.install({cache:s,report:o,persistProject:!1})})).exitCode()}};Ae.paths=[["workspaces","focus"]],Ae.usage=le.Command.Usage({category:"Workspace-related commands",description:"install a single workspace and its dependencies",details:"\n      This command will run an install as if the specified workspaces (and all other workspaces they depend on) were the only ones in the project. If no workspaces are explicitly listed, the active one will be assumed.\n\n      Note that this command is only very moderately useful when using zero-installs, since the cache will contain all the packages anyway - meaning that the only difference between a full install and a focused install would just be a few extra lines in the `.pnp.cjs` file, at the cost of introducing an extra complexity.\n\n      If the `-A,--all` flag is set, the entire project will be installed. Combine with `--production` to replicate the old `yarn install --production`.\n    "});var st=Ae;var Ie=X(require("@yarnpkg/cli")),ge=X(require("@yarnpkg/core")),Ee=X(require("@yarnpkg/core")),Y=X(require("@yarnpkg/core")),Rr=X(require("@yarnpkg/plugin-git")),U=X(require("clipanion")),Be=X(hr()),yr=X(require("os")),br=X(Ar()),re=X(require("typanion")),xe=class extends Ie.BaseCommand{constructor(){super(...arguments);this.recursive=U.Option.Boolean("-R,--recursive",!1,{description:"Find packages via dependencies/devDependencies instead of using the workspaces field"});this.from=U.Option.Array("--from",[],{description:"An array of glob pattern idents from which to base any recursion"});this.all=U.Option.Boolean("-A,--all",!1,{description:"Run the command on all workspaces of a project"});this.verbose=U.Option.Boolean("-v,--verbose",!1,{description:"Prefix each output line with the name of the originating workspace"});this.parallel=U.Option.Boolean("-p,--parallel",!1,{description:"Run the commands in parallel"});this.interlaced=U.Option.Boolean("-i,--interlaced",!1,{description:"Print the output of commands in real-time instead of buffering it"});this.jobs=U.Option.String("-j,--jobs",{description:"The maximum number of parallel tasks that the execution will be limited to; or `unlimited`",validator:re.isOneOf([re.isEnum(["unlimited"]),re.applyCascade(re.isNumber(),[re.isInteger(),re.isAtLeast(1)])])});this.topological=U.Option.Boolean("-t,--topological",!1,{description:"Run the command after all workspaces it depends on (regular) have finished"});this.topologicalDev=U.Option.Boolean("--topological-dev",!1,{description:"Run the command after all workspaces it depends on (regular + dev) have finished"});this.include=U.Option.Array("--include",[],{description:"An array of glob pattern idents; only matching workspaces will be traversed"});this.exclude=U.Option.Array("--exclude",[],{description:"An array of glob pattern idents; matching workspaces won't be traversed"});this.publicOnly=U.Option.Boolean("--no-private",{description:"Avoid running the command on private workspaces"});this.since=U.Option.String("--since",{description:"Only include workspaces that have been changed since the specified ref.",tolerateBoolean:!0});this.commandName=U.Option.String();this.args=U.Option.Proxy()}async execute(){let t=await ge.Configuration.find(this.context.cwd,this.context.plugins),{project:r,workspace:n}=await ge.Project.find(t,this.context.cwd);if(!this.all&&!n)throw new Ie.WorkspaceRequiredError(r.cwd,this.context.cwd);await r.restoreInstallState();let s=this.cli.process([this.commandName,...this.args]),a=s.path.length===1&&s.path[0]==="run"&&typeof s.scriptName!="undefined"?s.scriptName:null;if(s.path.length===0)throw new U.UsageError("Invalid subcommand name for iteration - use the 'run' keyword if you wish to execute a script");let i=this.all?r.topLevelWorkspace:n,o=this.since?Array.from(await Rr.gitUtils.fetchChangedWorkspaces({ref:this.since,project:r})):[i,...this.from.length>0?i.getRecursiveWorkspaceChildren():[]],h=E=>Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.from),g=this.from.length>0?o.filter(h):o,f=new Set([...g,...g.map(E=>[...this.recursive?this.since?E.getRecursiveWorkspaceDependents():E.getRecursiveWorkspaceDependencies():E.getRecursiveWorkspaceChildren()]).flat()]),A=[],p=!1;if(a==null?void 0:a.includes(":")){for(let E of r.workspaces)if(E.manifest.scripts.has(a)&&(p=!p,p===!1))break}for(let E of f)a&&!E.manifest.scripts.has(a)&&!p&&!(await ge.scriptUtils.getWorkspaceAccessibleBinaries(E)).has(a)||a===process.env.npm_lifecycle_event&&E.cwd===n.cwd||this.include.length>0&&!Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.include)||this.exclude.length>0&&Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.exclude)||this.publicOnly&&E.manifest.private===!0||A.push(E);let k=this.parallel?this.jobs==="unlimited"?Infinity:this.jobs||Math.max(1,(0,yr.cpus)().length/2):1,y=k===1?!1:this.parallel,R=y?this.interlaced:!0,_=(0,br.default)(k),x=new Map,T=new Set,O=0,W=null,G=!1,ne=await Ee.StreamReport.start({configuration:t,stdout:this.context.stdout},async E=>{let b=async(C,{commandIndex:M})=>{if(G)return-1;!y&&this.verbose&&M>1&&E.reportSeparator();let l=zn(C,{configuration:t,verbose:this.verbose,commandIndex:M}),[H,w]=_r(E,{prefix:l,interlaced:R}),[j,c]=_r(E,{prefix:l,interlaced:R});try{this.verbose&&E.reportInfo(null,`${l} Process started`);let u=Date.now(),I=await this.cli.run([this.commandName,...this.args],{cwd:C.cwd,stdout:H,stderr:j})||0;H.end(),j.end(),await w,await c;let $=Date.now();if(this.verbose){let ee=t.get("enableTimers")?`, completed in ${Y.formatUtils.pretty(t,$-u,Y.formatUtils.Type.DURATION)}`:"";E.reportInfo(null,`${l} Process exited (exit code ${I})${ee}`)}return I===130&&(G=!0,W=I),I}catch(u){throw H.end(),j.end(),await w,await c,u}};for(let C of A)x.set(C.anchoredLocator.locatorHash,C);for(;x.size>0&&!E.hasErrors();){let C=[];for(let[H,w]of x){if(T.has(w.anchoredDescriptor.descriptorHash))continue;let j=!0;if(this.topological||this.topologicalDev){let c=this.topologicalDev?new Map([...w.manifest.dependencies,...w.manifest.devDependencies]):w.manifest.dependencies;for(let u of c.values()){let I=r.tryWorkspaceByDescriptor(u);if(j=I===null||!x.has(I.anchoredLocator.locatorHash),!j)break}}if(!!j&&(T.add(w.anchoredDescriptor.descriptorHash),C.push(_(async()=>{let c=await b(w,{commandIndex:++O});return x.delete(H),T.delete(w.anchoredDescriptor.descriptorHash),c})),!y))break}if(C.length===0){let H=Array.from(x.values()).map(w=>Y.structUtils.prettyLocator(t,w.anchoredLocator)).join(", ");E.reportError(Ee.MessageName.CYCLIC_DEPENDENCIES,`Dependency cycle detected (${H})`);return}let l=(await Promise.all(C)).find(H=>H!==0);W===null&&(W=typeof l!="undefined"?1:W),(this.topological||this.topologicalDev)&&typeof l!="undefined"&&E.reportError(Ee.MessageName.UNNAMED,"The command failed for workspaces that are depended upon by other workspaces; can't satisfy the dependency graph")}});return W!==null?W:ne.exitCode()}};xe.paths=[["workspaces","foreach"]],xe.usage=U.Command.Usage({category:"Workspace-related commands",description:"run a command on all workspaces",details:"\n      This command will run a given sub-command on current and all its descendant workspaces. Various flags can alter the exact behavior of the command:\n\n      - If `-p,--parallel` is set, the commands will be ran in parallel; they'll by default be limited to a number of parallel tasks roughly equal to half your core number, but that can be overridden via `-j,--jobs`, or disabled by setting `-j unlimited`.\n\n      - If `-p,--parallel` and `-i,--interlaced` are both set, Yarn will print the lines from the output as it receives them. If `-i,--interlaced` wasn't set, it would instead buffer the output from each process and print the resulting buffers only after their source processes have exited.\n\n      - If `-t,--topological` is set, Yarn will only run the command after all workspaces that it depends on through the `dependencies` field have successfully finished executing. If `--topological-dev` is set, both the `dependencies` and `devDependencies` fields will be considered when figuring out the wait points.\n\n      - If `-A,--all` is set, Yarn will run the command on all the workspaces of a project. By default yarn runs the command only on current and all its descendant workspaces.\n\n      - If `-R,--recursive` is set, Yarn will find workspaces to run the command on by recursively evaluating `dependencies` and `devDependencies` fields, instead of looking at the `workspaces` fields.\n\n      - If `--from` is set, Yarn will use the packages matching the 'from' glob as the starting point for any recursive search.\n\n      - If `--since` is set, Yarn will only run the command on workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the `changesetBaseRefs` configuration option.\n\n      - The command may apply to only some workspaces through the use of `--include` which acts as a whitelist. The `--exclude` flag will do the opposite and will be a list of packages that mustn't execute the script. Both flags accept glob patterns (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n      Adding the `-v,--verbose` flag will cause Yarn to print more information; in particular the name of the workspace that generated the output will be printed at the front of each line.\n\n      If the command is `run` and the script being run does not exist the child workspace will be skipped without error.\n    ",examples:[["Publish current and all descendant packages","yarn workspaces foreach npm publish --tolerate-republish"],["Run build script on current and all descendant packages","yarn workspaces foreach run build"],["Run build script on current and all descendant packages in parallel, building package dependencies first","yarn workspaces foreach -pt run build"],["Run build script on several packages and all their dependencies, building dependencies first","yarn workspaces foreach -ptR --from '{workspace-a,workspace-b}' run build"]]});var Er=xe;function _r(e,{prefix:t,interlaced:r}){let n=e.createStreamReporter(t),s=new Y.miscUtils.DefaultStream;s.pipe(n,{end:!1}),s.on("finish",()=>{n.end()});let a=new Promise(o=>{n.on("finish",()=>{o(s.active)})});if(r)return[s,a];let i=new Y.miscUtils.BufferStream;return i.pipe(s,{end:!1}),i.on("finish",()=>{s.end()}),[i,a]}function zn(e,{configuration:t,commandIndex:r,verbose:n}){if(!n)return null;let s=Y.structUtils.convertToIdent(e.locator),i=`[${Y.structUtils.stringifyIdent(s)}]:`,o=["#2E86AB","#A23B72","#F18F01","#C73E1D","#CCE2A3"],h=o[r%o.length];return Y.formatUtils.pretty(t,i,h)}var Jn={commands:[st,Er]},es=Jn;return Vn;})();
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`}function ql(r,e){return e.replace(/\r?\n/g,Hge(r))}var wg=J("fs"),IS=J("stream"),uK=J("util"),yS=Pe(J("zlib"));var AK=Pe(J("fs"));var $t=class extends vA{constructor(t=AK.default){super();this.realFs=t,typeof this.realFs.lutimes<"u"&&(this.lutimesPromise=this.lutimesPromiseImpl,this.lutimesSync=this.lutimesSyncImpl)}getExtractHint(){return!1}getRealPath(){return Oe.root}resolve(t){return x.resolve(t)}async openPromise(t,i,n){return await new Promise((s,o)=>{this.realFs.open(K.fromPortablePath(t),i,n,this.makeCallback(s,o))})}openSync(t,i,n){return this.realFs.openSync(K.fromPortablePath(t),i,n)}async opendirPromise(t,i){return await new Promise((n,s)=>{typeof i<"u"?this.realFs.opendir(K.fromPortablePath(t),i,this.makeCallback(n,s)):this.realFs.opendir(K.fromPortablePath(t),this.makeCallback(n,s))}).then(n=>Object.defineProperty(n,"path",{value:t,configurable:!0,writable:!0}))}opendirSync(t,i){let n=typeof i<"u"?this.realFs.opendirSync(K.fromPortablePath(t),i):this.realFs.opendirSync(K.fromPortablePath(t));return Object.defineProperty(n,"path",{value:t,configurable:!0,writable:!0})}async readPromise(t,i,n=0,s=0,o=-1){return await new Promise((a,l)=>{this.realFs.read(t,i,n,s,o,(c,u)=>{c?l(c):a(u)})})}readSync(t,i,n,s,o){return this.realFs.readSync(t,i,n,s,o)}async writePromise(t,i,n,s,o){return await new Promise((a,l)=>typeof i=="string"?this.realFs.write(t,i,n,this.makeCallback(a,l)):this.realFs.write(t,i,n,s,o,this.makeCallback(a,l)))}writeSync(t,i,n,s,o){return typeof i=="string"?this.realFs.writeSync(t,i,n):this.realFs.writeSync(t,i,n,s,o)}async closePromise(t){await new Promise((i,n)=>{this.realFs.close(t,this.makeCallback(i,n))})}closeSync(t){this.realFs.closeSync(t)}createReadStream(t,i){let n=t!==null?K.fromPortablePath(t):t;return this.realFs.createReadStream(n,i)}createWriteStream(t,i){let n=t!==null?K.fromPortablePath(t):t;return this.realFs.createWriteStream(n,i)}async realpathPromise(t){return await new Promise((i,n)=>{this.realFs.realpath(K.fromPortablePath(t),{},this.makeCallback(i,n))}).then(i=>K.toPortablePath(i))}realpathSync(t){return K.toPortablePath(this.realFs.realpathSync(K.fromPortablePath(t),{}))}async existsPromise(t){return await new Promise(i=>{this.realFs.exists(K.fromPortablePath(t),i)})}accessSync(t,i){return this.realFs.accessSync(K.fromPortablePath(t),i)}async accessPromise(t,i){return await new Promise((n,s)=>{this.realFs.access(K.fromPortablePath(t),i,this.makeCallback(n,s))})}existsSync(t){return this.realFs.existsSync(K.fromPortablePath(t))}async statPromise(t,i){return await new Promise((n,s)=>{i?this.realFs.stat(K.fromPortablePath(t),i,this.makeCallback(n,s)):this.realFs.stat(K.fromPortablePath(t),this.makeCallback(n,s))})}statSync(t,i){return i?this.realFs.statSync(K.fromPortablePath(t),i):this.realFs.statSync(K.fromPortablePath(t))}async fstatPromise(t,i){return await new Promise((n,s)=>{i?this.realFs.fstat(t,i,this.makeCallback(n,s)):this.realFs.fstat(t,this.makeCallback(n,s))})}fstatSync(t,i){return i?this.realFs.fstatSync(t,i):this.realFs.fstatSync(t)}async lstatPromise(t,i){return await new Promise((n,s)=>{i?this.realFs.lstat(K.fromPortablePath(t),i,this.makeCallback(n,s)):this.realFs.lstat(K.fromPortablePath(t),this.makeCallback(n,s))})}lstatSync(t,i){return i?this.realFs.lstatSync(K.fromPortablePath(t),i):this.realFs.lstatSync(K.fromPortablePath(t))}async fchmodPromise(t,i){return await new Promise((n,s)=>{this.realFs.fchmod(t,i,this.makeCallback(n,s))})}fchmodSync(t,i){return this.realFs.fchmodSync(t,i)}async chmodPromise(t,i){return await new Promise((n,s)=>{this.realFs.chmod(K.fromPortablePath(t),i,this.makeCallback(n,s))})}chmodSync(t,i){return this.realFs.chmodSync(K.fromPortablePath(t),i)}async fchownPromise(t,i,n){return await new Promise((s,o)=>{this.realFs.fchown(t,i,n,this.makeCallback(s,o))})}fchownSync(t,i,n){return this.realFs.fchownSync(t,i,n)}async chownPromise(t,i,n){return await new Promise((s,o)=>{this.realFs.chown(K.fromPortablePath(t),i,n,this.makeCallback(s,o))})}chownSync(t,i,n){return this.realFs.chownSync(K.fromPortablePath(t),i,n)}async renamePromise(t,i){return await new Promise((n,s)=>{this.realFs.rename(K.fromPortablePath(t),K.fromPortablePath(i),this.makeCallback(n,s))})}renameSync(t,i){return this.realFs.renameSync(K.fromPortablePath(t),K.fromPortablePath(i))}async copyFilePromise(t,i,n=0){return await new Promise((s,o)=>{this.realFs.copyFile(K.fromPortablePath(t),K.fromPortablePath(i),n,this.makeCallback(s,o))})}copyFileSync(t,i,n=0){return this.realFs.copyFileSync(K.fromPortablePath(t),K.fromPortablePath(i),n)}async appendFilePromise(t,i,n){return await new Promise((s,o)=>{let a=typeof t=="string"?K.fromPortablePath(t):t;n?this.realFs.appendFile(a,i,n,this.makeCallback(s,o)):this.realFs.appendFile(a,i,this.makeCallback(s,o))})}appendFileSync(t,i,n){let s=typeof t=="string"?K.fromPortablePath(t):t;n?this.realFs.appendFileSync(s,i,n):this.realFs.appendFileSync(s,i)}async writeFilePromise(t,i,n){return await new Promise((s,o)=>{let a=typeof t=="string"?K.fromPortablePath(t):t;n?this.realFs.writeFile(a,i,n,this.makeCallback(s,o)):this.realFs.writeFile(a,i,this.makeCallback(s,o))})}writeFileSync(t,i,n){let s=typeof t=="string"?K.fromPortablePath(t):t;n?this.realFs.writeFileSync(s,i,n):this.realFs.writeFileSync(s,i)}async unlinkPromise(t){return await new Promise((i,n)=>{this.realFs.unlink(K.fromPortablePath(t),this.makeCallback(i,n))})}unlinkSync(t){return this.realFs.unlinkSync(K.fromPortablePath(t))}async utimesPromise(t,i,n){return await new Promise((s,o)=>{this.realFs.utimes(K.fromPortablePath(t),i,n,this.makeCallback(s,o))})}utimesSync(t,i,n){this.realFs.utimesSync(K.fromPortablePath(t),i,n)}async lutimesPromiseImpl(t,i,n){let s=this.realFs.lutimes;if(typeof s>"u")throw Mp("unavailable Node binding",`lutimes '${t}'`);return await new Promise((o,a)=>{s.call(this.realFs,K.fromPortablePath(t),i,n,this.makeCallback(o,a))})}lutimesSyncImpl(t,i,n){let s=this.realFs.lutimesSync;if(typeof s>"u")throw Mp("unavailable Node binding",`lutimes '${t}'`);s.call(this.realFs,K.fromPortablePath(t),i,n)}async mkdirPromise(t,i){return await new Promise((n,s)=>{this.realFs.mkdir(K.fromPortablePath(t),i,this.makeCallback(n,s))})}mkdirSync(t,i){return this.realFs.mkdirSync(K.fromPortablePath(t),i)}async rmdirPromise(t,i){return await new Promise((n,s)=>{i?this.realFs.rmdir(K.fromPortablePath(t),i,this.makeCallback(n,s)):this.realFs.rmdir(K.fromPortablePath(t),this.makeCallback(n,s))})}rmdirSync(t,i){return this.realFs.rmdirSync(K.fromPortablePath(t),i)}async linkPromise(t,i){return await new Promise((n,s)=>{this.realFs.link(K.fromPortablePath(t),K.fromPortablePath(i),this.makeCallback(n,s))})}linkSync(t,i){return this.realFs.linkSync(K.fromPortablePath(t),K.fromPortablePath(i))}async symlinkPromise(t,i,n){return await new Promise((s,o)=>{this.realFs.symlink(K.fromPortablePath(t.replace(/\/+$/,"")),K.fromPortablePath(i),n,this.makeCallback(s,o))})}symlinkSync(t,i,n){return this.realFs.symlinkSync(K.fromPortablePath(t.replace(/\/+$/,"")),K.fromPortablePath(i),n)}async readFilePromise(t,i){return await new Promise((n,s)=>{let o=typeof t=="string"?K.fromPortablePath(t):t;this.realFs.readFile(o,i,this.makeCallback(n,s))})}readFileSync(t,i){let n=typeof t=="string"?K.fromPortablePath(t):t;return this.realFs.readFileSync(n,i)}async readdirPromise(t,i){return await new Promise((n,s)=>{i!=null&&i.withFileTypes?this.realFs.readdir(K.fromPortablePath(t),{withFileTypes:!0},this.makeCallback(n,s)):this.realFs.readdir(K.fromPortablePath(t),this.makeCallback(o=>n(o),s))})}readdirSync(t,i){return i!=null&&i.withFileTypes?this.realFs.readdirSync(K.fromPortablePath(t),{withFileTypes:!0}):this.realFs.readdirSync(K.fromPortablePath(t))}async readlinkPromise(t){return await new Promise((i,n)=>{this.realFs.readlink(K.fromPortablePath(t),this.makeCallback(i,n))}).then(i=>K.toPortablePath(i))}readlinkSync(t){return K.toPortablePath(this.realFs.readlinkSync(K.fromPortablePath(t)))}async truncatePromise(t,i){return await new Promise((n,s)=>{this.realFs.truncate(K.fromPortablePath(t),i,this.makeCallback(n,s))})}truncateSync(t,i){return this.realFs.truncateSync(K.fromPortablePath(t),i)}async ftruncatePromise(t,i){return await new Promise((n,s)=>{this.realFs.ftruncate(t,i,this.makeCallback(n,s))})}ftruncateSync(t,i){return this.realFs.ftruncateSync(t,i)}watch(t,i,n){return this.realFs.watch(K.fromPortablePath(t),i,n)}watchFile(t,i,n){return this.realFs.watchFile(K.fromPortablePath(t),i,n)}unwatchFile(t,i){return this.realFs.unwatchFile(K.fromPortablePath(t),i)}makeCallback(t,i){return(n,s)=>{n?i(n):t(s)}}};var cK=J("events");function lK(r,e){if(r!==e)throw new Error(`Invalid StatWatcher status: expected '${e}', got '${r}'`)}var yg=class extends cK.EventEmitter{constructor(t,i,{bigint:n=!1}={}){super();this.status="ready";this.changeListeners=new Map;this.startTimeout=null;this.fakeFs=t,this.path=i,this.bigint=n,this.lastStats=this.stat()}static create(t,i,n){let s=new yg(t,i,n);return s.start(),s}start(){lK(this.status,"ready"),this.status="running",this.startTimeout=setTimeout(()=>{this.startTimeout=null,this.fakeFs.existsSync(this.path)||this.emit("change",this.lastStats,this.lastStats)},3)}stop(){lK(this.status,"running"),this.status="stopped",this.startTimeout!==null&&(clearTimeout(this.startTimeout),this.startTimeout=null),this.emit("stop")}stat(){try{return this.fakeFs.statSync(this.path,{bigint:this.bigint})}catch{let i=this.bigint?new Ig:new ma;return YE(i)}}makeInterval(t){let i=setInterval(()=>{let n=this.stat(),s=this.lastStats;uS(n,s)||(this.lastStats=n,this.emit("change",n,s))},t.interval);return t.persistent?i:i.unref()}registerChangeListener(t,i){this.addListener("change",t),this.changeListeners.set(t,this.makeInterval(i))}unregisterChangeListener(t){this.removeListener("change",t);let i=this.changeListeners.get(t);typeof i<"u"&&clearInterval(i),this.changeListeners.delete(t)}unregisterAllChangeListeners(){for(let t of this.changeListeners.keys())this.unregisterChangeListener(t)}hasChangeListeners(){return this.changeListeners.size>0}ref(){for(let t of this.changeListeners.values())t.ref();return this}unref(){for(let t of this.changeListeners.values())t.unref();return this}};var _E=new WeakMap;function $E(r,e,t,i){let n,s,o,a;switch(typeof t){case"function":n=!1,s=!0,o=5007,a=t;break;default:({bigint:n=!1,persistent:s=!0,interval:o=5007}=t),a=i;break}let l=_E.get(r);typeof l>"u"&&_E.set(r,l=new Map);let c=l.get(e);return typeof c>"u"&&(c=yg.create(r,e,{bigint:n}),l.set(e,c)),c.registerChangeListener(a,{persistent:s,interval:o}),c}function Up(r,e,t){let i=_E.get(r);if(typeof i>"u")return;let n=i.get(e);typeof n>"u"||(typeof t>"u"?n.unregisterAllChangeListeners():n.unregisterChangeListener(t),n.hasChangeListeners()||(n.stop(),i.delete(e)))}function Hp(r){let e=_E.get(r);if(!(typeof e>"u"))for(let t of e.keys())Up(r,t)}var Jl="mixed";function Gge(r){if(typeof r=="string"&&String(+r)===r)return+r;if(typeof r=="number"&&Number.isFinite(r))return r<0?Date.now()/1e3:r;if(uK.types.isDate(r))return r.getTime()/1e3;throw new Error("Invalid time")}function ES(){return Buffer.from([80,75,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])}var Wr=class extends vA{constructor(t,i){super();this.lzSource=null;this.listings=new Map;this.entries=new Map;this.fileSources=new Map;this.fds=new Map;this.nextFd=0;this.ready=!1;this.readOnly=!1;this.libzip=i.libzip;let n=i;if(this.level=typeof n.level<"u"?n.level:Jl,t!=null||(t=ES()),typeof t=="string"){let{baseFs:a=new $t}=n;this.baseFs=a,this.path=t}else this.path=null,this.baseFs=null;if(i.stats)this.stats=i.stats;else if(typeof t=="string")try{this.stats=this.baseFs.statSync(t)}catch(a){if(a.code==="ENOENT"&&n.create)this.stats=Lp();else throw a}else this.stats=Lp();let s=this.libzip.malloc(4);try{let a=0;if(typeof t=="string"&&n.create&&(a|=this.libzip.ZIP_CREATE|this.libzip.ZIP_TRUNCATE),i.readOnly&&(a|=this.libzip.ZIP_RDONLY,this.readOnly=!0),typeof t=="string")this.zip=this.libzip.open(K.fromPortablePath(t),a,s);else{let l=this.allocateUnattachedSource(t);try{this.zip=this.libzip.openFromSource(l,a,s),this.lzSource=l}catch(c){throw this.libzip.source.free(l),c}}if(this.zip===0){let l=this.libzip.struct.errorS();throw this.libzip.error.initWithCode(l,this.libzip.getValue(s,"i32")),this.makeLibzipError(l)}}finally{this.libzip.free(s)}this.listings.set(Oe.root,new Set);let o=this.libzip.getNumEntries(this.zip,0);for(let a=0;a<o;++a){let l=this.libzip.getName(this.zip,a,0);if(x.isAbsolute(l))continue;let c=x.resolve(Oe.root,l);this.registerEntry(c,a),l.endsWith("/")&&this.registerListing(c)}if(this.symlinkCount=this.libzip.ext.countSymlinks(this.zip),this.symlinkCount===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));this.ready=!0}makeLibzipError(t){let i=this.libzip.struct.errorCodeZip(t),n=this.libzip.error.strerror(t),s=new zE(n,this.libzip.errors[i]);if(i===this.libzip.errors.ZIP_ER_CHANGED)throw new Error(`Assertion failed: Unexpected libzip error: ${s.message}`);return s}getExtractHint(t){for(let i of this.entries.keys()){let n=this.pathUtils.extname(i);if(t.relevantExtensions.has(n))return!0}return!1}getAllFiles(){return Array.from(this.entries.keys())}getRealPath(){if(!this.path)throw new Error("ZipFS don't have real paths when loaded from a buffer");return this.path}getBufferAndClose(){if(this.prepareClose(),!this.lzSource)throw new Error("ZipFS was not created from a Buffer");if(this.entries.size===0)return this.discardAndClose(),ES();try{if(this.libzip.source.keep(this.lzSource),this.libzip.close(this.zip)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));if(this.libzip.source.open(this.lzSource)===-1)throw this.makeLibzipError(this.libzip.source.error(this.lzSource));if(this.libzip.source.seek(this.lzSource,0,0,this.libzip.SEEK_END)===-1)throw this.makeLibzipError(this.libzip.source.error(this.lzSource));let t=this.libzip.source.tell(this.lzSource);if(t===-1)throw this.makeLibzipError(this.libzip.source.error(this.lzSource));if(this.libzip.source.seek(this.lzSource,0,0,this.libzip.SEEK_SET)===-1)throw this.makeLibzipError(this.libzip.source.error(this.lzSource));let i=this.libzip.malloc(t);if(!i)throw new Error("Couldn't allocate enough memory");try{let n=this.libzip.source.read(this.lzSource,i,t);if(n===-1)throw this.makeLibzipError(this.libzip.source.error(this.lzSource));if(n<t)throw new Error("Incomplete read");if(n>t)throw new Error("Overread");let s=this.libzip.HEAPU8.subarray(i,i+t);return Buffer.from(s)}finally{this.libzip.free(i)}}finally{this.libzip.source.close(this.lzSource),this.libzip.source.free(this.lzSource),this.ready=!1}}prepareClose(){if(!this.ready)throw VE("archive closed, close");Hp(this)}saveAndClose(){if(!this.path||!this.baseFs)throw new Error("ZipFS cannot be saved and must be discarded when loaded from a buffer");if(this.prepareClose(),this.readOnly){this.discardAndClose();return}let t=this.baseFs.existsSync(this.path)||this.stats.mode===Np?void 0:this.stats.mode;if(this.entries.size===0)this.discardAndClose(),this.baseFs.writeFileSync(this.path,ES(),{mode:t});else{if(this.libzip.close(this.zip)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));typeof t<"u"&&this.baseFs.chmodSync(this.path,t)}this.ready=!1}discardAndClose(){this.prepareClose(),this.libzip.discard(this.zip),this.ready=!1}resolve(t){return x.resolve(Oe.root,t)}async openPromise(t,i,n){return this.openSync(t,i,n)}openSync(t,i,n){let s=this.nextFd++;return this.fds.set(s,{cursor:0,p:t}),s}hasOpenFileHandles(){return!!this.fds.size}async opendirPromise(t,i){return this.opendirSync(t,i)}opendirSync(t,i={}){let n=this.resolveFilename(`opendir '${t}'`,t);if(!this.entries.has(n)&&!this.listings.has(n))throw js(`opendir '${t}'`);let s=this.listings.get(n);if(!s)throw Qo(`opendir '${t}'`);let o=[...s],a=this.openSync(n,"r");return ZE(this,n,o,{onClose:()=>{this.closeSync(a)}})}async readPromise(t,i,n,s,o){return this.readSync(t,i,n,s,o)}readSync(t,i,n=0,s=i.byteLength,o=-1){let a=this.fds.get(t);if(typeof a>"u")throw Hr("read");let l=o===-1||o===null?a.cursor:o,c=this.readFileSync(a.p);c.copy(i,n,l,l+s);let u=Math.max(0,Math.min(c.length-l,s));return(o===-1||o===null)&&(a.cursor+=u),u}async writePromise(t,i,n,s,o){return typeof i=="string"?this.writeSync(t,i,o):this.writeSync(t,i,n,s,o)}writeSync(t,i,n,s,o){throw typeof this.fds.get(t)>"u"?Hr("read"):new Error("Unimplemented")}async closePromise(t){return this.closeSync(t)}closeSync(t){if(typeof this.fds.get(t)>"u")throw Hr("read");this.fds.delete(t)}createReadStream(t,{encoding:i}={}){if(t===null)throw new Error("Unimplemented");let n=this.openSync(t,"r"),s=Object.assign(new IS.PassThrough({emitClose:!0,autoDestroy:!0,destroy:(a,l)=>{clearImmediate(o),this.closeSync(n),l(a)}}),{close(){s.destroy()},bytesRead:0,path:t}),o=setImmediate(async()=>{try{let a=await this.readFilePromise(t,i);s.bytesRead=a.length,s.end(a)}catch(a){s.destroy(a)}});return s}createWriteStream(t,{encoding:i}={}){if(this.readOnly)throw ln(`open '${t}'`);if(t===null)throw new Error("Unimplemented");let n=[],s=this.openSync(t,"w"),o=Object.assign(new IS.PassThrough({autoDestroy:!0,emitClose:!0,destroy:(a,l)=>{try{a?l(a):(this.writeFileSync(t,Buffer.concat(n),i),l(null))}catch(c){l(c)}finally{this.closeSync(s)}}}),{bytesWritten:0,path:t,close(){o.destroy()}});return o.on("data",a=>{let l=Buffer.from(a);o.bytesWritten+=l.length,n.push(l)}),o}async realpathPromise(t){return this.realpathSync(t)}realpathSync(t){let i=this.resolveFilename(`lstat '${t}'`,t);if(!this.entries.has(i)&&!this.listings.has(i))throw js(`lstat '${t}'`);return i}async existsPromise(t){return this.existsSync(t)}existsSync(t){if(!this.ready)throw VE(`archive closed, existsSync '${t}'`);if(this.symlinkCount===0){let n=x.resolve(Oe.root,t);return this.entries.has(n)||this.listings.has(n)}let i;try{i=this.resolveFilename(`stat '${t}'`,t,void 0,!1)}catch{return!1}return i===void 0?!1:this.entries.has(i)||this.listings.has(i)}async accessPromise(t,i){return this.accessSync(t,i)}accessSync(t,i=wg.constants.F_OK){let n=this.resolveFilename(`access '${t}'`,t);if(!this.entries.has(n)&&!this.listings.has(n))throw js(`access '${t}'`);if(this.readOnly&&i&wg.constants.W_OK)throw ln(`access '${t}'`)}async statPromise(t,i={bigint:!1}){return i.bigint?this.statSync(t,{bigint:!0}):this.statSync(t)}statSync(t,i={bigint:!1,throwIfNoEntry:!0}){let n=this.resolveFilename(`stat '${t}'`,t,void 0,i.throwIfNoEntry);if(n!==void 0){if(!this.entries.has(n)&&!this.listings.has(n)){if(i.throwIfNoEntry===!1)return;throw js(`stat '${t}'`)}if(t[t.length-1]==="/"&&!this.listings.has(n))throw Qo(`stat '${t}'`);return this.statImpl(`stat '${t}'`,n,i)}}async fstatPromise(t,i){return this.fstatSync(t,i)}fstatSync(t,i){let n=this.fds.get(t);if(typeof n>"u")throw Hr("fstatSync");let{p:s}=n,o=this.resolveFilename(`stat '${s}'`,s);if(!this.entries.has(o)&&!this.listings.has(o))throw js(`stat '${s}'`);if(s[s.length-1]==="/"&&!this.listings.has(o))throw Qo(`stat '${s}'`);return this.statImpl(`fstat '${s}'`,o,i)}async lstatPromise(t,i={bigint:!1}){return i.bigint?this.lstatSync(t,{bigint:!0}):this.lstatSync(t)}lstatSync(t,i={bigint:!1,throwIfNoEntry:!0}){let n=this.resolveFilename(`lstat '${t}'`,t,!1,i.throwIfNoEntry);if(n!==void 0){if(!this.entries.has(n)&&!this.listings.has(n)){if(i.throwIfNoEntry===!1)return;throw js(`lstat '${t}'`)}if(t[t.length-1]==="/"&&!this.listings.has(n))throw Qo(`lstat '${t}'`);return this.statImpl(`lstat '${t}'`,n,i)}}statImpl(t,i,n={}){let s=this.entries.get(i);if(typeof s<"u"){let o=this.libzip.struct.statS();if(this.libzip.statIndex(this.zip,s,0,0,o)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));let l=this.stats.uid,c=this.stats.gid,u=this.libzip.struct.statSize(o)>>>0,g=512,f=Math.ceil(u/g),h=(this.libzip.struct.statMtime(o)>>>0)*1e3,p=h,C=h,y=h,B=new Date(p),v=new Date(C),D=new Date(y),L=new Date(h),H=this.listings.has(i)?16384:this.isSymbolicLink(s)?40960:32768,j=H===16384?493:420,$=H|this.getUnixMode(s,j)&511,V=this.libzip.struct.statCrc(o),W=Object.assign(new ma,{uid:l,gid:c,size:u,blksize:g,blocks:f,atime:B,birthtime:v,ctime:D,mtime:L,atimeMs:p,birthtimeMs:C,ctimeMs:y,mtimeMs:h,mode:$,crc:V});return n.bigint===!0?jE(W):W}if(this.listings.has(i)){let o=this.stats.uid,a=this.stats.gid,l=0,c=512,u=0,g=this.stats.mtimeMs,f=this.stats.mtimeMs,h=this.stats.mtimeMs,p=this.stats.mtimeMs,C=new Date(g),y=new Date(f),B=new Date(h),v=new Date(p),D=16877,L=0,H=Object.assign(new ma,{uid:o,gid:a,size:l,blksize:c,blocks:u,atime:C,birthtime:y,ctime:B,mtime:v,atimeMs:g,birthtimeMs:f,ctimeMs:h,mtimeMs:p,mode:D,crc:L});return n.bigint===!0?jE(H):H}throw new Error("Unreachable")}getUnixMode(t,i){if(this.libzip.file.getExternalAttributes(this.zip,t,0,0,this.libzip.uint08S,this.libzip.uint32S)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));return this.libzip.getValue(this.libzip.uint08S,"i8")>>>0!==this.libzip.ZIP_OPSYS_UNIX?i:this.libzip.getValue(this.libzip.uint32S,"i32")>>>16}registerListing(t){let i=this.listings.get(t);if(i)return i;this.registerListing(x.dirname(t)).add(x.basename(t));let s=new Set;return this.listings.set(t,s),s}registerEntry(t,i){this.registerListing(x.dirname(t)).add(x.basename(t)),this.entries.set(t,i)}unregisterListing(t){this.listings.delete(t);let i=this.listings.get(x.dirname(t));i==null||i.delete(x.basename(t))}unregisterEntry(t){this.unregisterListing(t);let i=this.entries.get(t);this.entries.delete(t),!(typeof i>"u")&&(this.fileSources.delete(i),this.isSymbolicLink(i)&&this.symlinkCount--)}deleteEntry(t,i){if(this.unregisterEntry(t),this.libzip.delete(this.zip,i)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip))}resolveFilename(t,i,n=!0,s=!0){if(!this.ready)throw VE(`archive closed, ${t}`);let o=x.resolve(Oe.root,i);if(o==="/")return Oe.root;let a=this.entries.get(o);if(n&&a!==void 0)if(this.symlinkCount!==0&&this.isSymbolicLink(a)){let l=this.getFileSource(a).toString();return this.resolveFilename(t,x.resolve(x.dirname(o),l),!0,s)}else return o;for(;;){let l=this.resolveFilename(t,x.dirname(o),!0,s);if(l===void 0)return l;let c=this.listings.has(l),u=this.entries.has(l);if(!c&&!u){if(s===!1)return;throw js(t)}if(!c)throw Qo(t);if(o=x.resolve(l,x.basename(o)),!n||this.symlinkCount===0)break;let g=this.libzip.name.locate(this.zip,o.slice(1),0);if(g===-1)break;if(this.isSymbolicLink(g)){let f=this.getFileSource(g).toString();o=x.resolve(x.dirname(o),f)}else break}return o}allocateBuffer(t){Buffer.isBuffer(t)||(t=Buffer.from(t));let i=this.libzip.malloc(t.byteLength);if(!i)throw new Error("Couldn't allocate enough memory");return new Uint8Array(this.libzip.HEAPU8.buffer,i,t.byteLength).set(t),{buffer:i,byteLength:t.byteLength}}allocateUnattachedSource(t){let i=this.libzip.struct.errorS(),{buffer:n,byteLength:s}=this.allocateBuffer(t),o=this.libzip.source.fromUnattachedBuffer(n,s,0,1,i);if(o===0)throw this.libzip.free(i),this.makeLibzipError(i);return o}allocateSource(t){let{buffer:i,byteLength:n}=this.allocateBuffer(t),s=this.libzip.source.fromBuffer(this.zip,i,n,0,1);if(s===0)throw this.libzip.free(i),this.makeLibzipError(this.libzip.getError(this.zip));return s}setFileSource(t,i){let n=Buffer.isBuffer(i)?i:Buffer.from(i),s=x.relative(Oe.root,t),o=this.allocateSource(i);try{let a=this.libzip.file.add(this.zip,s,o,this.libzip.ZIP_FL_OVERWRITE);if(a===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));if(this.level!=="mixed"){let l=this.level===0?this.libzip.ZIP_CM_STORE:this.libzip.ZIP_CM_DEFLATE;if(this.libzip.file.setCompression(this.zip,a,0,l,this.level)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip))}return this.fileSources.set(a,n),a}catch(a){throw this.libzip.source.free(o),a}}isSymbolicLink(t){if(this.symlinkCount===0)return!1;if(this.libzip.file.getExternalAttributes(this.zip,t,0,0,this.libzip.uint08S,this.libzip.uint32S)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));return this.libzip.getValue(this.libzip.uint08S,"i8")>>>0!==this.libzip.ZIP_OPSYS_UNIX?!1:(this.libzip.getValue(this.libzip.uint32S,"i32")>>>16&61440)===40960}getFileSource(t,i={asyncDecompress:!1}){let n=this.fileSources.get(t);if(typeof n<"u")return n;let s=this.libzip.struct.statS();if(this.libzip.statIndex(this.zip,t,0,0,s)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));let a=this.libzip.struct.statCompSize(s),l=this.libzip.struct.statCompMethod(s),c=this.libzip.malloc(a);try{let u=this.libzip.fopenIndex(this.zip,t,0,this.libzip.ZIP_FL_COMPRESSED);if(u===0)throw this.makeLibzipError(this.libzip.getError(this.zip));try{let g=this.libzip.fread(u,c,a,0);if(g===-1)throw this.makeLibzipError(this.libzip.file.getError(u));if(g<a)throw new Error("Incomplete read");if(g>a)throw new Error("Overread");let f=this.libzip.HEAPU8.subarray(c,c+a),h=Buffer.from(f);if(l===0)return this.fileSources.set(t,h),h;if(i.asyncDecompress)return new Promise((p,C)=>{yS.default.inflateRaw(h,(y,B)=>{y?C(y):(this.fileSources.set(t,B),p(B))})});{let p=yS.default.inflateRawSync(h);return this.fileSources.set(t,p),p}}finally{this.libzip.fclose(u)}}finally{this.libzip.free(c)}}async fchmodPromise(t,i){return this.chmodPromise(this.fdToPath(t,"fchmod"),i)}fchmodSync(t,i){return this.chmodSync(this.fdToPath(t,"fchmodSync"),i)}async chmodPromise(t,i){return this.chmodSync(t,i)}chmodSync(t,i){if(this.readOnly)throw ln(`chmod '${t}'`);i&=493;let n=this.resolveFilename(`chmod '${t}'`,t,!1),s=this.entries.get(n);if(typeof s>"u")throw new Error(`Assertion failed: The entry should have been registered (${n})`);let a=this.getUnixMode(s,32768)&-512|i;if(this.libzip.file.setExternalAttributes(this.zip,s,0,0,this.libzip.ZIP_OPSYS_UNIX,a<<16)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip))}async fchownPromise(t,i,n){return this.chownPromise(this.fdToPath(t,"fchown"),i,n)}fchownSync(t,i,n){return this.chownSync(this.fdToPath(t,"fchownSync"),i,n)}async chownPromise(t,i,n){return this.chownSync(t,i,n)}chownSync(t,i,n){throw new Error("Unimplemented")}async renamePromise(t,i){return this.renameSync(t,i)}renameSync(t,i){throw new Error("Unimplemented")}async copyFilePromise(t,i,n){let{indexSource:s,indexDest:o,resolvedDestP:a}=this.prepareCopyFile(t,i,n),l=await this.getFileSource(s,{asyncDecompress:!0}),c=this.setFileSource(a,l);c!==o&&this.registerEntry(a,c)}copyFileSync(t,i,n=0){let{indexSource:s,indexDest:o,resolvedDestP:a}=this.prepareCopyFile(t,i,n),l=this.getFileSource(s),c=this.setFileSource(a,l);c!==o&&this.registerEntry(a,c)}prepareCopyFile(t,i,n=0){if(this.readOnly)throw ln(`copyfile '${t} -> '${i}'`);if((n&wg.constants.COPYFILE_FICLONE_FORCE)!==0)throw Mp("unsupported clone operation",`copyfile '${t}' -> ${i}'`);let s=this.resolveFilename(`copyfile '${t} -> ${i}'`,t),o=this.entries.get(s);if(typeof o>"u")throw SA(`copyfile '${t}' -> '${i}'`);let a=this.resolveFilename(`copyfile '${t}' -> ${i}'`,i),l=this.entries.get(a);if((n&(wg.constants.COPYFILE_EXCL|wg.constants.COPYFILE_FICLONE_FORCE))!==0&&typeof l<"u")throw XE(`copyfile '${t}' -> '${i}'`);return{indexSource:o,resolvedDestP:a,indexDest:l}}async appendFilePromise(t,i,n){if(this.readOnly)throw ln(`open '${t}'`);return typeof n>"u"?n={flag:"a"}:typeof n=="string"?n={flag:"a",encoding:n}:typeof n.flag>"u"&&(n={flag:"a",...n}),this.writeFilePromise(t,i,n)}appendFileSync(t,i,n={}){if(this.readOnly)throw ln(`open '${t}'`);return typeof n>"u"?n={flag:"a"}:typeof n=="string"?n={flag:"a",encoding:n}:typeof n.flag>"u"&&(n={flag:"a",...n}),this.writeFileSync(t,i,n)}fdToPath(t,i){var s;let n=(s=this.fds.get(t))==null?void 0:s.p;if(typeof n>"u")throw Hr(i);return n}async writeFilePromise(t,i,n){let{encoding:s,mode:o,index:a,resolvedP:l}=this.prepareWriteFile(t,n);a!==void 0&&typeof n=="object"&&n.flag&&n.flag.includes("a")&&(i=Buffer.concat([await this.getFileSource(a,{asyncDecompress:!0}),Buffer.from(i)])),s!==null&&(i=i.toString(s));let c=this.setFileSource(l,i);c!==a&&this.registerEntry(l,c),o!==null&&await this.chmodPromise(l,o)}writeFileSync(t,i,n){let{encoding:s,mode:o,index:a,resolvedP:l}=this.prepareWriteFile(t,n);a!==void 0&&typeof n=="object"&&n.flag&&n.flag.includes("a")&&(i=Buffer.concat([this.getFileSource(a),Buffer.from(i)])),s!==null&&(i=i.toString(s));let c=this.setFileSource(l,i);c!==a&&this.registerEntry(l,c),o!==null&&this.chmodSync(l,o)}prepareWriteFile(t,i){if(typeof t=="number"&&(t=this.fdToPath(t,"read")),this.readOnly)throw ln(`open '${t}'`);let n=this.resolveFilename(`open '${t}'`,t);if(this.listings.has(n))throw Kp(`open '${t}'`);let s=null,o=null;typeof i=="string"?s=i:typeof i=="object"&&({encoding:s=null,mode:o=null}=i);let a=this.entries.get(n);return{encoding:s,mode:o,resolvedP:n,index:a}}async unlinkPromise(t){return this.unlinkSync(t)}unlinkSync(t){if(this.readOnly)throw ln(`unlink '${t}'`);let i=this.resolveFilename(`unlink '${t}'`,t);if(this.listings.has(i))throw Kp(`unlink '${t}'`);let n=this.entries.get(i);if(typeof n>"u")throw SA(`unlink '${t}'`);this.deleteEntry(i,n)}async utimesPromise(t,i,n){return this.utimesSync(t,i,n)}utimesSync(t,i,n){if(this.readOnly)throw ln(`utimes '${t}'`);let s=this.resolveFilename(`utimes '${t}'`,t);this.utimesImpl(s,n)}async lutimesPromise(t,i,n){return this.lutimesSync(t,i,n)}lutimesSync(t,i,n){if(this.readOnly)throw ln(`lutimes '${t}'`);let s=this.resolveFilename(`utimes '${t}'`,t,!1);this.utimesImpl(s,n)}utimesImpl(t,i){this.listings.has(t)&&(this.entries.has(t)||this.hydrateDirectory(t));let n=this.entries.get(t);if(n===void 0)throw new Error("Unreachable");if(this.libzip.file.setMtime(this.zip,n,0,Gge(i),0)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip))}async mkdirPromise(t,i){return this.mkdirSync(t,i)}mkdirSync(t,{mode:i=493,recursive:n=!1}={}){if(n)return this.mkdirpSync(t,{chmod:i});if(this.readOnly)throw ln(`mkdir '${t}'`);let s=this.resolveFilename(`mkdir '${t}'`,t);if(this.entries.has(s)||this.listings.has(s))throw XE(`mkdir '${t}'`);this.hydrateDirectory(s),this.chmodSync(s,i)}async rmdirPromise(t,i){return this.rmdirSync(t,i)}rmdirSync(t,{recursive:i=!1}={}){if(this.readOnly)throw ln(`rmdir '${t}'`);if(i){this.removeSync(t);return}let n=this.resolveFilename(`rmdir '${t}'`,t),s=this.listings.get(n);if(!s)throw Qo(`rmdir '${t}'`);if(s.size>0)throw nK(`rmdir '${t}'`);let o=this.entries.get(n);if(typeof o>"u")throw SA(`rmdir '${t}'`);this.deleteEntry(t,o)}hydrateDirectory(t){let i=this.libzip.dir.add(this.zip,x.relative(Oe.root,t));if(i===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));return this.registerListing(t),this.registerEntry(t,i),i}async linkPromise(t,i){return this.linkSync(t,i)}linkSync(t,i){throw sK(`link '${t}' -> '${i}'`)}async symlinkPromise(t,i){return this.symlinkSync(t,i)}symlinkSync(t,i){if(this.readOnly)throw ln(`symlink '${t}' -> '${i}'`);let n=this.resolveFilename(`symlink '${t}' -> '${i}'`,i);if(this.listings.has(n))throw Kp(`symlink '${t}' -> '${i}'`);if(this.entries.has(n))throw XE(`symlink '${t}' -> '${i}'`);let s=this.setFileSource(n,t);if(this.registerEntry(n,s),this.libzip.file.setExternalAttributes(this.zip,s,0,0,this.libzip.ZIP_OPSYS_UNIX,41471<<16)===-1)throw this.makeLibzipError(this.libzip.getError(this.zip));this.symlinkCount+=1}async readFilePromise(t,i){typeof i=="object"&&(i=i?i.encoding:void 0);let n=await this.readFileBuffer(t,{asyncDecompress:!0});return i?n.toString(i):n}readFileSync(t,i){typeof i=="object"&&(i=i?i.encoding:void 0);let n=this.readFileBuffer(t);return i?n.toString(i):n}readFileBuffer(t,i={asyncDecompress:!1}){typeof t=="number"&&(t=this.fdToPath(t,"read"));let n=this.resolveFilename(`open '${t}'`,t);if(!this.entries.has(n)&&!this.listings.has(n))throw js(`open '${t}'`);if(t[t.length-1]==="/"&&!this.listings.has(n))throw Qo(`open '${t}'`);if(this.listings.has(n))throw Kp("read");let s=this.entries.get(n);if(s===void 0)throw new Error("Unreachable");return this.getFileSource(s,i)}async readdirPromise(t,i){return this.readdirSync(t,i)}readdirSync(t,i){let n=this.resolveFilename(`scandir '${t}'`,t);if(!this.entries.has(n)&&!this.listings.has(n))throw js(`scandir '${t}'`);let s=this.listings.get(n);if(!s)throw Qo(`scandir '${t}'`);let o=[...s];return i!=null&&i.withFileTypes?o.map(a=>Object.assign(this.statImpl("lstat",x.join(t,a)),{name:a})):o}async readlinkPromise(t){let i=this.prepareReadlink(t);return(await this.getFileSource(i,{asyncDecompress:!0})).toString()}readlinkSync(t){let i=this.prepareReadlink(t);return this.getFileSource(i).toString()}prepareReadlink(t){let i=this.resolveFilename(`readlink '${t}'`,t,!1);if(!this.entries.has(i)&&!this.listings.has(i))throw js(`readlink '${t}'`);if(t[t.length-1]==="/"&&!this.listings.has(i))throw Qo(`open '${t}'`);if(this.listings.has(i))throw SA(`readlink '${t}'`);let n=this.entries.get(i);if(n===void 0)throw new Error("Unreachable");if(!this.isSymbolicLink(n))throw SA(`readlink '${t}'`);return n}async truncatePromise(t,i=0){let n=this.resolveFilename(`open '${t}'`,t),s=this.entries.get(n);if(typeof s>"u")throw SA(`open '${t}'`);let o=await this.getFileSource(s,{asyncDecompress:!0}),a=Buffer.alloc(i,0);return o.copy(a),await this.writeFilePromise(t,a)}truncateSync(t,i=0){let n=this.resolveFilename(`open '${t}'`,t),s=this.entries.get(n);if(typeof s>"u")throw SA(`open '${t}'`);let o=this.getFileSource(s),a=Buffer.alloc(i,0);return o.copy(a),this.writeFileSync(t,a)}async ftruncatePromise(t,i){return this.truncatePromise(this.fdToPath(t,"ftruncate"),i)}ftruncateSync(t,i){return this.truncateSync(this.fdToPath(t,"ftruncateSync"),i)}watch(t,i,n){let s;switch(typeof i){case"function":case"string":case"undefined":s=!0;break;default:({persistent:s=!0}=i);break}if(!s)return{on:()=>{},close:()=>{}};let o=setInterval(()=>{},24*60*60*1e3);return{on:()=>{},close:()=>{clearInterval(o)}}}watchFile(t,i,n){let s=x.resolve(Oe.root,t);return $E(this,s,i,n)}unwatchFile(t,i){let n=x.resolve(Oe.root,t);return Up(this,n,i)}};var pi=class extends Ea{getExtractHint(e){return this.baseFs.getExtractHint(e)}resolve(e){return this.mapFromBase(this.baseFs.resolve(this.mapToBase(e)))}getRealPath(){return this.mapFromBase(this.baseFs.getRealPath())}async openPromise(e,t,i){return this.baseFs.openPromise(this.mapToBase(e),t,i)}openSync(e,t,i){return this.baseFs.openSync(this.mapToBase(e),t,i)}async opendirPromise(e,t){return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(e),t),{path:e})}opendirSync(e,t){return Object.assign(this.baseFs.opendirSync(this.mapToBase(e),t),{path:e})}async readPromise(e,t,i,n,s){return await this.baseFs.readPromise(e,t,i,n,s)}readSync(e,t,i,n,s){return this.baseFs.readSync(e,t,i,n,s)}async writePromise(e,t,i,n,s){return typeof t=="string"?await this.baseFs.writePromise(e,t,i):await this.baseFs.writePromise(e,t,i,n,s)}writeSync(e,t,i,n,s){return typeof t=="string"?this.baseFs.writeSync(e,t,i):this.baseFs.writeSync(e,t,i,n,s)}async closePromise(e){return this.baseFs.closePromise(e)}closeSync(e){this.baseFs.closeSync(e)}createReadStream(e,t){return this.baseFs.createReadStream(e!==null?this.mapToBase(e):e,t)}createWriteStream(e,t){return this.baseFs.createWriteStream(e!==null?this.mapToBase(e):e,t)}async realpathPromise(e){return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(e)))}realpathSync(e){return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(e)))}async existsPromise(e){return this.baseFs.existsPromise(this.mapToBase(e))}existsSync(e){return this.baseFs.existsSync(this.mapToBase(e))}accessSync(e,t){return this.baseFs.accessSync(this.mapToBase(e),t)}async accessPromise(e,t){return this.baseFs.accessPromise(this.mapToBase(e),t)}async statPromise(e,t){return this.baseFs.statPromise(this.mapToBase(e),t)}statSync(e,t){return this.baseFs.statSync(this.mapToBase(e),t)}async fstatPromise(e,t){return this.baseFs.fstatPromise(e,t)}fstatSync(e,t){return this.baseFs.fstatSync(e,t)}lstatPromise(e,t){return this.baseFs.lstatPromise(this.mapToBase(e),t)}lstatSync(e,t){return this.baseFs.lstatSync(this.mapToBase(e),t)}async fchmodPromise(e,t){return this.baseFs.fchmodPromise(e,t)}fchmodSync(e,t){return this.baseFs.fchmodSync(e,t)}async chmodPromise(e,t){return this.baseFs.chmodPromise(this.mapToBase(e),t)}chmodSync(e,t){return this.baseFs.chmodSync(this.mapToBase(e),t)}async fchownPromise(e,t,i){return this.baseFs.fchownPromise(e,t,i)}fchownSync(e,t,i){return this.baseFs.fchownSync(e,t,i)}async chownPromise(e,t,i){return this.baseFs.chownPromise(this.mapToBase(e),t,i)}chownSync(e,t,i){return this.baseFs.chownSync(this.mapToBase(e),t,i)}async renamePromise(e,t){return this.baseFs.renamePromise(this.mapToBase(e),this.mapToBase(t))}renameSync(e,t){return this.baseFs.renameSync(this.mapToBase(e),this.mapToBase(t))}async copyFilePromise(e,t,i=0){return this.baseFs.copyFilePromise(this.mapToBase(e),this.mapToBase(t),i)}copyFileSync(e,t,i=0){return this.baseFs.copyFileSync(this.mapToBase(e),this.mapToBase(t),i)}async appendFilePromise(e,t,i){return this.baseFs.appendFilePromise(this.fsMapToBase(e),t,i)}appendFileSync(e,t,i){return this.baseFs.appendFileSync(this.fsMapToBase(e),t,i)}async writeFilePromise(e,t,i){return this.baseFs.writeFilePromise(this.fsMapToBase(e),t,i)}writeFileSync(e,t,i){return this.baseFs.writeFileSync(this.fsMapToBase(e),t,i)}async unlinkPromise(e){return this.baseFs.unlinkPromise(this.mapToBase(e))}unlinkSync(e){return this.baseFs.unlinkSync(this.mapToBase(e))}async utimesPromise(e,t,i){return this.baseFs.utimesPromise(this.mapToBase(e),t,i)}utimesSync(e,t,i){return this.baseFs.utimesSync(this.mapToBase(e),t,i)}async mkdirPromise(e,t){return this.baseFs.mkdirPromise(this.mapToBase(e),t)}mkdirSync(e,t){return this.baseFs.mkdirSync(this.mapToBase(e),t)}async rmdirPromise(e,t){return this.baseFs.rmdirPromise(this.mapToBase(e),t)}rmdirSync(e,t){return this.baseFs.rmdirSync(this.mapToBase(e),t)}async linkPromise(e,t){return this.baseFs.linkPromise(this.mapToBase(e),this.mapToBase(t))}linkSync(e,t){return this.baseFs.linkSync(this.mapToBase(e),this.mapToBase(t))}async symlinkPromise(e,t,i){let n=this.mapToBase(t);if(this.pathUtils.isAbsolute(e))return this.baseFs.symlinkPromise(this.mapToBase(e),n,i);let s=this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(t),e)),o=this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(n),s);return this.baseFs.symlinkPromise(o,n,i)}symlinkSync(e,t,i){let n=this.mapToBase(t);if(this.pathUtils.isAbsolute(e))return this.baseFs.symlinkSync(this.mapToBase(e),n,i);let s=this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(t),e)),o=this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(n),s);return this.baseFs.symlinkSync(o,n,i)}async readFilePromise(e,t){return t==="utf8"?this.baseFs.readFilePromise(this.fsMapToBase(e),t):this.baseFs.readFilePromise(this.fsMapToBase(e),t)}readFileSync(e,t){return t==="utf8"?this.baseFs.readFileSync(this.fsMapToBase(e),t):this.baseFs.readFileSync(this.fsMapToBase(e),t)}async readdirPromise(e,t){return this.baseFs.readdirPromise(this.mapToBase(e),t)}readdirSync(e,t){return this.baseFs.readdirSync(this.mapToBase(e),t)}async readlinkPromise(e){return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(e)))}readlinkSync(e){return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(e)))}async truncatePromise(e,t){return this.baseFs.truncatePromise(this.mapToBase(e),t)}truncateSync(e,t){return this.baseFs.truncateSync(this.mapToBase(e),t)}async ftruncatePromise(e,t){return this.baseFs.ftruncatePromise(e,t)}ftruncateSync(e,t){return this.baseFs.ftruncateSync(e,t)}watch(e,t,i){return this.baseFs.watch(this.mapToBase(e),t,i)}watchFile(e,t,i){return this.baseFs.watchFile(this.mapToBase(e),t,i)}unwatchFile(e,t){return this.baseFs.unwatchFile(this.mapToBase(e),t)}fsMapToBase(e){return typeof e=="number"?e:this.mapToBase(e)}};var bo=class extends pi{constructor(t,{baseFs:i,pathUtils:n}){super(n);this.target=t,this.baseFs=i}getRealPath(){return this.target}getBaseFs(){return this.baseFs}mapFromBase(t){return t}mapToBase(t){return t}};var qt=class extends pi{constructor(t,{baseFs:i=new $t}={}){super(x);this.target=this.pathUtils.normalize(t),this.baseFs=i}getRealPath(){return this.pathUtils.resolve(this.baseFs.getRealPath(),this.target)}resolve(t){return this.pathUtils.isAbsolute(t)?x.normalize(t):this.baseFs.resolve(x.join(this.target,t))}mapFromBase(t){return t}mapToBase(t){return this.pathUtils.isAbsolute(t)?t:this.pathUtils.join(this.target,t)}};var gK=Oe.root,So=class extends pi{constructor(t,{baseFs:i=new $t}={}){super(x);this.target=this.pathUtils.resolve(Oe.root,t),this.baseFs=i}getRealPath(){return this.pathUtils.resolve(this.baseFs.getRealPath(),this.pathUtils.relative(Oe.root,this.target))}getTarget(){return this.target}getBaseFs(){return this.baseFs}mapToBase(t){let i=this.pathUtils.normalize(t);if(this.pathUtils.isAbsolute(t))return this.pathUtils.resolve(this.target,this.pathUtils.relative(gK,t));if(i.match(/^\.\.\/?/))throw new Error(`Resolving this path (${t}) would escape the jail`);return this.pathUtils.resolve(this.target,t)}mapFromBase(t){return this.pathUtils.resolve(gK,this.pathUtils.relative(this.target,t))}};var Bg=class extends pi{constructor(t,i){super(i);this.instance=null;this.factory=t}get baseFs(){return this.instance||(this.instance=this.factory()),this.instance}set baseFs(t){this.instance=t}mapFromBase(t){return t}mapToBase(t){return t}};var Ze=()=>Object.assign(new Error("ENOSYS: unsupported filesystem access"),{code:"ENOSYS"}),wS=class extends Ea{constructor(){super(x)}getExtractHint(){throw Ze()}getRealPath(){throw Ze()}resolve(){throw Ze()}async openPromise(){throw Ze()}openSync(){throw Ze()}async opendirPromise(){throw Ze()}opendirSync(){throw Ze()}async readPromise(){throw Ze()}readSync(){throw Ze()}async writePromise(){throw Ze()}writeSync(){throw Ze()}async closePromise(){throw Ze()}closeSync(){throw Ze()}createWriteStream(){throw Ze()}createReadStream(){throw Ze()}async realpathPromise(){throw Ze()}realpathSync(){throw Ze()}async readdirPromise(){throw Ze()}readdirSync(){throw Ze()}async existsPromise(e){throw Ze()}existsSync(e){throw Ze()}async accessPromise(){throw Ze()}accessSync(){throw Ze()}async statPromise(){throw Ze()}statSync(){throw Ze()}async fstatPromise(e){throw Ze()}fstatSync(e){throw Ze()}async lstatPromise(e){throw Ze()}lstatSync(e){throw Ze()}async fchmodPromise(){throw Ze()}fchmodSync(){throw Ze()}async chmodPromise(){throw Ze()}chmodSync(){throw Ze()}async fchownPromise(){throw Ze()}fchownSync(){throw Ze()}async chownPromise(){throw Ze()}chownSync(){throw Ze()}async mkdirPromise(){throw Ze()}mkdirSync(){throw Ze()}async rmdirPromise(){throw Ze()}rmdirSync(){throw Ze()}async linkPromise(){throw Ze()}linkSync(){throw Ze()}async symlinkPromise(){throw Ze()}symlinkSync(){throw Ze()}async renamePromise(){throw Ze()}renameSync(){throw Ze()}async copyFilePromise(){throw Ze()}copyFileSync(){throw Ze()}async appendFilePromise(){throw Ze()}appendFileSync(){throw Ze()}async writeFilePromise(){throw Ze()}writeFileSync(){throw Ze()}async unlinkPromise(){throw Ze()}unlinkSync(){throw Ze()}async utimesPromise(){throw Ze()}utimesSync(){throw Ze()}async readFilePromise(){throw Ze()}readFileSync(){throw Ze()}async readlinkPromise(){throw Ze()}readlinkSync(){throw Ze()}async truncatePromise(){throw Ze()}truncateSync(){throw Ze()}async ftruncatePromise(e,t){throw Ze()}ftruncateSync(e,t){throw Ze()}watch(){throw Ze()}watchFile(){throw Ze()}unwatchFile(){throw Ze()}},Gp=wS;Gp.instance=new wS;var Qg=class extends pi{constructor(t){super(K);this.baseFs=t}mapFromBase(t){return K.fromPortablePath(t)}mapToBase(t){return K.toPortablePath(t)}};var Yge=/^[0-9]+$/,BS=/^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/,jge=/^([^/]+-)?[a-f0-9]+$/,Br=class extends pi{constructor({baseFs:t=new $t}={}){super(x);this.baseFs=t}static makeVirtualPath(t,i,n){if(x.basename(t)!=="__virtual__")throw new Error('Assertion failed: Virtual folders must be named "__virtual__"');if(!x.basename(i).match(jge))throw new Error("Assertion failed: Virtual components must be ended by[1;31m an h[mexadecimal hash");let o=x.relative(x.dirname(t),n).split("/"),a=0;for(;a<o.length&&o[a]==="..";)a+=1;let l=o.slice(a);return x.join(t,i,String(a),...l)}static resolveVirtual(t){let i=t.match(BS);if(!i||!i[3]&&i[5])return t;let n=x.dirname(i[1]);if(!i[3]||!i[4])return n;if(!Yge.test(i[4]))return t;let o=Number(i[4]),a="../".repeat(o),l=i[5]||".";return Br.resolveVirtual(x.join(n,a,l))}getExtractHint(t){return this.baseFs.getExtractHint(t)}getRealPath(){return this.baseFs.getRealPath()}realpathSync(t){let i=t.match(BS);if(!i)return this.baseFs.realpathSync(t);if(!i[5])return t;let n=this.baseFs.realpathSync(this.mapToBase(t));return Br.makeVirtualPath(i[1],i[3],n)}async realpathPromise(t){let i=t.match(BS);if(!i)return await this.baseFs.realpathPromise(t);if(!i[5])return t;let n=await this.baseFs.realpathPromise(this.mapToBase(t));return Br.makeVirtualPath(i[1],i[3],n)}mapToBase(t){if(t==="")return t;if(this.pathUtils.isAbsolute(t))return Br.resolveVirtual(t);let i=Br.resolveVirtual(this.baseFs.resolve(Oe.dot)),n=Br.resolveVirtual(this.baseFs.resolve(t));return x.relative(i,n)||Oe.dot}mapFromBase(t){return t}};var Yp=J("fs");var cn=4278190080,Wi=704643072,fK=(r,e)=>{let t=r.indexOf(e);if(t<=0)return null;let i=t;for(;t>=0&&(i=t+e.length,r[i]!==x.sep);){if(r[t-1]===x.sep)return null;t=r.indexOf(e,i)}return r.length>i&&r[i]!==x.sep?null:r.slice(0,i)},On=class extends vA{constructor({libzip:t,baseFs:i=new $t,filter:n=null,maxOpenFiles:s=1/0,readOnlyArchives:o=!1,useCache:a=!0,maxAge:l=5e3,fileExtensions:c=null}){super();this.fdMap=new Map;this.nextFd=3;this.isZip=new Set;this.notZip=new Set;this.realPaths=new Map;this.limitOpenFilesTimeout=null;this.libzipFactory=typeof t!="function"?()=>t:t,this.baseFs=i,this.zipInstances=a?new Map:null,this.filter=n,this.maxOpenFiles=s,this.readOnlyArchives=o,this.maxAge=l,this.fileExtensions=c}static async openPromise(t,i){let n=new On(i);try{return await t(n)}finally{n.saveAndClose()}}get libzip(){return typeof this.libzipInstance>"u"&&(this.libzipInstance=this.libzipFactory()),this.libzipInstance}getExtractHint(t){return this.baseFs.getExtractHint(t)}getRealPath(){return this.baseFs.getRealPath()}saveAndClose(){if(Hp(this),this.zipInstances)for(let[t,{zipFs:i}]of this.zipInstances.entries())i.saveAndClose(),this.zipInstances.delete(t)}discardAndClose(){if(Hp(this),this.zipInstances)for(let[t,{zipFs:i}]of this.zipInstances.entries())i.discardAndClose(),this.zipInstances.delete(t)}resolve(t){return this.baseFs.resolve(t)}remapFd(t,i){let n=this.nextFd++|Wi;return this.fdMap.set(n,[t,i]),n}async openPromise(t,i,n){return await this.makeCallPromise(t,async()=>await this.baseFs.openPromise(t,i,n),async(s,{subPath:o})=>this.remapFd(s,await s.openPromise(o,i,n)))}openSync(t,i,n){return this.makeCallSync(t,()=>this.baseFs.openSync(t,i,n),(s,{subPath:o})=>this.remapFd(s,s.openSync(o,i,n)))}async opendirPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.opendirPromise(t,i),async(n,{subPath:s})=>await n.opendirPromise(s,i),{requireSubpath:!1})}opendirSync(t,i){return this.makeCallSync(t,()=>this.baseFs.opendirSync(t,i),(n,{subPath:s})=>n.opendirSync(s,i),{requireSubpath:!1})}async readPromise(t,i,n,s,o){if((t&cn)!==Wi)return await this.baseFs.readPromise(t,i,n,s,o);let a=this.fdMap.get(t);if(typeof a>"u")throw Hr("read");let[l,c]=a;return await l.readPromise(c,i,n,s,o)}readSync(t,i,n,s,o){if((t&cn)!==Wi)return this.baseFs.readSync(t,i,n,s,o);let a=this.fdMap.get(t);if(typeof a>"u")throw Hr("readSync");let[l,c]=a;return l.readSync(c,i,n,s,o)}async writePromise(t,i,n,s,o){if((t&cn)!==Wi)return typeof i=="string"?await this.baseFs.writePromise(t,i,n):await this.baseFs.writePromise(t,i,n,s,o);let a=this.fdMap.get(t);if(typeof a>"u")throw Hr("write");let[l,c]=a;return typeof i=="string"?await l.writePromise(c,i,n):await l.writePromise(c,i,n,s,o)}writeSync(t,i,n,s,o){if((t&cn)!==Wi)return typeof i=="string"?this.baseFs.writeSync(t,i,n):this.baseFs.writeSync(t,i,n,s,o);let a=this.fdMap.get(t);if(typeof a>"u")throw Hr("writeSync");let[l,c]=a;return typeof i=="string"?l.writeSync(c,i,n):l.writeSync(c,i,n,s,o)}async closePromise(t){if((t&cn)!==Wi)return await this.baseFs.closePromise(t);let i=this.fdMap.get(t);if(typeof i>"u")throw Hr("close");this.fdMap.delete(t);let[n,s]=i;return await n.closePromise(s)}closeSync(t){if((t&cn)!==Wi)return this.baseFs.closeSync(t);let i=this.fdMap.get(t);if(typeof i>"u")throw Hr("closeSync");this.fdMap.delete(t);let[n,s]=i;return n.closeSync(s)}createReadStream(t,i){return t===null?this.baseFs.createReadStream(t,i):this.makeCallSync(t,()=>this.baseFs.createReadStream(t,i),(n,{archivePath:s,subPath:o})=>{let a=n.createReadStream(o,i);return a.path=K.fromPortablePath(this.pathUtils.join(s,o)),a})}createWriteStream(t,i){return t===null?this.baseFs.createWriteStream(t,i):this.makeCallSync(t,()=>this.baseFs.createWriteStream(t,i),(n,{subPath:s})=>n.createWriteStream(s,i))}async realpathPromise(t){return await this.makeCallPromise(t,async()=>await this.baseFs.realpathPromise(t),async(i,{archivePath:n,subPath:s})=>{let o=this.realPaths.get(n);return typeof o>"u"&&(o=await this.baseFs.realpathPromise(n),this.realPaths.set(n,o)),this.pathUtils.join(o,this.pathUtils.relative(Oe.root,await i.realpathPromise(s)))})}realpathSync(t){return this.makeCallSync(t,()=>this.baseFs.realpathSync(t),(i,{archivePath:n,subPath:s})=>{let o=this.realPaths.get(n);return typeof o>"u"&&(o=this.baseFs.realpathSync(n),this.realPaths.set(n,o)),this.pathUtils.join(o,this.pathUtils.relative(Oe.root,i.realpathSync(s)))})}async existsPromise(t){return await this.makeCallPromise(t,async()=>await this.baseFs.existsPromise(t),async(i,{subPath:n})=>await i.existsPromise(n))}existsSync(t){return this.makeCallSync(t,()=>this.baseFs.existsSync(t),(i,{subPath:n})=>i.existsSync(n))}async accessPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.accessPromise(t,i),async(n,{subPath:s})=>await n.accessPromise(s,i))}accessSync(t,i){return this.makeCallSync(t,()=>this.baseFs.accessSync(t,i),(n,{subPath:s})=>n.accessSync(s,i))}async statPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.statPromise(t,i),async(n,{subPath:s})=>await n.statPromise(s,i))}statSync(t,i){return this.makeCallSync(t,()=>this.baseFs.statSync(t,i),(n,{subPath:s})=>n.statSync(s,i))}async fstatPromise(t,i){if((t&cn)!==Wi)return this.baseFs.fstatPromise(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("fstat");let[s,o]=n;return s.fstatPromise(o,i)}fstatSync(t,i){if((t&cn)!==Wi)return this.baseFs.fstatSync(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("fstatSync");let[s,o]=n;return s.fstatSync(o,i)}async lstatPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.lstatPromise(t,i),async(n,{subPath:s})=>await n.lstatPromise(s,i))}lstatSync(t,i){return this.makeCallSync(t,()=>this.baseFs.lstatSync(t,i),(n,{subPath:s})=>n.lstatSync(s,i))}async fchmodPromise(t,i){if((t&cn)!==Wi)return this.baseFs.fchmodPromise(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("fchmod");let[s,o]=n;return s.fchmodPromise(o,i)}fchmodSync(t,i){if((t&cn)!==Wi)return this.baseFs.fchmodSync(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("fchmodSync");let[s,o]=n;return s.fchmodSync(o,i)}async chmodPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.chmodPromise(t,i),async(n,{subPath:s})=>await n.chmodPromise(s,i))}chmodSync(t,i){return this.makeCallSync(t,()=>this.baseFs.chmodSync(t,i),(n,{subPath:s})=>n.chmodSync(s,i))}async fchownPromise(t,i,n){if((t&cn)!==Wi)return this.baseFs.fchownPromise(t,i,n);let s=this.fdMap.get(t);if(typeof s>"u")throw Hr("fchown");let[o,a]=s;return o.fchownPromise(a,i,n)}fchownSync(t,i,n){if((t&cn)!==Wi)return this.baseFs.fchownSync(t,i,n);let s=this.fdMap.get(t);if(typeof s>"u")throw Hr("fchownSync");let[o,a]=s;return o.fchownSync(a,i,n)}async chownPromise(t,i,n){return await this.makeCallPromise(t,async()=>await this.baseFs.chownPromise(t,i,n),async(s,{subPath:o})=>await s.chownPromise(o,i,n))}chownSync(t,i,n){return this.makeCallSync(t,()=>this.baseFs.chownSync(t,i,n),(s,{subPath:o})=>s.chownSync(o,i,n))}async renamePromise(t,i){return await this.makeCallPromise(t,async()=>await this.makeCallPromise(i,async()=>await this.baseFs.renamePromise(t,i),async()=>{throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"})}),async(n,{subPath:s})=>await this.makeCallPromise(i,async()=>{throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"})},async(o,{subPath:a})=>{if(n!==o)throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"});return await n.renamePromise(s,a)}))}renameSync(t,i){return this.makeCallSync(t,()=>this.makeCallSync(i,()=>this.baseFs.renameSync(t,i),()=>{throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"})}),(n,{subPath:s})=>this.makeCallSync(i,()=>{throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"})},(o,{subPath:a})=>{if(n!==o)throw Object.assign(new Error("EEXDEV: cross-device link not permitted"),{code:"EEXDEV"});return n.renameSync(s,a)}))}async copyFilePromise(t,i,n=0){let s=async(o,a,l,c)=>{if((n&Yp.constants.COPYFILE_FICLONE_FORCE)!==0)throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${a}' -> ${c}'`),{code:"EXDEV"});if(n&Yp.constants.COPYFILE_EXCL&&await this.existsPromise(a))throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${a}' -> '${c}'`),{code:"EEXIST"});let u;try{u=await o.readFilePromise(a)}catch{throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${a}' -> '${c}'`),{code:"EINVAL"})}await l.writeFilePromise(c,u)};return await this.makeCallPromise(t,async()=>await this.makeCallPromise(i,async()=>await this.baseFs.copyFilePromise(t,i,n),async(o,{subPath:a})=>await s(this.baseFs,t,o,a)),async(o,{subPath:a})=>await this.makeCallPromise(i,async()=>await s(o,a,this.baseFs,i),async(l,{subPath:c})=>o!==l?await s(o,a,l,c):await o.copyFilePromise(a,c,n)))}copyFileSync(t,i,n=0){let s=(o,a,l,c)=>{if((n&Yp.constants.COPYFILE_FICLONE_FORCE)!==0)throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${a}' -> ${c}'`),{code:"EXDEV"});if(n&Yp.constants.COPYFILE_EXCL&&this.existsSync(a))throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${a}' -> '${c}'`),{code:"EEXIST"});let u;try{u=o.readFileSync(a)}catch{throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${a}' -> '${c}'`),{code:"EINVAL"})}l.writeFileSync(c,u)};return this.makeCallSync(t,()=>this.makeCallSync(i,()=>this.baseFs.copyFileSync(t,i,n),(o,{subPath:a})=>s(this.baseFs,t,o,a)),(o,{subPath:a})=>this.makeCallSync(i,()=>s(o,a,this.baseFs,i),(l,{subPath:c})=>o!==l?s(o,a,l,c):o.copyFileSync(a,c,n)))}async appendFilePromise(t,i,n){return await this.makeCallPromise(t,async()=>await this.baseFs.appendFilePromise(t,i,n),async(s,{subPath:o})=>await s.appendFilePromise(o,i,n))}appendFileSync(t,i,n){return this.makeCallSync(t,()=>this.baseFs.appendFileSync(t,i,n),(s,{subPath:o})=>s.appendFileSync(o,i,n))}async writeFilePromise(t,i,n){return await this.makeCallPromise(t,async()=>await this.baseFs.writeFilePromise(t,i,n),async(s,{subPath:o})=>await s.writeFilePromise(o,i,n))}writeFileSync(t,i,n){return this.makeCallSync(t,()=>this.baseFs.writeFileSync(t,i,n),(s,{subPath:o})=>s.writeFileSync(o,i,n))}async unlinkPromise(t){return await this.makeCallPromise(t,async()=>await this.baseFs.unlinkPromise(t),async(i,{subPath:n})=>await i.unlinkPromise(n))}unlinkSync(t){return this.makeCallSync(t,()=>this.baseFs.unlinkSync(t),(i,{subPath:n})=>i.unlinkSync(n))}async utimesPromise(t,i,n){return await this.makeCallPromise(t,async()=>await this.baseFs.utimesPromise(t,i,n),async(s,{subPath:o})=>await s.utimesPromise(o,i,n))}utimesSync(t,i,n){return this.makeCallSync(t,()=>this.baseFs.utimesSync(t,i,n),(s,{subPath:o})=>s.utimesSync(o,i,n))}async mkdirPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.mkdirPromise(t,i),async(n,{subPath:s})=>await n.mkdirPromise(s,i))}mkdirSync(t,i){return this.makeCallSync(t,()=>this.baseFs.mkdirSync(t,i),(n,{subPath:s})=>n.mkdirSync(s,i))}async rmdirPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.rmdirPromise(t,i),async(n,{subPath:s})=>await n.rmdirPromise(s,i))}rmdirSync(t,i){return this.makeCallSync(t,()=>this.baseFs.rmdirSync(t,i),(n,{subPath:s})=>n.rmdirSync(s,i))}async linkPromise(t,i){return await this.makeCallPromise(i,async()=>await this.baseFs.linkPromise(t,i),async(n,{subPath:s})=>await n.linkPromise(t,s))}linkSync(t,i){return this.makeCallSync(i,()=>this.baseFs.linkSync(t,i),(n,{subPath:s})=>n.linkSync(t,s))}async symlinkPromise(t,i,n){return await this.makeCallPromise(i,async()=>await this.baseFs.symlinkPromise(t,i,n),async(s,{subPath:o})=>await s.symlinkPromise(t,o))}symlinkSync(t,i,n){return this.makeCallSync(i,()=>this.baseFs.symlinkSync(t,i,n),(s,{subPath:o})=>s.symlinkSync(t,o))}async readFilePromise(t,i){return this.makeCallPromise(t,async()=>{switch(i){case"utf8":return await this.baseFs.readFilePromise(t,i);default:return await this.baseFs.readFilePromise(t,i)}},async(n,{subPath:s})=>await n.readFilePromise(s,i))}readFileSync(t,i){return this.makeCallSync(t,()=>{switch(i){case"utf8":return this.baseFs.readFileSync(t,i);default:return this.baseFs.readFileSync(t,i)}},(n,{subPath:s})=>n.readFileSync(s,i))}async readdirPromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.readdirPromise(t,i),async(n,{subPath:s})=>await n.readdirPromise(s,i),{requireSubpath:!1})}readdirSync(t,i){return this.makeCallSync(t,()=>this.baseFs.readdirSync(t,i),(n,{subPath:s})=>n.readdirSync(s,i),{requireSubpath:!1})}async readlinkPromise(t){return await this.makeCallPromise(t,async()=>await this.baseFs.readlinkPromise(t),async(i,{subPath:n})=>await i.readlinkPromise(n))}readlinkSync(t){return this.makeCallSync(t,()=>this.baseFs.readlinkSync(t),(i,{subPath:n})=>i.readlinkSync(n))}async truncatePromise(t,i){return await this.makeCallPromise(t,async()=>await this.baseFs.truncatePromise(t,i),async(n,{subPath:s})=>await n.truncatePromise(s,i))}truncateSync(t,i){return this.makeCallSync(t,()=>this.baseFs.truncateSync(t,i),(n,{subPath:s})=>n.truncateSync(s,i))}async ftruncatePromise(t,i){if((t&cn)!==Wi)return this.baseFs.ftruncatePromise(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("ftruncate");let[s,o]=n;return s.ftruncatePromise(o,i)}ftruncateSync(t,i){if((t&cn)!==Wi)return this.baseFs.ftruncateSync(t,i);let n=this.fdMap.get(t);if(typeof n>"u")throw Hr("ftruncateSync");let[s,o]=n;return s.ftruncateSync(o,i)}watch(t,i,n){return this.makeCallSync(t,()=>this.baseFs.watch(t,i,n),(s,{subPath:o})=>s.watch(o,i,n))}watchFile(t,i,n){return this.makeCallSync(t,()=>this.baseFs.watchFile(t,i,n),()=>$E(this,t,i,n))}unwatchFile(t,i){return this.makeCallSync(t,()=>this.baseFs.unwatchFile(t,i),()=>Up(this,t,i))}async makeCallPromise(t,i,n,{requireSubpath:s=!0}={}){if(typeof t!="string")return await i();let o=this.resolve(t),a=this.findZip(o);return a?s&&a.subPath==="/"?await i():await this.getZipPromise(a.archivePath,async l=>await n(l,a)):await i()}makeCallSync(t,i,n,{requireSubpath:s=!0}={}){if(typeof t!="string")return i();let o=this.resolve(t),a=this.findZip(o);return!a||s&&a.subPath==="/"?i():this.getZipSync(a.archivePath,l=>n(l,a))}findZip(t){if(this.filter&&!this.filter.test(t))return null;let i="";for(;;){let n=t.substring(i.length),s;if(!this.fileExtensions)s=fK(n,".zip");else for(let o of this.fileExtensions)if(s=fK(n,o),s)break;if(!s)return null;if(i=this.pathUtils.join(i,s),this.isZip.has(i)===!1){if(this.notZip.has(i))continue;try{if(!this.baseFs.lstatSync(i).isFile()){this.notZip.add(i);continue}}catch{return null}this.isZip.add(i)}return{archivePath:i,subPath:this.pathUtils.join(Oe.root,t.substring(i.length))}}}limitOpenFiles(t){if(this.zipInstances===null)return;let i=Date.now(),n=i+this.maxAge,s=t===null?0:this.zipInstances.size-t;for(let[o,{zipFs:a,expiresAt:l,refCount:c}]of this.zipInstances.entries())if(!(c!==0||a.hasOpenFileHandles())){if(i>=l){a.saveAndClose(),this.zipInstances.delete(o),s-=1;continue}else if(t===null||s<=0){n=l;break}a.saveAndClose(),this.zipInstances.delete(o),s-=1}this.limitOpenFilesTimeout===null&&(t===null&&this.zipInstances.size>0||t!==null)&&(this.limitOpenFilesTimeout=setTimeout(()=>{this.limitOpenFilesTimeout=null,this.limitOpenFiles(null)},n-i).unref())}async getZipPromise(t,i){let n=async()=>({baseFs:this.baseFs,libzip:this.libzip,readOnly:this.readOnlyArchives,stats:await this.baseFs.statPromise(t)});if(this.zipInstances){let s=this.zipInstances.get(t);if(!s){let o=await n();s=this.zipInstances.get(t),s||(s={zipFs:new Wr(t,o),expiresAt:0,refCount:0})}this.zipInstances.delete(t),this.limitOpenFiles(this.maxOpenFiles-1),this.zipInstances.set(t,s),s.expiresAt=Date.now()+this.maxAge,s.refCount+=1;try{return await i(s.zipFs)}finally{s.refCount-=1}}else{let s=new Wr(t,await n());try{return await i(s)}finally{s.saveAndClose()}}}getZipSync(t,i){let n=()=>({baseFs:this.baseFs,libzip:this.libzip,readOnly:this.readOnlyArchives,stats:this.baseFs.statSync(t)});if(this.zipInstances){let s=this.zipInstances.get(t);return s||(s={zipFs:new Wr(t,n()),expiresAt:0,refCount:0}),this.zipInstances.delete(t),this.limitOpenFiles(this.maxOpenFiles-1),this.zipInstances.set(t,s),s.expiresAt=Date.now()+this.maxAge,i(s.zipFs)}else{let s=new Wr(t,n());try{return i(s)}finally{s.saveAndClose()}}}};var Sg=J("util");var tI=J("url"),hK=J("util");var eI=class extends pi{constructor(t){super(K);this.baseFs=t}mapFromBase(t){return t}mapToBase(t){if(typeof t=="string")return t;if(t instanceof tI.URL)return(0,tI.fileURLToPath)(t);if(Buffer.isBuffer(t)){let i=t.toString();if(Buffer.byteLength(i)!==t.byteLength)throw new Error("Non-utf8 buffers are not supported at the moment. Please upvote the following issue if you encounter this error: https://github.com/yarnpkg/berry/issues/4942");return i}throw new Error(`Unsupported path type: ${(0,hK.inspect)(t)}`)}};var pK=J("readline"),Fi=Symbol("kBaseFs"),Ia=Symbol("kFd"),xA=Symbol("kClosePromise"),rI=Symbol("kCloseResolve"),iI=Symbol("kCloseReject"),bg=Symbol("kRefs"),qs=Symbol("kRef"),Js=Symbol("kUnref"),qge,Jge,Wge,zge,jp=class{constructor(e,t){this[qge]=1;this[Jge]=void 0;this[Wge]=void 0;this[zge]=void 0;this[Fi]=t,this[Ia]=e}get fd(){return this[Ia]}async appendFile(e,t){var i;try{this[qs](this.appendFile);let n=(i=typeof t=="string"?t:t==null?void 0:t.encoding)!=null?i:void 0;return await this[Fi].appendFilePromise(this.fd,e,n?{encoding:n}:void 0)}finally{this[Js]()}}async chown(e,t){try{return this[qs](this.chown),await this[Fi].fchownPromise(this.fd,e,t)}finally{this[Js]()}}async chmod(e){try{return this[qs](this.chmod),await this[Fi].fchmodPromise(this.fd,e)}finally{this[Js]()}}createReadStream(e){return this[Fi].createReadStream(null,{...e,fd:this.fd})}createWriteStream(e){return this[Fi].createWriteStream(null,{...e,fd:this.fd})}datasync(){throw new Error("Method not implemented.")}sync(){throw new Error("Method not implemented.")}async read(e,t,i,n){var s,o,a;try{this[qs](this.read);let l;return Buffer.isBuffer(e)?l=e:(e!=null||(e={}),l=(s=e.buffer)!=null?s:Buffer.alloc(16384),t=e.offset||0,i=(o=e.length)!=null?o:l.byteLength,n=(a=e.position)!=null?a:null),t!=null||(t=0),i!=null||(i=0),i===0?{bytesRead:i,buffer:l}:{bytesRead:await this[Fi].readPromise(this.fd,l,t,i,n),buffer:l}}finally{this[Js]()}}async readFile(e){var t;try{this[qs](this.readFile);let i=(t=typeof e=="string"?e:e==null?void 0:e.encoding)!=null?t:void 0;return await this[Fi].readFilePromise(this.fd,i)}finally{this[Js]()}}readLines(e){return(0,pK.createInterface)({input:this.createReadStream(e),crlfDelay:1/0})}async stat(e){try{return this[qs](this.stat),await this[Fi].fstatPromise(this.fd,e)}finally{this[Js]()}}async truncate(e){try{return this[qs](this.truncate),await this[Fi].ftruncatePromise(this.fd,e)}finally{this[Js]()}}utimes(e,t){throw new Error("Method not implemented.")}async writeFile(e,t){var i;try{this[qs](this.writeFile);let n=(i=typeof t=="string"?t:t==null?void 0:t.encoding)!=null?i:void 0;await this[Fi].writeFilePromise(this.fd,e,n)}finally{this[Js]()}}async write(...e){try{if(this[qs](this.write),ArrayBuffer.isView(e[0])){let[t,i,n,s]=e;return{bytesWritten:await this[Fi].writePromise(this.fd,t,i!=null?i:void 0,n!=null?n:void 0,s!=null?s:void 0),buffer:t}}else{let[t,i,n]=e;return{bytesWritten:await this[Fi].writePromise(this.fd,t,i,n),buffer:t}}}finally{this[Js]()}}async writev(e,t){try{this[qs](this.writev);let i=0;if(typeof t<"u")for(let n of e){let s=await this.write(n,void 0,void 0,t);i+=s.bytesWritten,t+=s.bytesWritten}else for(let n of e)i+=(await this.write(n)).bytesWritten;return{buffers:e,bytesWritten:i}}finally{this[Js]()}}readv(e,t){throw new Error("Method not implemented.")}close(){if(this[Ia]===-1)return Promise.resolve();if(this[xA])return this[xA];if(this[bg]--,this[bg]===0){let e=this[Ia];this[Ia]=-1,this[xA]=this[Fi].closePromise(e).finally(()=>{this[xA]=void 0})}else this[xA]=new Promise((e,t)=>{this[rI]=e,this[iI]=t}).finally(()=>{this[xA]=void 0,this[iI]=void 0,this[rI]=void 0});return this[xA]}[(Fi,Ia,qge=bg,Jge=xA,Wge=rI,zge=iI,qs)](e){if(this[Ia]===-1){let t=new Error("file closed");throw t.code="EBADF",t.syscall=e.name,t}this[bg]++}[Js](){if(this[bg]--,this[bg]===0){let e=this[Ia];this[Ia]=-1,this[Fi].closePromise(e).then(this[rI],this[iI])}}};var Vge=new Set(["accessSync","appendFileSync","createReadStream","createWriteStream","chmodSync","fchmodSync","chownSync","fchownSync","closeSync","copyFileSync","linkSync","lstatSync","fstatSync","lutimesSync","mkdirSync","openSync","opendirSync","readlinkSync","readFileSync","readdirSync","readlinkSync","realpathSync","renameSync","rmdirSync","statSync","symlinkSync","truncateSync","ftruncateSync","unlinkSync","unwatchFile","utimesSync","watch","watchFile","writeFileSync","writeSync"]),dK=new Set(["accessPromise","appendFilePromise","fchmodPromise","chmodPromise","fchownPromise","chownPromise","closePromise","copyFilePromise","linkPromise","fstatPromise","lstatPromise","lutimesPromise","mkdirPromise","openPromise","opendirPromise","readdirPromise","realpathPromise","readFilePromise","readdirPromise","readlinkPromise","renamePromise","rmdirPromise","statPromise","symlinkPromise","truncatePromise","ftruncatePromise","unlinkPromise","utimesPromise","writeFilePromise","writeSync"]);function QS(r,e){e=new eI(e);let t=(i,n,s)=>{let o=i[n];i[n]=s,typeof(o==null?void 0:o[Sg.promisify.custom])<"u"&&(s[Sg.promisify.custom]=o[Sg.promisify.custom])};{t(r,"exists",(i,...n)=>{let o=typeof n[n.length-1]=="function"?n.pop():()=>{};process.nextTick(()=>{e.existsPromise(i).then(a=>{o(a)},()=>{o(!1)})})}),t(r,"read",(...i)=>{let[n,s,o,a,l,c]=i;if(i.length<=3){let u={};i.length<3?c=i[1]:(u=i[1],c=i[2]),{buffer:s=Buffer.alloc(16384),offset:o=0,length:a=s.byteLength,position:l}=u}if(o==null&&(o=0),a|=0,a===0){process.nextTick(()=>{c(null,0,s)});return}l==null&&(l=-1),process.nextTick(()=>{e.readPromise(n,s,o,a,l).then(u=>{c(null,u,s)},u=>{c(u,0,s)})})});for(let i of dK){let n=i.replace(/Promise$/,"");if(typeof r[n]>"u")continue;let s=e[i];if(typeof s>"u")continue;t(r,n,(...a)=>{let c=typeof a[a.length-1]=="function"?a.pop():()=>{};process.nextTick(()=>{s.apply(e,a).then(u=>{c(null,u)},u=>{c(u)})})})}r.realpath.native=r.realpath}{t(r,"existsSync",i=>{try{return e.existsSync(i)}catch{return!1}}),t(r,"readSync",(...i)=>{let[n,s,o,a,l]=i;return i.length<=3&&({offset:o=0,length:a=s.byteLength,position:l}=i[2]||{}),o==null&&(o=0),a|=0,a===0?0:(l==null&&(l=-1),e.readSync(n,s,o,a,l))});for(let i of Vge){let n=i;if(typeof r[n]>"u")continue;let s=e[i];typeof s>"u"||t(r,n,s.bind(e))}r.realpathSync.native=r.realpathSync}{let i=process.emitWarning;process.emitWarning=()=>{};let n;try{n=r.promises}finally{process.emitWarning=i}if(typeof n<"u"){for(let s of dK){let o=s.replace(/Promise$/,"");if(typeof n[o]>"u")continue;let a=e[s];typeof a>"u"||s!=="open"&&t(n,o,(l,...c)=>l instanceof jp?l[o].apply(l,c):a.call(e,l,...c))}t(n,"open",async(...s)=>{let o=await e.openPromise(...s);return new jp(o,e)})}}r.read[Sg.promisify.custom]=async(i,n,...s)=>({bytesRead:await e.readPromise(i,n,...s),buffer:n}),r.write[Sg.promisify.custom]=async(i,n,...s)=>({bytesWritten:await e.writePromise(i,n,...s),buffer:n})}function nI(r,e){let t=Object.create(r);return QS(t,e),t}var EK=Pe(J("os"));function CK(r){let e=Math.ceil(Math.random()*4294967296).toString(16).padStart(8,"0");return`${r}${e}`}var Ws=new Set,bS=null;function mK(){if(bS)return bS;let r=K.toPortablePath(EK.default.tmpdir()),e=M.realpathSync(r);return process.once("exit",()=>{M.rmtempSync()}),bS={tmpdir:r,realTmpdir:e}}var M=Object.assign(new $t,{detachTemp(r){Ws.delete(r)},mktempSync(r){let{tmpdir:e,realTmpdir:t}=mK();for(;;){let i=CK("xfs-");try{this.mkdirSync(x.join(e,i))}catch(s){if(s.code==="EEXIST")continue;throw s}let n=x.join(t,i);if(Ws.add(n),typeof r>"u")return n;try{return r(n)}finally{if(Ws.has(n)){Ws.delete(n);try{this.removeSync(n)}catch{}}}}},async mktempPromise(r){let{tmpdir:e,realTmpdir:t}=mK();for(;;){let i=CK("xfs-");try{await this.mkdirPromise(x.join(e,i))}catch(s){if(s.code==="EEXIST")continue;throw s}let n=x.join(t,i);if(Ws.add(n),typeof r>"u")return n;try{return await r(n)}finally{if(Ws.has(n)){Ws.delete(n);try{await this.removePromise(n)}catch{}}}}},async rmtempPromise(){await Promise.all(Array.from(Ws.values()).map(async r=>{try{await M.removePromise(r,{maxRetries:0}),Ws.delete(r)}catch{}}))},rmtempSync(){for(let r of Ws)try{M.removeSync(r),Ws.delete(r)}catch{}}});var fk=Pe(LS());var $p={};ut($p,{parseResolution:()=>cI,parseShell:()=>aI,parseSyml:()=>yi,stringifyArgument:()=>KS,stringifyArgumentSegment:()=>US,stringifyArithmeticExpression:()=>lI,stringifyCommand:()=>MS,stringifyCommandChain:()=>Dg,stringifyCommandChainThen:()=>OS,stringifyCommandLine:()=>AI,stringifyCommandLineThen:()=>TS,stringifyEnvSegment:()=>oI,stringifyRedirectArgument:()=>Jp,stringifyResolution:()=>uI,stringifyShell:()=>Pg,stringifyShellLine:()=>Pg,stringifySyml:()=>wa,stringifyValueArgument:()=>zl});var lU=Pe(AU());function aI(r,e={isGlobPattern:()=>!1}){try{return(0,lU.parse)(r,e)}catch(t){throw t.location&&(t.message=t.message.replace(/(\.)?$/,` (line ${t.location.start.line}, column ${t.location.start.column})$1`)),t}}function Pg(r,{endSemicolon:e=!1}={}){return r.map(({command:t,type:i},n)=>`${AI(t)}${i===";"?n!==r.length-1||e?";":"":" &"}`).join(" ")}function AI(r){return`${Dg(r.chain)}${r.then?` ${TS(r.then)}`:""}`}function TS(r){return`${r.type} ${AI(r.line)}`}function Dg(r){return`${MS(r)}${r.then?` ${OS(r.then)}`:""}`}function OS(r){return`${r.type} ${Dg(r.chain)}`}function MS(r){switch(r.type){case"command":return`${r.envs.length>0?`${r.envs.map(e=>oI(e)).join(" ")} `:""}${r.args.map(e=>KS(e)).join(" ")}`;case"subshell":return`(${Pg(r.subshell)})${r.args.length>0?` ${r.args.map(e=>Jp(e)).join(" ")}`:""}`;case"group":return`{ ${Pg(r.group,{endSemicolon:!0})} }${r.args.length>0?` ${r.args.map(e=>Jp(e)).join(" ")}`:""}`;case"envs":return r.envs.map(e=>oI(e)).join(" ");default:throw new Error(`Unsupported command type:  "${r.type}"`)}}function oI(r){return`${r.name}=${r.args[0]?zl(r.args[0]):""}`}function KS(r){switch(r.type){case"redirection":return Jp(r);case"argument":return zl(r);default:throw new Error(`Unsupported argument type: "${r.type}"`)}}function Jp(r){return`${r.subtype} ${r.args.map(e=>zl(e)).join(" ")}`}function zl(r){return r.segments.map(e=>US(e)).join("")}function US(r){let e=(i,n)=>n?`"${i}"`:i,t=i=>i===""?'""':i.match(/[(){}<>$|&; \t"']/)?`$'${i.replace(/\\/g,"\\\\").replace(/'/g,"\\'").replace(/\f/g,"\\f").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\t/g,"\\t").replace(/\v/g,"\\v").replace(/\0/g,"\\0")}'`:i;switch(r.type){case"text":return t(r.text);case"glob":return r.pattern;case"shell":return e(`\${${Pg(r.shell)}}`,r.quoted);case"variable":return e(typeof r.defaultValue>"u"?typeof r.alternativeValue>"u"?`\${${r.name}}`:r.alternativeValue.length===0?`\${${r.name}:+}`:`\${${r.name}:+${r.alternativeValue.map(i=>zl(i)).join(" ")}}`:r.defaultValue.length===0?`\${${r.name}:-}`:`\${${r.name}:-${r.defaultValue.map(i=>zl(i)).join(" ")}}`,r.quoted);case"arithmetic":return`$(( ${lI(r.arithmetic)} ))`;default:throw new Error(`Unsupported argument segment type: "${r.type}"`)}}function lI(r){let e=n=>{switch(n){case"addition":return"+";case"subtraction":return"-";case"multiplication":return"*";case"division":return"/";default:throw new Error(`Can't extract operator from arithmetic expression of type "${n}"`)}},t=(n,s)=>s?`( ${n} )`:n,i=n=>t(lI(n),!["number","variable"].includes(n.type));switch(r.type){case"number":return String(r.value);case"variable":return r.name;default:return`${i(r.left)} ${e(r.type)} ${i(r.right)}`}}var gU=Pe(uU());function cI(r){let e=r.match(/^\*{1,2}\/(.*)/);if(e)throw new Error(`The override for '${r}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${e[1]}' instead.`);try{return(0,gU.parse)(r)}catch(t){throw t.location&&(t.message=t.message.replace(/(\.)?$/,` (line ${t.location.start.line}, column ${t.location.start.column})$1`)),t}}function uI(r){let e="";return r.from&&(e+=r.from.fullName,r.from.description&&(e+=`@${r.from.description}`),e+="/"),e+=r.descriptor.fullName,r.descriptor.description&&(e+=`@${r.descriptor.description}`),e}var BI=Pe(rH()),aH=Pe(nH()),nde=/^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/,sH=["__metadata","version","resolution","dependencies","peerDependencies","dependenciesMeta","peerDependenciesMeta","binaries"],wI=class{constructor(e){this.data=e}};function oH(r){return r.match(nde)?r:JSON.stringify(r)}function AH(r){return typeof r>"u"?!0:typeof r=="object"&&r!==null?Object.keys(r).every(e=>AH(r[e])):!1}function $S(r,e,t){if(r===null)return`null
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`).join("");throw M.writeFileSync(_,ae),M.detachTemp(W),new at(45,`Encountered a stack overflow when resolving peer dependencies; cf ${K.fromPortablePath(_)}`)},v=W=>{let _=t.get(W.descriptorHash);if(typeof _>"u")throw new Error("Assertion failed: The resolution should have been registered");let A=i.get(_);if(!A)throw new Error("Assertion failed: The package could not be found");return A},D=(W,_,A,{top:ae,optional:ge})=>{u.length>1e3&&B(),u.push(_);let re=L(W,_,A,{top:ae,optional:ge});return u.pop(),re},L=(W,_,A,{top:ae,optional:ge})=>{if(n.has(_.locatorHash))return;n.add(_.locatorHash),ge||s.delete(_.locatorHash);let re=i.get(_.locatorHash);if(!re)throw new Error(`Assertion failed: The package (${mt(r.configuration,_)}) should have been registered`);let O=[],F=[],ue=[],he=[],ke=[];for(let Ne of Array.from(re.dependencies.values())){if(re.peerDependencies.has(Ne.identHash)&&re.locatorHash!==ae)continue;if(qA(Ne))throw new Error("Assertion failed: Virtual packages shouldn't be encountered when virtualizing a branch");a.delete(Ne.descriptorHash);let oe=ge;if(!oe){let Y=re.dependenciesMeta.get(Ot(Ne));if(typeof Y<"u"){let pe=Y.get(null);typeof pe<"u"&&pe.optional&&(oe=!0)}}let le=t.get(Ne.descriptorHash);if(!le)throw new Error(`Assertion failed: The resolution (${tr(r.configuration,Ne)}) should have been registered`);let we=y.get(le)||i.get(le);if(!we)throw new Error(`Assertion failed: The package (${le}, resolved from ${tr(r.configuration,Ne)}) should have been registered`);if(we.peerDependencies.size===0){D(Ne,we,new Map,{top:ae,optional:oe});continue}let fe,Ae,qe=new Set,ne;F.push(()=>{fe=GD(Ne,_.locatorHash),Ae=YD(we,_.locatorHash),re.dependencies.delete(Ne.identHash),re.dependencies.set(fe.identHash,fe),t.set(fe.descriptorHash,Ae.locatorHash),e.set(fe.descriptorHash,fe),i.set(Ae.locatorHash,Ae),O.push([we,fe,Ae])}),ue.push(()=>{var Y;ne=new Map;for(let pe of Ae.peerDependencies.values()){let ie=re.dependencies.get(pe.identHash);if(!ie&&iC(_,pe)&&(W.identHash===_.identHash?ie=W:(ie=_t(_,W.range),e.set(ie.descriptorHash,ie),t.set(ie.descriptorHash,_.locatorHash),a.delete(ie.descriptorHash))),(!ie||ie.range==="missing:")&&Ae.dependencies.has(pe.identHash)){Ae.peerDependencies.delete(pe.identHash);continue}ie||(ie=_t(pe,"missing:")),Ae.dependencies.set(ie.identHash,ie),qA(ie)&&mc(h,ie.descriptorHash).add(Ae.locatorHash),g.set(ie.identHash,ie),ie.range==="missing:"&&qe.add(ie.identHash),ne.set(pe.identHash,(Y=A.get(pe.identHash))!=null?Y:Ae.locatorHash)}Ae.dependencies=new Map(wn(Ae.dependencies,([pe,ie])=>Ot(ie)))}),he.push(()=>{if(!i.has(Ae.locatorHash))return;let Y=c.get(we.locatorHash);typeof Y=="number"&&Y>=2&&B();let pe=c.get(we.locatorHash),ie=typeof pe<"u"?pe+1:1;c.set(we.locatorHash,ie),D(fe,Ae,ne,{top:ae,optional:oe}),c.set(we.locatorHash,ie-1)}),ke.push(()=>{let Y=re.dependencies.get(Ne.identHash);if(typeof Y>"u")throw new Error("Assertion failed: Expected the peer dependency to have been turned into a dependency");let pe=t.get(Y.descriptorHash);if(typeof pe>"u")throw new Error("Assertion failed: Expected the descriptor to be registered");if(mc(C,pe).add(_.locatorHash),!!i.has(Ae.locatorHash)){for(let ie of Ae.peerDependencies.values()){let de=ne.get(ie.identHash);if(typeof de>"u")throw new Error("Assertion failed: Expected the peer dependency ident to be registered");uf(gf(p,de),Ot(ie)).push(Ae.locatorHash)}for(let ie of qe)Ae.dependencies.delete(ie)}})}for(let Ne of[...F,...ue])Ne();let Fe;do{Fe=!0;for(let[Ne,oe,le]of O){let we=gf(f,Ne.locatorHash),fe=en(...[...le.dependencies.values()].map(Y=>{let pe=Y.range!=="missing:"?t.get(Y.descriptorHash):"missing:";if(typeof pe>"u")throw new Error(`Assertion failed: Expected the resolution for ${tr(r.configuration,Y)} to have been registered`);return pe===ae?`${pe} (top)`:pe}),oe.identHash),Ae=we.get(fe);if(typeof Ae>"u"){we.set(fe,oe);continue}if(Ae===oe)continue;i.delete(le.locatorHash),e.delete(oe.descriptorHash),t.delete(oe.descriptorHash),n.delete(le.locatorHash);let qe=h.get(oe.descriptorHash)||[],ne=[re.locatorHash,...qe];h.delete(oe.descriptorHash);for(let Y of ne){let pe=i.get(Y);typeof pe>"u"||(pe.dependencies.get(oe.identHash).descriptorHash!==Ae.descriptorHash&&(Fe=!1),pe.dependencies.set(oe.identHash,Ae))}}}while(!Fe);for(let Ne of[...he,...ke])Ne()};for(let W of r.workspaces){let _=W.anchoredLocator;a.delete(W.anchoredDescriptor.descriptorHash),D(W.anchoredDescriptor,_,new Map,{top:_.locatorHash,optional:!1})}let H;(A=>(A[A.NotProvided=0]="NotProvided",A[A.NotCompatible=1]="NotCompatible"))(H||(H={}));let j=[];for(let[W,_]of C){let A=i.get(W);if(typeof A>"u")throw new Error("Assertion failed: Expected the root to be registered");let ae=p.get(W);if(!(typeof ae>"u"))for(let ge of _){let re=i.get(ge);if(!(typeof re>"u"))for(let[O,F]of ae){let ue=$i(O);if(re.peerDependencies.has(ue.identHash))continue;let he=`p${en(ge,O,W).slice(0,5)}`;o.set(he,{subject:ge,requested:ue,rootRequester:W,allRequesters:F});let ke=A.dependencies.get(ue.identHash);if(typeof ke<"u"){let Fe=v(ke),Ne=(V=Fe.version)!=null?V:"0.0.0",oe=new Set;for(let we of F){let fe=i.get(we);if(typeof fe>"u")throw new Error("Assertion failed: Expected the link to be registered");let Ae=fe.peerDependencies.get(ue.identHash);if(typeof Ae>"u")throw new Error("Assertion failed: Expected the ident to be registered");oe.add(Ae.range)}[...oe].every(we=>{if(we.startsWith(jr.protocol)){if(!r.tryWorkspaceByLocator(Fe))return!1;we=we.slice(jr.protocol.length),(we==="^"||we==="~")&&(we="*")}return vc(Ne,we)})||j.push({type:1,subject:re,requested:ue,requester:A,version:Ne,hash:he,requirementCount:F.length})}else{let Fe=A.peerDependenciesMeta.get(O);Fe!=null&&Fe.optional||j.push({type:0,subject:re,requested:ue,requester:A,hash:he})}}}}let $=[W=>jD(W.subject),W=>Ot(W.requested),W=>`${W.type}`];l==null||l.startSectionSync({reportFooter:()=>{l.reportWarning(0,`Some peer dependencies are incorrectly met; run ${$e(r.configuration,"yarn explain peer-requirements <hash>",Ue.CODE)} for details, where ${$e(r.configuration,"<hash>",Ue.CODE)} is the six-letter p-prefixed code`)},skipIfEmpty:!0},()=>{for(let W of wn(j,$))switch(W.type){case 0:l.reportWarning(2,`${mt(r.configuration,W.subject)} doesn't provide ${Ai(r.configuration,W.requested)} (${$e(r.configuration,W.hash,Ue.CODE)}), requested by ${Ai(r.configuration,W.requester)}`);break;case 1:{let _=W.requirementCount>1?"and some of its descendants request":"requests";l.reportWarning(60,`${mt(r.configuration,W.subject)} provides ${Ai(r.configuration,W.requested)} (${$e(r.configuration,W.hash,Ue.CODE)}) with version ${oC(r.configuration,W.version)}, which doesn't satisfy what ${Ai(r.configuration,W.requester)} ${_}`)}break}})}var Bh=class{constructor(e,t){this.values=new Map;this.hits=new Map;this.enumerators=new Map;this.configuration=e;let i=this.getRegistryPath();this.isNew=!M.existsSync(i),this.sendReport(t),this.startBuffer()}reportVersion(e){this.reportValue("version",e.replace(/-git\..*/,"-git"))}reportCommandName(e){this.reportValue("commandName",e||"<none>")}reportPluginName(e){this.reportValue("pluginName",e)}reportProject(e){this.reportEnumerator("projectCount",e)}reportInstall(e){this.reportHit("installCount",e)}reportPackageExtension(e){this.reportValue("packageExtension",e)}reportWorkspaceCount(e){this.reportValue("workspaceCount",String(e))}reportDependencyCount(e){this.reportValue("dependencyCount",String(e))}reportValue(e,t){mc(this.values,e).add(t)}reportEnumerator(e,t){mc(this.enumerators,e).add(en(t))}reportHit(e,t="*"){let i=gf(this.hits,e),n=Fa(i,t,()=>0);i.set(t,n+1)}getRegistryPath(){let e=this.configuration.get("globalFolder");return x.join(e,"telemetry.json")}sendReport(e){var u,g,f;let t=this.getRegistryPath(),i;try{i=M.readJsonSync(t)}catch{i={}}let n=Date.now(),s=this.configuration.get("telemetryInterval")*24*60*60*1e3,a=((u=i.lastUpdate)!=null?u:n+s+Math.floor(s*Math.random()))+s;if(a>n&&i.lastUpdate!=null)return;try{M.mkdirSync(x.dirname(t),{recursive:!0}),M.writeJsonSync(t,{lastUpdate:n})}catch{return}if(a>n||!i.blocks)return;let l=`https://browser-http-intake.logs.datadoghq.eu/v1/input/${e}?ddsource=yarn`,c=h=>kR(l,h,{configuration:this.configuration}).catch(()=>{});for(let[h,p]of Object.entries((g=i.blocks)!=null?g:{})){if(Object.keys(p).length===0)continue;let C=p;C.userId=h,C.reportType="primary";for(let v of Object.keys((f=C.enumerators)!=null?f:{}))C.enumerators[v]=C.enumerators[v].length;c(C);let y=new Map,B=20;for(let[v,D]of Object.entries(C.values))D.length>0&&y.set(v,D.slice(0,B));for(;y.size>0;){let v={};v.userId=h,v.reportType="secondary",v.metrics={};for(let[D,L]of y)v.metrics[D]=L.shift(),L.length===0&&y.delete(D);c(v)}}}applyChanges(){var o,a,l,c,u,g,f,h,p;let e=this.getRegistryPath(),t;try{t=M.readJsonSync(e)}catch{t={}}let i=(o=this.configuration.get("telemetryUserId"))!=null?o:"*",n=t.blocks=(a=t.blocks)!=null?a:{},s=n[i]=(l=n[i])!=null?l:{};for(let C of this.hits.keys()){let y=s.hits=(c=s.hits)!=null?c:{},B=y[C]=(u=y[C])!=null?u:{};for(let[v,D]of this.hits.get(C))B[v]=((g=B[v])!=null?g:0)+D}for(let C of["values","enumerators"])for(let y of this[C].keys()){let B=s[C]=(f=s[C])!=null?f:{};B[y]=[...new Set([...(h=B[y])!=null?h:[],...(p=this[C].get(y))!=null?p:[]])]}M.mkdirSync(x.dirname(e),{recursive:!0}),M.writeJsonSync(e,t)}startBuffer(){process.on("exit",()=>{try{this.applyChanges()}catch{}})}};var zN=J("child_process"),D$=Pe(nc());var VN=J("fs");var Qh=new Map([["constraints",[["constraints","query"],["constraints","source"],["constraints"]]],["exec",[]],["interactive-tools",[["search"],["upgrade-interactive"]]],["stage",[["stage"]]],["typescript",[]],["version",[["version","apply"],["version","check"],["version"]]],["workspace-tools",[["workspaces","focus"],["workspaces","foreach"]]]]);function HMe(r){let e=K.fromPortablePath(r);process.on("SIGINT",()=>{}),e?(0,zN.execFileSync)(process.execPath,[e,...process.argv.slice(2)],{stdio:"inherit",env:{...process.env,YARN_IGNORE_PATH:"1",YARN_IGNORE_CWD:"1"}}):(0,zN.execFileSync)(e,process.argv.slice(2),{stdio:"inherit",env:{...process.env,YARN_IGNORE_PATH:"1",YARN_IGNORE_CWD:"1"}})}async function z0({binaryVersion:r,pluginConfiguration:e}){async function t(){let n=new Un({binaryLabel:"Yarn Package Manager",binaryName:"yarn",binaryVersion:r});try{await i(n)}catch(s){process.stdout.write(n.error(s)),process.exitCode=1}}async function i(n){var C,y,B,v,D;let s=process.versions.node,o=">=12 <14 || 14.2 - 14.9 || >14.10.0";if(!Ie.parseOptionalBoolean(process.env.YARN_IGNORE_NODE)&&!vt.satisfiesWithPrereleases(s,o))throw new be(`This tool requires a Node version compatible with ${o} (got ${s}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`);let l=await ye.find(K.toPortablePath(process.cwd()),e,{usePath:!0,strict:!1}),c=l.get("yarnPath"),u=l.get("ignorePath"),g=l.get("ignoreCwd"),f=K.toPortablePath(K.resolve(process.argv[1])),h=L=>M.readFilePromise(L).catch(()=>Buffer.of());if(!u&&!g&&await(async()=>c===f||Buffer.compare(...await Promise.all([h(c),h(f)]))===0)()){process.env.YARN_IGNORE_PATH="1",process.env.YARN_IGNORE_CWD="1",await i(n);return}else if(c!==null&&!u)if(!M.existsSync(c))process.stdout.write(n.error(new Error(`The "yarn-path" option has been set (in ${l.sources.get("yarnPath")}), but the specified location doesn't exist (${c}).`))),process.exitCode=1;else try{HMe(c)}catch(L){process.exitCode=L.code||1}else{u&&delete process.env.YARN_IGNORE_PATH,l.get("enableTelemetry")&&!D$.isCI&&process.stdout.isTTY&&(ye.telemetry=new Bh(l,"puba9cdc10ec5790a2cf4969dd413a47270")),(C=ye.telemetry)==null||C.reportVersion(r);for(let[$,V]of l.plugins.entries()){Qh.has((B=(y=$.match(/^@yarnpkg\/plugin-(.*)$/))==null?void 0:y[1])!=null?B:"")&&((v=ye.telemetry)==null||v.reportPluginName($));for(let W of V.commands||[])n.register(W)}let H=n.process(process.argv.slice(2));H.help||(D=ye.telemetry)==null||D.reportCommandName(H.path.join(" "));let j=H.cwd;if(typeof j<"u"&&!g){let $=(0,VN.realpathSync)(process.cwd()),V=(0,VN.realpathSync)(j);if($!==V){process.chdir(j),await t();return}}await n.runExit(H,{cwd:K.toPortablePath(process.cwd()),plugins:e,quiet:!1,stdin:process.stdin,stdout:process.stdout,stderr:process.stderr})}}return t().catch(n=>{process.stdout.write(n.stack||n.message),process.exitCode=1}).finally(()=>M.rmtempPromise())}function k$(r){r.Command.Path=(...e)=>t=>{t.paths=t.paths||[],t.paths.push(e)};for(let e of["Array","Boolean","String","Proxy","Rest","Counter"])r.Command[e]=(...t)=>(i,n)=>{let s=r.Option[e](...t);Object.defineProperty(i,`__${n}`,{configurable:!1,enumerable:!0,get(){return s},set(o){this[n]=o}})};return r}var Rm={};ut(Rm,{BaseCommand:()=>De,WorkspaceRequiredError:()=>ct,getDynamicLibs:()=>jie,getPluginConfiguration:()=>mQ,main:()=>z0,openWorkspace:()=>Mh,pluginCommands:()=>Qh});var De=class extends ve{constructor(){super(...arguments);this.cwd=z.String("--cwd",{hidden:!0})}};var ct=class extends be{constructor(e,t){let i=x.relative(e,t),n=x.join(e,ot.fileName);super(`This command can only be run from within a workspace of your project (${i} isn't a workspace of ${n}).`)}};var WYe=Pe(Xr());as();var zYe=Pe(WL()),jie=()=>new Map([["@yarnpkg/cli",Rm],["@yarnpkg/core",im],["@yarnpkg/fslib",qp],["@yarnpkg/libzip",SC],["@yarnpkg/parsers",$p],["@yarnpkg/shell",DC],["clipanion",ld],["semver",WYe],["typanion",gn],["yup",zYe]]);async function Mh(r,e){let{project:t,workspace:i}=await je.find(r,e);if(!i)throw new ct(t.cwd,e);return i}var B7e=Pe(Xr());as();var Q7e=Pe(WL());var pO={};ut(pO,{dedupeUtils:()=>PQ,default:()=>o3e,suggestUtils:()=>Gh});var Yae=Pe(nc());var Rse=Pe(Om());as();var Gh={};ut(Gh,{Modifier:()=>KT,Strategy:()=>bQ,Target:()=>Mm,WorkspaceModifier:()=>Sse,applyModifier:()=>xse,extractDescriptorFromPath:()=>UT,extractRangeModifier:()=>vse,fetchDescriptorFrom:()=>HT,findProjectDescriptors:()=>kse,getModifier:()=>Km,getSuggestedDescriptors:()=>Um,makeWorkspaceDescriptor:()=>Dse,toWorkspaceModifier:()=>Pse});var MT=Pe(Xr()),gqe="workspace:",Mm=(i=>(i.REGULAR="dependencies",i.DEVELOPMENT="devDependencies",i.PEER="peerDependencies",i))(Mm||{}),KT=(i=>(i.CARET="^",i.TILDE="~",i.EXACT="",i))(KT||{}),Sse=(i=>(i.CARET="^",i.TILDE="~",i.EXACT="*",i))(Sse||{}),bQ=(s=>(s.KEEP="keep",s.REUSE="reuse",s.PROJECT="project",s.LATEST="latest",s.CACHE="cache",s))(bQ||{});function Km(r,e){return r.exact?"":r.caret?"^":r.tilde?"~":e.configuration.get("defaultSemverRangePrefix")}var fqe=/^([\^~]?)[0-9]+(?:\.[0-9]+){0,2}(?:-\S+)?$/;function vse(r,{project:e}){let t=r.match(fqe);return t?t[1]:e.configuration.get("defaultSemverRangePrefix")}function xse(r,e){let{protocol:t,source:i,params:n,selector:s}=P.parseRange(r.range);return MT.default.valid(s)&&(s=`${e}${r.range}`),P.makeDescriptor(r,P.makeRange({protocol:t,source:i,params:n,selector:s}))}function Pse(r){switch(r){case"^":return"^";case"~":return"~";case"":return"*";default:throw new Error(`Assertion failed: Unknown modifier: "${r}"`)}}function Dse(r,e){return P.makeDescriptor(r.anchoredDescriptor,`${gqe}${Pse(e)}`)}async function kse(r,{project:e,target:t}){let i=new Map,n=s=>{let o=i.get(s.descriptorHash);return o||i.set(s.descriptorHash,o={descriptor:s,locators:[]}),o};for(let s of e.workspaces)if(t==="peerDependencies"){let o=s.manifest.peerDependencies.get(r.identHash);o!==void 0&&n(o).locators.push(s.anchoredLocator)}else{let o=s.manifest.dependencies.get(r.identHash),a=s.manifest.devDependencies.get(r.identHash);t==="devDependencies"?a!==void 0?n(a).locators.push(s.anchoredLocator):o!==void 0&&n(o).locators.push(s.anchoredLocator):o!==void 0?n(o).locators.push(s.anchoredLocator):a!==void 0&&n(a).locators.push(s.anchoredLocator)}return i}async function UT(r,{cwd:e,workspace:t}){return await hqe(async i=>{x.isAbsolute(r)||(r=x.relative(t.cwd,x.resolve(e,r)),r.match(/^\.{0,2}\//)||(r=`./${r}`));let{project:n}=t,s=await HT(P.makeIdent(null,"archive"),r,{project:t.project,cache:i,workspace:t});if(!s)throw new Error("Assertion failed: The descriptor should have been found");let o=new ti,a=n.configuration.makeResolver(),l=n.configuration.makeFetcher(),c={checksums:n.storedChecksums,project:n,cache:i,fetcher:l,report:o,resolver:a},u=a.bindDescriptor(s,t.anchoredLocator,c),g=P.convertDescriptorToLocator(u),f=await l.fetch(g,c),h=await ot.find(f.prefixPath,{baseFs:f.packageFs});if(!h.name)throw new Error("Target path doesn't have a name");return P.makeDescriptor(h.name,r)})}async function Um(r,{project:e,workspace:t,cache:i,target:n,modifier:s,strategies:o,maxResults:a=1/0}){if(!(a>=0))throw new Error(`Invalid maxResults (${a})`);if(r.range!=="unknown")return{suggestions:[{descriptor:r,name:`Use ${P.prettyDescriptor(e.configuration,r)}`,reason:"(unambiguous explicit request)"}],rejections:[]};let l=typeof t<"u"&&t!==null&&t.manifest[n].get(r.identHash)||null,c=[],u=[],g=async f=>{try{await f()}catch(h){u.push(h)}};for(let f of o){if(c.length>=a)break;switch(f){case"keep":await g(async()=>{l&&c.push({descriptor:l,name:`Keep ${P.prettyDescriptor(e.configuration,l)}`,reason:"(no changes)"})});break;case"reuse":await g(async()=>{for(let{descriptor:h,locators:p}of(await kse(r,{project:e,target:n})).values()){if(p.length===1&&p[0].locatorHash===t.anchoredLocator.locatorHash&&o.includes("keep"))continue;let C=`(originally used by ${P.prettyLocator(e.configuration,p[0])}`;C+=p.length>1?` and ${p.length-1} other${p.length>2?"s":""})`:")",c.push({descriptor:h,name:`Reuse ${P.prettyDescriptor(e.configuration,h)}`,reason:C})}});break;case"cache":await g(async()=>{for(let h of e.storedDescriptors.values())h.identHash===r.identHash&&c.push({descriptor:h,name:`Reuse ${P.prettyDescriptor(e.configuration,h)}`,reason:"(already used somewhere in the lockfile)"})});break;case"project":await g(async()=>{if(t.manifest.name!==null&&r.identHash===t.manifest.name.identHash)return;let h=e.tryWorkspaceByIdent(r);if(h===null)return;let p=Dse(h,s);c.push({descriptor:p,name:`Attach ${P.prettyDescriptor(e.configuration,p)}`,reason:`(local workspace at ${ee.pretty(e.configuration,h.relativeCwd,ee.Type.PATH)})`})});break;case"latest":await g(async()=>{if(r.range!=="unknown")c.push({descriptor:r,name:`Use ${P.prettyRange(e.configuration,r.range)}`,reason:"(explicit range requested)"});else if(n==="peerDependencies")c.push({descriptor:P.makeDescriptor(r,"*"),name:"Use *",reason:"(catch-all peer dependency pattern)"});else if(!e.configuration.get("enableNetwork"))c.push({descriptor:null,name:"Resolve from latest",reason:ee.pretty(e.configuration,"(unavailable because enableNetwork is toggled off)","grey")});else{let h=await HT(r,"latest",{project:e,cache:i,workspace:t,preserveModifier:!1});h&&(h=xse(h,s),c.push({descriptor:h,name:`Use ${P.prettyDescriptor(e.configuration,h)}`,reason:"(resolved from latest)"}))}});break}}return{suggestions:c.slice(0,a),rejections:u.slice(0,a)}}async function HT(r,e,{project:t,cache:i,workspace:n,preserveModifier:s=!0}){let o=P.makeDescriptor(r,e),a=new ti,l=t.configuration.makeFetcher(),c=t.configuration.makeResolver(),u={project:t,fetcher:l,cache:i,checksums:t.storedChecksums,report:a,cacheOptions:{skipIntegrityCheck:!0},skipIntegrityCheck:!0},g={...u,resolver:c,fetchOptions:u},f=c.bindDescriptor(o,n.anchoredLocator,g),h=await c.getCandidates(f,new Map,g);if(h.length===0)return null;let p=h[0],{protocol:C,source:y,params:B,selector:v}=P.parseRange(P.convertToManifestRange(p.reference));if(C===t.configuration.get("defaultProtocol")&&(C=null),MT.default.valid(v)&&s!==!1){let D=typeof s=="string"?s:o.range;v=vse(D,{project:t})+v}return P.makeDescriptor(p,P.makeRange({protocol:C,source:y,params:B,selector:v}))}async function hqe(r){return await M.mktempPromise(async e=>{let t=ye.create(e);return t.useWithSource(e,{enableMirror:!1,compressionLevel:0},e,{overwrite:!0}),await r(new Rt(e,{configuration:t,check:!1,immutable:!1}))})}var nu=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.exact=z.Boolean("-E,--exact",!1,{description:"Don't use any semver modifier on the resolved range"});this.tilde=z.Boolean("-T,--tilde",!1,{description:"Use the `~` semver modifier on the resolved range"});this.caret=z.Boolean("-C,--caret",!1,{description:"Use the `^` semver modifier on the resolved range"});this.dev=z.Boolean("-D,--dev",!1,{description:"Add a package as a dev dependency"});this.peer=z.Boolean("-P,--peer",!1,{description:"Add a package as a peer dependency"});this.optional=z.Boolean("-O,--optional",!1,{description:"Add / upgrade a package to an optional regular / peer dependency"});this.preferDev=z.Boolean("--prefer-dev",!1,{description:"Add / upgrade a package to a dev dependency"});this.interactive=z.Boolean("-i,--interactive",{description:"Reuse the specified package from other workspaces in the project"});this.cached=z.Boolean("--cached",!1,{description:"Reuse the highest version already used somewhere within the project"});this.mode=z.String("--mode",{description:"Change what artifacts installs generate",validator:Vi($n)});this.silent=z.Boolean("--silent",{hidden:!0});this.packages=z.Rest()}async execute(){var y;let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd),s=await Rt.find(t);if(!n)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState({restoreResolutions:!1});let o=(y=this.interactive)!=null?y:t.get("preferInteractive"),a=Km(this,i),l=[...o?["reuse"]:[],"project",...this.cached?["cache"]:[],"latest"],c=o?1/0:1,u=await Promise.all(this.packages.map(async B=>{let v=B.match(/^\.{0,2}\//)?await UT(B,{cwd:this.context.cwd,workspace:n}):P.tryParseDescriptor(B),D=B.match(/^(https?:|git@github)/);if(D)throw new be(`It seems you are trying to add a package using a ${ee.pretty(t,`${D[0]}...`,xi.RANGE)} url; we now require package names to be explicitly specified.
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`),(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout,includeLogs:!this.context.quiet},async B=>{await i.install({cache:s,report:B,mode:this.mode})})).exitCode()}};nu.paths=[["add"]],nu.usage=ve.Usage({description:"add dependencies to the project",details:"\n      This command adds a package to the package.json for the nearest workspace.\n\n      - If it didn't exist before, the package will by default be added to the regular `dependencies` field, but this behavior can be overriden thanks to the `-D,--dev` flag (which will cause the dependency to be added to the `devDependencies` field instead) and the `-P,--peer` flag (which will do the same but for `peerDependencies`).\n\n      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your `dependencies` or `devDependencies` (it won't ever update `peerDependencies`, though).\n\n      - If set, the `--prefer-dev` flag will operate as a more flexible `-D,--dev` in that it will add the package to your `devDependencies` if it isn't already listed in either `dependencies` or `devDependencies`, but it will also happily upgrade your `dependencies` if that's what you already use (whereas `-D,--dev` would throw an exception).\n\n      - If set, the `-O,--optional` flag will add the package to the `optionalDependencies` field and, in combination with the `-P,--peer` flag, it will add the package as an optional peer dependency. If the package was already listed in your `dependencies`, it will be upgraded to `optionalDependencies`. If the package was already listed in your `peerDependencies`, in combination with the `-P,--peer` flag, it will be upgraded to an optional peer dependency: `\"peerDependenciesMeta\": { \"<package>\": { \"optional\": true } }`\n\n      - If the added package doesn't specify a range at all its `latest` tag will be resolved and the returned version will be used to generate a new semver range (using the `^` modifier by default unless otherwise configured via the `defaultSemverRangePrefix` configuration, or the `~` modifier if `-T,--tilde` is specified, or no modifier at all if `-E,--exact` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use `-P,--peer` the default range will be `*` and won't be resolved at all.\n\n      - If the added package specifies a range (such as `^1.0.0`, `latest`, or `rc`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as `rc` will be encoded as-is rather than being converted into a semver range).\n\n      If the `--cached` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.\n\n      If the `-i,--interactive` option is used (or if the `preferInteractive` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.\n\n      If the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n      - `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the latter will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n      - `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\n      For a compilation of all the supported protocols, please consult the dedicated page from our website: https://yarnpkg.com/features/protocols.\n    ",examples:[["Add a regular package to the current workspace","$0 add lodash"],["Add a specific version for a package to the current workspace","$0 add lodash@1.2.3"],["Add a package from a GitHub repository (the master branch) to the current workspace using a URL","$0 add lodash@https://github.com/lodash/lodash"],["Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol","$0 add lodash@github:lodash/lodash"],["Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)","$0 add lodash@lodash/lodash"],["Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)","$0 add lodash-es@lodash/lodash#es"]]});function pqe(r,e,{dev:t,peer:i,preferDev:n,optional:s}){let o=r.manifest["dependencies"].has(e.identHash),a=r.manifest["devDependencies"].has(e.identHash),l=r.manifest["peerDependencies"].has(e.identHash);if((t||i)&&o)throw new be(`Package "${P.prettyIdent(r.project.configuration,e)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);if(!t&&!i&&l)throw new be(`Package "${P.prettyIdent(r.project.configuration,e)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);if(s&&a)throw new be(`Package "${P.prettyIdent(r.project.configuration,e)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);if(s&&!i&&l)throw new be(`Package "${P.prettyIdent(r.project.configuration,e)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);if((t||n)&&s)throw new be(`Package "${P.prettyIdent(r.project.configuration,e)}" cannot simultaneously be a dev dependency and an optional dependency`);let c=[];return i&&c.push("peerDependencies"),(t||n)&&c.push("devDependencies"),s&&c.push("dependencies"),c.length>0?c:a?["devDependencies"]:l?["peerDependencies"]:["dependencies"]}var su=class extends De{constructor(){super(...arguments);this.verbose=z.Boolean("-v,--verbose",!1,{description:"Print both the binary name and the locator of the package that provides the binary"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.name=z.String({required:!1})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,locator:n}=await je.find(t,this.context.cwd);if(await i.restoreInstallState(),this.name){let a=(await Wt.getPackageAccessibleBinaries(n,{project:i})).get(this.name);if(!a)throw new be(`Couldn't find a binary named "${this.name}" for package "${P.prettyLocator(t,n)}"`);let[,l]=a;return this.context.stdout.write(`${l}
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Remove all the local archives","$0 cache clean"],["Remove all the archives stored in the ~/.yarn directory","$0 cache clean --mirror"]]});var Fse=Pe(oQ()),GT=J("util"),au=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.unsafe=z.Boolean("--no-redacted",!1,{description:"Don't redact secrets (such as tokens) from the output"});this.name=z.String()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),i=this.name.replace(/[.[].*$/,""),n=this.name.replace(/^[^.[]*/,"");if(typeof t.settings.get(i)>"u")throw new be(`Couldn't find a configuration settings named "${i}"`);let o=t.getSpecial(i,{hideSecrets:!this.unsafe,getNativePaths:!0}),a=Ie.convertMapsToIndexableObjects(o),l=n?(0,Fse.default)(a,n):a,c=await Ge.start({configuration:t,includeFooter:!1,json:this.json,stdout:this.context.stdout},async u=>{u.reportJson(l)});if(!this.json){if(typeof l=="string")return this.context.stdout.write(`${l}
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Unset a simple configuration setting","yarn config unset initScope"],["Unset a complex configuration setting","yarn config unset packageExtensions"],["Unset a nested configuration setting","yarn config unset npmScopes.company.npmRegistryServer"]]});var XT=J("util"),cu=class extends De{constructor(){super(...arguments);this.verbose=z.Boolean("-v,--verbose",!1,{description:"Print the setting description on top of the regular key/value information"});this.why=z.Boolean("--why",!1,{description:"Print the reason why a setting is set a particular way"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins,{strict:!1});return(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout},async n=>{if(t.invalid.size>0&&!this.json){for(let[s,o]of t.invalid)n.reportError(34,`Invalid configuration key "${s}" in ${o}`);n.reportSeparator()}if(this.json){let s=Ie.sortMap(t.settings.keys(),o=>o);for(let o of s){let a=t.settings.get(o),l=t.getSpecial(o,{hideSecrets:!0,getNativePaths:!0}),c=t.sources.get(o);this.verbose?n.reportJson({key:o,effective:l,source:c}):n.reportJson({key:o,effective:l,source:c,...a})}}else{let s=Ie.sortMap(t.settings.keys(),l=>l),o=s.reduce((l,c)=>Math.max(l,c.length),0),a={breakLength:1/0,colors:t.get("enableColors"),maxArrayLength:2};if(this.why||this.verbose){let l=s.map(u=>{let g=t.settings.get(u);if(!g)throw new Error(`Assertion failed: This settings ("${u}") should have been registered`);let f=this.why?t.sources.get(u)||"<default>":g.description;return[u,f]}),c=l.reduce((u,[,g])=>Math.max(u,g.length),0);for(let[u,g]of l)n.reportInfo(null,`${u.padEnd(o," ")}   ${g.padEnd(c," ")}   ${(0,XT.inspect)(t.getSpecial(u,{hideSecrets:!0,getNativePaths:!0}),a)}`)}else for(let l of s)n.reportInfo(null,`${l.padEnd(o," ")}   ${(0,XT.inspect)(t.getSpecial(l,{hideSecrets:!0,getNativePaths:!0}),a)}`)}})).exitCode()}};cu.paths=[["config"]],cu.usage=ve.Usage({description:"display the current configuration",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Print the active configuration settings","$0 config"]]});as();var PQ={};ut(PQ,{Strategy:()=>Gm,acceptedStrategies:()=>m4e,dedupe:()=>ZT});var sae=Pe(yn()),Gm=(e=>(e.HIGHEST="highest",e))(Gm||{}),m4e=new Set(Object.values(Gm)),E4e={highest:async(r,e,{resolver:t,fetcher:i,resolveOptions:n,fetchOptions:s})=>{let o=new Map;for(let[a,l]of r.storedResolutions){let c=r.storedDescriptors.get(a);if(typeof c>"u")throw new Error(`Assertion failed: The descriptor (${a}) should have been registered`);Ie.getSetWithDefault(o,c.identHash).add(l)}return Array.from(r.storedDescriptors.values(),async a=>{if(e.length&&!sae.default.isMatch(P.stringifyIdent(a),e))return null;let l=r.storedResolutions.get(a.descriptorHash);if(typeof l>"u")throw new Error(`Assertion failed: The resolution (${a.descriptorHash}) should have been registered`);let c=r.originalPackages.get(l);if(typeof c>"u"||!t.shouldPersistResolution(c,n))return null;let u=o.get(a.identHash);if(typeof u>"u")throw new Error(`Assertion failed: The resolutions (${a.identHash}) should have been registered`);if(u.size===1)return null;let g=[...u].map(y=>{let B=r.originalPackages.get(y);if(typeof B>"u")throw new Error(`Assertion failed: The package (${y}) should have been registered`);return B.reference}),f=await t.getSatisfying(a,g,n),h=f==null?void 0:f[0];if(typeof h>"u")return null;let p=h.locatorHash,C=r.originalPackages.get(p);if(typeof C>"u")throw new Error(`Assertion failed: The package (${p}) should have been registered`);return p===l?null:{descriptor:a,currentPackage:c,updatedPackage:C}})}};async function ZT(r,{strategy:e,patterns:t,cache:i,report:n}){let{configuration:s}=r,o=new ti,a=s.makeResolver(),l=s.makeFetcher(),c={cache:i,checksums:r.storedChecksums,fetcher:l,project:r,report:o,skipIntegrityCheck:!0,cacheOptions:{skipIntegrityCheck:!0}},u={project:r,resolver:a,report:o,fetchOptions:c};return await n.startTimerPromise("Deduplication step",async()=>{let g=E4e[e],f=await g(r,t,{resolver:a,resolveOptions:u,fetcher:l,fetchOptions:c}),h=vi.progressViaCounter(f.length);await n.reportProgress(h);let p=0;await Promise.all(f.map(B=>B.then(v=>{if(v===null)return;p++;let{descriptor:D,currentPackage:L,updatedPackage:H}=v;n.reportInfo(0,`${P.prettyDescriptor(s,D)} can be deduped from ${P.prettyLocator(s,L)} to ${P.prettyLocator(s,H)}`),n.reportJson({descriptor:P.stringifyDescriptor(D),currentResolution:P.stringifyLocator(L),updatedResolution:P.stringifyLocator(H)}),r.storedResolutions.set(D.descriptorHash,H.locatorHash)}).finally(()=>h.tick())));let C;switch(p){case 0:C="No packages";break;case 1:C="One package";break;default:C=`${p} packages`}let y=ee.pretty(s,e,ee.Type.CODE);return n.reportInfo(0,`${C} can be deduped using the ${y} strategy`),p})}var uu=class extends De{constructor(){super(...arguments);this.strategy=z.String("-s,--strategy","highest",{description:"The strategy to use when deduping dependencies",validator:Vi(Gm)});this.check=z.Boolean("-c,--check",!1,{description:"Exit with exit code 1 when duplicates are found, without persisting the dependency tree"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.mode=z.String("--mode",{description:"Change what artifacts installs generate",validator:Vi($n)});this.patterns=z.Rest()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i}=await je.find(t,this.context.cwd),n=await Rt.find(t);await i.restoreInstallState({restoreResolutions:!1});let s=0,o=await Ge.start({configuration:t,includeFooter:!1,stdout:this.context.stdout,json:this.json},async a=>{s=await ZT(i,{strategy:this.strategy,patterns:this.patterns,cache:n,report:a})});return o.hasErrors()?o.exitCode():this.check?s?1:0:(await Ge.start({configuration:t,stdout:this.context.stdout,json:this.json},async l=>{await i.install({cache:n,report:l,mode:this.mode})})).exitCode()}};uu.paths=[["dedupe"]],uu.usage=ve.Usage({description:"deduplicate dependencies with overlapping ranges",details:"\n      Duplicates are defined as descriptors with overlapping ranges being resolved and locked to different locators. They are a natural consequence of Yarn's deterministic installs, but they can sometimes pile up and unnecessarily increase the size of your project.\n\n      This command dedupes dependencies in the current project using different strategies (only one is implemented at the moment):\n\n      - `highest`: Reuses (where possible) the locators with the highest versions. This means that dependencies can only be upgraded, never downgraded. It's also guaranteed that it never takes more than a single pass to dedupe the entire dependency tree.\n\n      **Note:** Even though it never produces a wrong dependency tree, this command should be used with caution, as it modifies the dependency tree, which can sometimes cause problems when packages don't strictly follow semver recommendations. Because of this, it is recommended to also review the changes manually.\n\n      If set, the `-c,--check` flag will only report the found duplicates, without persisting the modified dependency tree. If changes are found, the command will exit with a non-zero exit code, making it suitable for CI purposes.\n\n      If the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n      - `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the latter will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n      - `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\n      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n      ### In-depth explanation:\n\n      Yarn doesn't deduplicate dependencies by default, otherwise installs wouldn't be deterministic and the lockfile would be useless. What it actually does is that it tries to not duplicate dependencies in the first place.\n\n      **Example:** If `foo@^2.3.4` (a dependency of a dependency) has already been resolved to `foo@2.3.4`, running `yarn add foo@*`will cause Yarn to reuse `foo@2.3.4`, even if the latest `foo` is actually `foo@2.10.14`, thus preventing unnecessary duplication.\n\n      Duplication happens when Yarn can't unlock dependencies that have already been locked inside the lockfile.\n\n      **Example:** If `foo@^2.3.4` (a dependency of a dependency) has already been resolved to `foo@2.3.4`, running `yarn add foo@2.10.14` will cause Yarn to install `foo@2.10.14` because the existing resolution doesn't satisfy the range `2.10.14`. This behavior can lead to (sometimes) unwanted duplication, since now the lockfile contains 2 separate resolutions for the 2 `foo` descriptors, even though they have overlapping ranges, which means that the lockfile can be simplified so that both descriptors resolve to `foo@2.10.14`.\n    ",examples:[["Dedupe all packages","$0 dedupe"],["Dedupe all packages using a specific strategy","$0 dedupe --strategy highest"],["Dedupe a specific package","$0 dedupe lodash"],["Dedupe all packages with the `@babel/*` scope","$0 dedupe '@babel/*'"],["Check for duplicates (can be used as a CI step)","$0 dedupe --check"]]});var Jh=class extends De{async execute(){let{plugins:e}=await ye.find(this.context.cwd,this.context.plugins),t=[];for(let o of e){let{commands:a}=o[1];if(a){let c=Un.from(a).definitions();t.push([o[0],c])}}let i=this.cli.definitions(),n=(o,a)=>o.split(" ").slice(1).join()===a.split(" ").slice(1).join(),s=oae()["@yarnpkg/builder"].bundles.standard;for(let o of t){let a=o[1];for(let l of a)i.find(c=>n(c.path,l.path)).plugin={name:o[0],isDefault:s.includes(o[0])}}this.context.stdout.write(`${JSON.stringify(i,null,2)}
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`;await M.changeFilePromise(g,f,{automaticNewlines:!0})}function Aae(r){return Ct[RI(r)]}var B4e=/## (?<code>YN[0-9]{4}) - `(?<name>[A-Z_]+)`\n\n(?<details>(?:.(?!##))+)/gs;async function Q4e(r){let t=`https://repo.yarnpkg.com/${Ie.isTaggedYarnVersion(Lr)?Lr:await jm(r,"canary")}/packages/gatsby/content/advanced/error-codes.md`,i=await Xt.get(t,{configuration:r});return new Map(Array.from(i.toString().matchAll(B4e),({groups:n})=>{if(!n)throw new Error("Assertion failed: Expected the match to have been successful");let s=Aae(n.code);if(n.name!==s)throw new Error(`Assertion failed: Invalid error code data: Expected "${n.name}" to be named "${s}"`);return[n.code,n.details]}))}var pu=class extends De{constructor(){super(...arguments);this.code=z.String({required:!1,validator:nd(id(),[sd(/^YN[0-9]{4}$/)])});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins);if(typeof this.code<"u"){let i=Aae(this.code),n=ee.pretty(t,i,ee.Type.CODE),s=this.cli.format().header(`${this.code} - ${n}`),a=(await Q4e(t)).get(this.code),l=typeof a<"u"?ee.jsonOrPretty(this.json,t,ee.tuple(ee.Type.MARKDOWN,{text:a,format:this.cli.format(),paragraphs:!0})):`This error code does not have a description.
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Explain an error code","$0 explain YN0006"],["List all error codes","$0 explain"]]});var lae=Pe(yn()),du=class extends De{constructor(){super(...arguments);this.all=z.Boolean("-A,--all",!1,{description:"Print versions of a package from the whole project"});this.recursive=z.Boolean("-R,--recursive",!1,{description:"Print information for all packages, including transitive dependencies"});this.extra=z.Array("-X,--extra",[],{description:"An array of requests of extra data provided by plugins"});this.cache=z.Boolean("--cache",!1,{description:"Print information about the cache entry of a package (path, size, checksum)"});this.dependents=z.Boolean("--dependents",!1,{description:"Print all dependents for each matching package"});this.manifest=z.Boolean("--manifest",!1,{description:"Print data obtained by looking at the package archive (license, homepage, ...)"});this.nameOnly=z.Boolean("--name-only",!1,{description:"Only print the name for the matching packages"});this.virtuals=z.Boolean("--virtuals",!1,{description:"Print each instance of the virtual packages"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.patterns=z.Rest()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd),s=await Rt.find(t);if(!n&&!this.all)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState();let o=new Set(this.extra);this.cache&&o.add("cache"),this.dependents&&o.add("dependents"),this.manifest&&o.add("manifest");let a=(L,{recursive:H})=>{let j=L.anchoredLocator.locatorHash,$=new Map,V=[j];for(;V.length>0;){let W=V.shift();if($.has(W))continue;let _=i.storedPackages.get(W);if(typeof _>"u")throw new Error("Assertion failed: Expected the package to be registered");if($.set(W,_),P.isVirtualLocator(_)&&V.push(P.devirtualizeLocator(_).locatorHash),!(!H&&W!==j))for(let A of _.dependencies.values()){let ae=i.storedResolutions.get(A.descriptorHash);if(typeof ae>"u")throw new Error("Assertion failed: Expected the resolution to be registered");V.push(ae)}}return $.values()},l=({recursive:L})=>{let H=new Map;for(let j of i.workspaces)for(let $ of a(j,{recursive:L}))H.set($.locatorHash,$);return H.values()},c=({all:L,recursive:H})=>L&&H?i.storedPackages.values():L?l({recursive:H}):a(n,{recursive:H}),u=({all:L,recursive:H})=>{let j=c({all:L,recursive:H}),$=this.patterns.map(_=>{let A=P.parseLocator(_),ae=lae.default.makeRe(P.stringifyIdent(A)),ge=P.isVirtualLocator(A),re=ge?P.devirtualizeLocator(A):A;return O=>{let F=P.stringifyIdent(O);if(!ae.test(F))return!1;if(A.reference==="unknown")return!0;let ue=P.isVirtualLocator(O),he=ue?P.devirtualizeLocator(O):O;return!(ge&&ue&&A.reference!==O.reference||re.reference!==he.reference)}}),V=Ie.sortMap([...j],_=>P.stringifyLocator(_));return{selection:V.filter(_=>$.length===0||$.some(A=>A(_))),sortedLookup:V}},{selection:g,sortedLookup:f}=u({all:this.all,recursive:this.recursive});if(g.length===0)throw new be("No package matched your request");let h=new Map;if(this.dependents)for(let L of f)for(let H of L.dependencies.values()){let j=i.storedResolutions.get(H.descriptorHash);if(typeof j>"u")throw new Error("Assertion failed: Expected the resolution to be registered");Ie.getArrayWithDefault(h,j).push(L)}let p=new Map;for(let L of f){if(!P.isVirtualLocator(L))continue;let H=P.devirtualizeLocator(L);Ie.getArrayWithDefault(p,H.locatorHash).push(L)}let C={},y={children:C},B=t.makeFetcher(),v={project:i,fetcher:B,cache:s,checksums:i.storedChecksums,report:new ti,cacheOptions:{skipIntegrityCheck:!0},skipIntegrityCheck:!0},D=[async(L,H,j)=>{var W,_;if(!H.has("manifest"))return;let $=await B.fetch(L,v),V;try{V=await ot.find($.prefixPath,{baseFs:$.packageFs})}finally{(W=$.releaseFs)==null||W.call($)}j("Manifest",{License:ee.tuple(ee.Type.NO_HINT,V.license),Homepage:ee.tuple(ee.Type.URL,(_=V.raw.homepage)!=null?_:null)})},async(L,H,j)=>{var ae;if(!H.has("cache"))return;let $={mockedPackages:i.disabledLocators,unstablePackages:i.conditionalLocators},V=(ae=i.storedChecksums.get(L.locatorHash))!=null?ae:null,W=s.getLocatorPath(L,V,$),_;if(W!==null)try{_=M.statSync(W)}catch{}let A=typeof _<"u"?[_.size,ee.Type.SIZE]:void 0;j("Cache",{Checksum:ee.tuple(ee.Type.NO_HINT,V),Path:ee.tuple(ee.Type.PATH,W),Size:A})}];for(let L of g){let H=P.isVirtualLocator(L);if(!this.virtuals&&H)continue;let j={},$={value:[L,ee.Type.LOCATOR],children:j};if(C[P.stringifyLocator(L)]=$,this.nameOnly){delete $.children;continue}let V=p.get(L.locatorHash);typeof V<"u"&&(j.Instances={label:"Instances",value:ee.tuple(ee.Type.NUMBER,V.length)}),j.Version={label:"Version",value:ee.tuple(ee.Type.NO_HINT,L.version)};let W=(A,ae)=>{let ge={};if(j[A]=ge,Array.isArray(ae))ge.children=ae.map(re=>({value:re}));else{let re={};ge.children=re;for(let[O,F]of Object.entries(ae))typeof F>"u"||(re[O]={label:O,value:F})}};if(!H){for(let A of D)await A(L,o,W);await t.triggerHook(A=>A.fetchPackageInfo,L,o,W)}L.bin.size>0&&!H&&W("Exported Binaries",[...L.bin.keys()].map(A=>ee.tuple(ee.Type.PATH,A)));let _=h.get(L.locatorHash);typeof _<"u"&&_.length>0&&W("Dependents",_.map(A=>ee.tuple(ee.Type.LOCATOR,A))),L.dependencies.size>0&&!H&&W("Dependencies",[...L.dependencies.values()].map(A=>{var re;let ae=i.storedResolutions.get(A.descriptorHash),ge=typeof ae<"u"&&(re=i.storedPackages.get(ae))!=null?re:null;return ee.tuple(ee.Type.RESOLUTION,{descriptor:A,locator:ge})})),L.peerDependencies.size>0&&H&&W("Peer dependencies",[...L.peerDependencies.values()].map(A=>{var O,F;let ae=L.dependencies.get(A.identHash),ge=typeof ae<"u"&&(O=i.storedResolutions.get(ae.descriptorHash))!=null?O:null,re=ge!==null&&(F=i.storedPackages.get(ge))!=null?F:null;return ee.tuple(ee.Type.RESOLUTION,{descriptor:A,locator:re})}))}_n.emitTree(y,{configuration:t,json:this.json,stdout:this.context.stdout,separators:this.nameOnly?0:2})}};du.paths=[["info"]],du.usage=ve.Usage({description:"see information related to packages",details:"\n      This command prints various information related to the specified packages, accepting glob patterns.\n\n      By default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the `-A,--all` flag. Adding the `-R,--recursive` flag will also report transitive dependencies.\n\n      Some fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (`--dependents`, `--manifest`, `--virtuals`, ...) described in the option descriptions.\n\n      Note that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use `yarn why` which will do just that (it also provides a `-R,--recursive` flag that may be of some help).\n    ",examples:[["Show information about Lodash","$0 info lodash"]]});var DQ=Pe(nc());as();var Cu=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.immutable=z.Boolean("--immutable",{description:"Abort with an error exit code if the lockfile was to be modified"});this.immutableCache=z.Boolean("--immutable-cache",{description:"Abort with an error exit code if the cache folder was to be modified"});this.checkCache=z.Boolean("--check-cache",!1,{description:"Always refetch the packages and ensure that their checksums are consistent"});this.inlineBuilds=z.Boolean("--inline-builds",{description:"Verbosely print the output of the build steps of dependencies"});this.mode=z.String("--mode",{description:"Change what artifacts installs generate",validator:Vi($n)});this.cacheFolder=z.String("--cache-folder",{hidden:!0});this.frozenLockfile=z.Boolean("--frozen-lockfile",{hidden:!0});this.ignoreEngines=z.Boolean("--ignore-engines",{hidden:!0});this.nonInteractive=z.Boolean("--non-interactive",{hidden:!0});this.preferOffline=z.Boolean("--prefer-offline",{hidden:!0});this.production=z.Boolean("--production",{hidden:!0});this.registry=z.String("--registry",{hidden:!0});this.silent=z.Boolean("--silent",{hidden:!0});this.networkTimeout=z.String("--network-timeout",{hidden:!0})}async execute(){var f;let t=await ye.find(this.context.cwd,this.context.plugins);typeof this.inlineBuilds<"u"&&t.useWithSource("<cli>",{enableInlineBuilds:this.inlineBuilds},t.startingCwd,{overwrite:!0});let i=!!process.env.FUNCTION_TARGET||!!process.env.GOOGLE_RUNTIME,n=async(h,{error:p})=>{let C=await Ge.start({configuration:t,stdout:this.context.stdout,includeFooter:!1},async y=>{p?y.reportError(50,h):y.reportWarning(50,h)});return C.hasErrors()?C.exitCode():null};if(typeof this.ignoreEngines<"u"){let h=await n("The --ignore-engines option is deprecated; engine checking isn't a core feature anymore",{error:!DQ.default.VERCEL});if(h!==null)return h}if(typeof this.registry<"u"){let h=await n("The --registry option is deprecated; prefer setting npmRegistryServer in your .yarnrc.yml file",{error:!1});if(h!==null)return h}if(typeof this.preferOffline<"u"){let h=await n("The --prefer-offline flag is deprecated; use the --cached flag with 'yarn add' instead",{error:!DQ.default.VERCEL});if(h!==null)return h}if(typeof this.production<"u"){let h=await n("The --production option is deprecated on 'install'; use 'yarn workspaces focus' instead",{error:!0});if(h!==null)return h}if(typeof this.nonInteractive<"u"){let h=await n("The --non-interactive option is deprecated",{error:!i});if(h!==null)return h}if(typeof this.frozenLockfile<"u"&&(await n("The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead",{error:!1}),this.immutable=this.frozenLockfile),typeof this.cacheFolder<"u"){let h=await n("The cache-folder option has been deprecated; use rc settings instead",{error:!DQ.default.NETLIFY});if(h!==null)return h}let s=this.mode==="update-lockfile";if(s&&(this.immutable||this.immutableCache))throw new be(`${ee.pretty(t,"--immutable",ee.Type.CODE)} and ${ee.pretty(t,"--immutable-cache",ee.Type.CODE)} cannot be used with ${ee.pretty(t,"--mode=update-lockfile",ee.Type.CODE)}`);let o=((f=this.immutable)!=null?f:t.get("enableImmutableInstalls"))&&!s,a=this.immutableCache&&!s;if(t.projectCwd!==null){let h=await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout,includeFooter:!1},async p=>{await x4e(t,o)&&(p.reportInfo(48,"Automatically fixed merge conflicts \u{1F44D}"),p.reportSeparator())});if(h.hasErrors())return h.exitCode()}if(t.projectCwd!==null&&typeof t.sources.get("nodeLinker")>"u"){let h=t.projectCwd,p;try{p=await M.readFilePromise(x.join(h,xt.lockfile),"utf8")}catch{}if(p!=null&&p.includes("yarn lockfile v1")){let C=await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout,includeFooter:!1},async y=>{y.reportInfo(70,"Migrating from Yarn 1; automatically enabling the compatibility node-modules linker \u{1F44D}"),y.reportSeparator(),t.use("<compat>",{nodeLinker:"node-modules"},h,{overwrite:!0}),await ye.updateConfiguration(h,{nodeLinker:"node-modules"})});if(C.hasErrors())return C.exitCode()}}if(t.projectCwd!==null){let h=await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout,includeFooter:!1},async p=>{var C;(C=ye.telemetry)!=null&&C.isNew&&(p.reportInfo(65,"Yarn will periodically gather anonymous telemetry: https://yarnpkg.com/advanced/telemetry"),p.reportInfo(65,`Run ${ee.pretty(t,"yarn config set --home enableTelemetry 0",ee.Type.CODE)} to disable`),p.reportSeparator())});if(h.hasErrors())return h.exitCode()}let{project:l,workspace:c}=await je.find(t,this.context.cwd),u=await Rt.find(t,{immutable:a,check:this.checkCache});if(!c)throw new ct(l.cwd,this.context.cwd);return await l.restoreInstallState({restoreResolutions:!1}),(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout,includeLogs:!0},async h=>{await l.install({cache:u,report:h,immutable:o,mode:this.mode})})).exitCode()}};Cu.paths=[["install"],ve.Default],Cu.usage=ve.Usage({description:"install the project dependencies",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Run a Node script","$0 node ./my-script.js"]]});var dae=J("os");var uae=J("os");var D4e="https://raw.githubusercontent.com/yarnpkg/berry/master/plugins.yml";async function yu(r){let e=await Xt.get(D4e,{configuration:r});return yi(e.toString())}var Iu=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins);return(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout},async n=>{let s=await yu(t);for(let[o,{experimental:a,...l}]of Object.entries(s)){let c=o;a&&(c+=" [experimental]"),n.reportJson({name:o,experimental:a,...l}),n.reportInfo(null,c)}})).exitCode()}};Iu.paths=[["plugin","list"]],Iu.usage=ve.Usage({category:"Plugin-related commands",description:"list the available official plugins",details:"\n      This command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in `yarn plugin import`.\n    ",examples:[["List the official plugins","$0 plugin list"]]});var k4e=/^[0-9]+$/;function gae(r){return k4e.test(r)?`pull/${r}/head`:r}var R4e=({repository:r,branch:e},t)=>[["git","init",K.fromPortablePath(t)],["git","remote","add","origin",r],["git","fetch","origin","--depth=1",gae(e)],["git","reset","--hard","FETCH_HEAD"]],F4e=({branch:r})=>[["git","fetch","origin","--depth=1",gae(r),"--force"],["git","reset","--hard","FETCH_HEAD"],["git","clean","-dfx"]],N4e=({plugins:r,noMinify:e},t)=>[["yarn","build:cli",...new Array().concat(...r.map(i=>["--plugin",x.resolve(t,i)])),...e?["--no-minify"]:[],"|"]],wu=class extends De{constructor(){super(...arguments);this.installPath=z.String("--path",{description:"The path where the repository should be cloned to"});this.repository=z.String("--repository","https://github.com/yarnpkg/berry.git",{description:"The repository that should be cloned"});this.branch=z.String("--branch","master",{description:"The branch of the repository that should be cloned"});this.plugins=z.Array("--plugin",[],{description:"An array of additional plugins that should be included in the bundle"});this.noMinify=z.Boolean("--no-minify",!1,{description:"Build a bundle for development (debugging) - non-minified and non-mangled"});this.force=z.Boolean("-f,--force",!1,{description:"Always clone the repository instead of trying to fetch the latest commits"});this.skipPlugins=z.Boolean("--skip-plugins",!1,{description:"Skip updating the contrib plugins"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i}=await je.find(t,this.context.cwd),n=typeof this.installPath<"u"?x.resolve(this.context.cwd,K.toPortablePath(this.installPath)):x.resolve(K.toPortablePath((0,uae.tmpdir)()),"yarnpkg-sources",li.makeHash(this.repository).slice(0,6));return(await Ge.start({configuration:t,stdout:this.context.stdout},async o=>{await $T(this,{configuration:t,report:o,target:n}),o.reportSeparator(),o.reportInfo(0,"Building a fresh bundle"),o.reportSeparator(),await qm(N4e(this,n),{configuration:t,context:this.context,target:n}),o.reportSeparator();let a=x.resolve(n,"packages/yarnpkg-cli/bundles/yarn.js"),l=await M.readFilePromise(a);await _T(t,"sources",l,{report:o}),this.skipPlugins||await L4e(this,{project:i,report:o,target:n})})).exitCode()}};wu.paths=[["set","version","from","sources"]],wu.usage=ve.Usage({description:"build Yarn from master",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m   `,examples:[["Remove a plugin imported from the Yarn repository","$0 plugin remove @yarnpkg/plugin-typescript"],["Remove a plugin imported from a local file","$0 plugin remove my-local-plugin"]]});var Su=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins);return(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout},async n=>{for(let s of t.plugins.keys()){let o=this.context.plugins.plugins.has(s),a=s;o&&(a+=" [builtin]"),n.reportJson({name:s,builtin:o}),n.reportInfo(null,`${a}`)}})).exitCode()}};Su.paths=[["plugin","runtime"]],Su.usage=ve.Usage({category:"Plugin-related commands",description:"list the active plugins",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`),(await Ge.start({configuration:t,stdout:this.context.stdout},async B=>{await i.install({cache:s,report:B,mode:this.mode})})).exitCode()}};Cl.paths=[["up"]],Cl.usage=ve.Usage({description:"upgrade dependencies across the project",details:"\n      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of `dependencies` or `devDependencies` - `peerDependencies` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.\n\n      If `-R,--recursive` is set the command will change behavior and no other switch will be allowed. When operating under this mode `yarn up` will force all ranges matching the selected packages to be resolved again (often to the highest available versions) before being stored in the lockfile. It however won't touch your manifests anymore, so depending on your needs you might want to run both `yarn up` and `yarn up -R` to cover all bases.\n\n      If `-i,--interactive` is set (or if the `preferInteractive` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.\n\n      The, `-C,--caret`, `-E,--exact` and  `-T,--tilde` options have the same meaning as in the `add` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).\n\n      If the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n      - `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the latter will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n      - `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\n      Generally you can see `yarn up` as a counterpart to what was `yarn upgrade --latest` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike `yarn upgrade` which only upgraded dependencies in the current workspace, `yarn up` will upgrade all workspaces at the same time.\n\n      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.\n    ",examples:[["Upgrade all instances of lodash to the latest release","$0 up lodash"],["Upgrade all instances of lodash to the latest release, but ask confirmation for each","$0 up lodash -i"],["Upgrade all instances of lodash to 1.2.3","$0 up lodash@1.2.3"],["Upgrade all instances of packages with the `@babel` scope to the latest release","$0 up '@babel/*'"],["Upgrade all instances of packages containing the word `jest` to the latest release","$0 up '*jest*'"],["Upgrade all instances of packages with the `@babel` scope to 7.0.0","$0 up '@babel/*@7.0.0'"]]}),Cl.schema=[av("recursive",sc.Forbids,["interactive","exact","tilde","caret"],{ignore:[void 0,!1]})];var Ru=class extends De{constructor(){super(...arguments);this.recursive=z.Boolean("-R,--recursive",!1,{description:"List, for each workspace, what are all the paths that lead to the dependency"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.peers=z.Boolean("--peers",!1,{description:"Also print the peer dependencies that match the specified name"});this.package=z.String()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState();let s=P.parseIdent(this.package).identHash,o=this.recursive?M4e(i,s,{configuration:t,peers:this.peers}):O4e(i,s,{configuration:t,peers:this.peers});_n.emitTree(o,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};Ru.paths=[["why"]],Ru.usage=ve.Usage({description:"display the reason why a package is needed",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Explain why lodash is used in your project","$0 why lodash"]]});function O4e(r,e,{configuration:t,peers:i}){let n=Ie.sortMap(r.storedPackages.values(),a=>P.stringifyLocator(a)),s={},o={children:s};for(let a of n){let l={};for(let u of a.dependencies.values()){if(!i&&a.peerDependencies.has(u.identHash))continue;let g=r.storedResolutions.get(u.descriptorHash);if(!g)throw new Error("Assertion failed: The resolution should have been registered");let f=r.storedPackages.get(g);if(!f)throw new Error("Assertion failed: The package should have been registered");if(f.identHash!==e)continue;{let p=P.stringifyLocator(a);s[p]={value:[a,ee.Type.LOCATOR],children:l}}let h=P.stringifyLocator(f);l[h]={value:[{descriptor:u,locator:f},ee.Type.DEPENDENT]}}}return o}function M4e(r,e,{configuration:t,peers:i}){let n=Ie.sortMap(r.workspaces,f=>P.stringifyLocator(f.anchoredLocator)),s=new Set,o=new Set,a=f=>{if(s.has(f.locatorHash))return o.has(f.locatorHash);if(s.add(f.locatorHash),f.identHash===e)return o.add(f.locatorHash),!0;let h=!1;f.identHash===e&&(h=!0);for(let p of f.dependencies.values()){if(!i&&f.peerDependencies.has(p.identHash))continue;let C=r.storedResolutions.get(p.descriptorHash);if(!C)throw new Error("Assertion failed: The resolution should have been registered");let y=r.storedPackages.get(C);if(!y)throw new Error("Assertion failed: The package should have been registered");a(y)&&(h=!0)}return h&&o.add(f.locatorHash),h};for(let f of n){let h=r.storedPackages.get(f.anchoredLocator.locatorHash);if(!h)throw new Error("Assertion failed: The package should have been registered");a(h)}let l=new Set,c={},u={children:c},g=(f,h,p)=>{if(!o.has(f.locatorHash))return;let C=p!==null?ee.tuple(ee.Type.DEPENDENT,{locator:f,descriptor:p}):ee.tuple(ee.Type.LOCATOR,f),y={},B={value:C,children:y},v=P.stringifyLocator(f);if(h[v]=B,!l.has(f.locatorHash)&&(l.add(f.locatorHash),!(p!==null&&r.tryWorkspaceByLocator(f))))for(let D of f.dependencies.values()){if(!i&&f.peerDependencies.has(D.identHash))continue;let L=r.storedResolutions.get(D.descriptorHash);if(!L)throw new Error("Assertion failed: The resolution should have been registered");let H=r.storedPackages.get(L);if(!H)throw new Error("Assertion failed: The package should have been registered");g(H,y,D)}};for(let f of n){let h=r.storedPackages.get(f.anchoredLocator.locatorHash);if(!h)throw new Error("Assertion failed: The package should have been registered");g(h,c,null)}return u}var hO={};ut(hO,{default:()=>n3e,gitUtils:()=>aA});var aA={};ut(aA,{TreeishProtocols:()=>kQ,clone:()=>fO,fetchBase:()=>Hae,fetchChangedFiles:()=>Gae,fetchChangedWorkspaces:()=>r3e,fetchRoot:()=>Uae,isGitUrl:()=>Zh,lsRemote:()=>Kae,normalizeLocator:()=>uO,normalizeRepoUrl:()=>Wm,resolveUrl:()=>gO,splitRepoUrl:()=>Jm});var cO=Pe(Fae()),Oae=Pe(bB()),Xh=Pe(J("querystring")),AO=Pe(Xr());var Lae=J("url");function aO(r,e,t){let i=r.indexOf(t);return r.lastIndexOf(e,i>-1?i:1/0)}function Nae(r){try{return new Lae.URL(r)}catch{return}}function e3e(r){let e=aO(r,"@","#"),t=aO(r,":","#");return t>e&&(r=`${r.slice(0,t)}/${r.slice(t+1)}`),aO(r,":","#")===-1&&r.indexOf("//")===-1&&(r=`ssh://${r}`),r}function Tae(r){return Nae(r)||Nae(e3e(r))}function Mae(){return{...process.env,GIT_SSH_COMMAND:process.env.GIT_SSH_COMMAND||`${process.env.GIT_SSH||"ssh"} -o BatchMode=yes`}}var t3e=[/^ssh:/,/^git(?:\+[^:]+)?:/,/^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/,/^git@[^#]+\/[^#]+\.git(?:#.*)?$/,/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/,/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/],kQ=(n=>(n.Commit="commit",n.Head="head",n.Tag="tag",n.Semver="semver",n))(kQ||{});function Zh(r){return r?t3e.some(e=>!!r.match(e)):!1}function Jm(r){r=Wm(r);let e=r.indexOf("#");if(e===-1)return{repo:r,treeish:{protocol:"head",request:"HEAD"},extra:{}};let t=r.slice(0,e),i=r.slice(e+1);if(i.match(/^[a-z]+=/)){let n=Xh.default.parse(i);for(let[l,c]of Object.entries(n))if(typeof c!="string")throw new Error(`Assertion failed: The ${l} parameter must be a literal string`);let s=Object.values(kQ).find(l=>Object.prototype.hasOwnProperty.call(n,l)),o,a;typeof s<"u"?(o=s,a=n[s]):(o="head",a="HEAD");for(let l of Object.values(kQ))delete n[l];return{repo:t,treeish:{protocol:o,request:a},extra:n}}else{let n=i.indexOf(":"),s,o;return n===-1?(s=null,o=i):(s=i.slice(0,n),o=i.slice(n+1)),{repo:t,treeish:{protocol:s,request:o},extra:{}}}}function Wm(r,{git:e=!1}={}){if(r=r.replace(/^git\+https:/,"https:"),r=r.replace(/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)(?:\.git)?(#.*)?$/,"https://github.com/$1/$2.git$3"),r=r.replace(/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/,"https://github.com/$1/$2.git#$3"),e){let t=Tae(r);t&&(r=t.href),r=r.replace(/^git\+([^:]+):/,"$1:")}return r}function uO(r){return P.makeLocator(r,Wm(r.reference))}async function Kae(r,e){let t=Wm(r,{git:!0});if(!Xt.getNetworkSettings(`https://${(0,cO.default)(t).resource}`,{configuration:e}).enableNetwork)throw new Error(`Request to '${t}' has been blocked because of your configuration settings`);let n=await lO("listing refs",["ls-remote",t],{cwd:e.startingCwd,env:Mae()},{configuration:e,normalizedRepoUrl:t}),s=new Map,o=/^([a-f0-9]{40})\t([^\n]+)/gm,a;for(;(a=o.exec(n.stdout))!==null;)s.set(a[2],a[1]);return s}async function gO(r,e){let{repo:t,treeish:{protocol:i,request:n},extra:s}=Jm(r),o=await Kae(t,e),a=(c,u)=>{switch(c){case"commit":{if(!u.match(/^[a-f0-9]{40}$/))throw new Error("Invalid commit hash");return Xh.default.stringify({...s,commit:u})}case"head":{let g=o.get(u==="HEAD"?u:`refs/heads/${u}`);if(typeof g>"u")throw new Error(`Unknown head ("${u}")`);return Xh.default.stringify({...s,commit:g})}case"tag":{let g=o.get(`refs/tags/${u}`);if(typeof g>"u")throw new Error(`Unknown tag ("${u}")`);return Xh.default.stringify({...s,commit:g})}case"semver":{let g=vt.validRange(u);if(!g)throw new Error(`Invalid range ("${u}")`);let f=new Map([...o.entries()].filter(([p])=>p.startsWith("refs/tags/")).map(([p,C])=>[AO.default.parse(p.slice(10)),C]).filter(p=>p[0]!==null)),h=AO.default.maxSatisfying([...f.keys()],g);if(h===null)throw new Error(`No matching range ("${u}")`);return Xh.default.stringify({...s,commit:f.get(h)})}case null:{let g;if((g=l("commit",u))!==null||(g=l("tag",u))!==null||(g=l("head",u))!==null)return g;throw u.match(/^[a-f0-9]+$/)?new Error(`Couldn't resolve "${u}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`):new Error(`Couldn't resolve "${u}" as either a commit, a tag, or a head`)}default:throw new Error(`Invalid Git resolution protocol ("${c}")`)}},l=(c,u)=>{try{return a(c,u)}catch{return null}};return`${t}#${a(i,n)}`}async function fO(r,e){return await e.getLimit("cloneConcurrency")(async()=>{let{repo:t,treeish:{protocol:i,request:n}}=Jm(r);if(i!=="commit")throw new Error("Invalid treeish protocol when cloning");let s=Wm(t,{git:!0});if(Xt.getNetworkSettings(`https://${(0,cO.default)(s).resource}`,{configuration:e}).enableNetwork===!1)throw new Error(`Request to '${s}' has been blocked because of your configuration settings`);let o=await M.mktempPromise(),a={cwd:o,env:Mae()};return await lO("cloning the repository",["clone","-c core.autocrlf=false",s,K.fromPortablePath(o)],a,{configuration:e,normalizedRepoUrl:s}),await lO("switching branch",["checkout",`${n}`],a,{configuration:e,normalizedRepoUrl:s}),o})}async function Uae(r){let e=null,t,i=r;do t=i,await M.existsPromise(x.join(t,".git"))&&(e=t),i=x.dirname(t);while(e===null&&i!==t);return e}async function Hae(r,{baseRefs:e}){if(e.length===0)throw new be("Can't run this command with zero base refs specified.");let t=[];for(let a of e){let{code:l}=await Cr.execvp("git",["merge-base",a,"HEAD"],{cwd:r});l===0&&t.push(a)}if(t.length===0)throw new be(`No ancestor could be found between any of HEAD and ${e.join(", ")}`);let{stdout:i}=await Cr.execvp("git",["merge-base","HEAD",...t],{cwd:r,strict:!0}),n=i.trim(),{stdout:s}=await Cr.execvp("git",["show","--quiet","--pretty=format:%s",n],{cwd:r,strict:!0}),o=s.trim();return{hash:n,title:o}}async function Gae(r,{base:e,project:t}){let i=Ie.buildIgnorePattern(t.configuration.get("changesetIgnorePatterns")),{stdout:n}=await Cr.execvp("git",["diff","--name-only",`${e}`],{cwd:r,strict:!0}),s=n.split(/\r\n|\r|\n/).filter(c=>c.length>0).map(c=>x.resolve(r,K.toPortablePath(c))),{stdout:o}=await Cr.execvp("git",["ls-files","--others","--exclude-standard"],{cwd:r,strict:!0}),a=o.split(/\r\n|\r|\n/).filter(c=>c.length>0).map(c=>x.resolve(r,K.toPortablePath(c))),l=[...new Set([...s,...a].sort())];return i?l.filter(c=>!x.relative(t.cwd,c).match(i)):l}async function r3e({ref:r,project:e}){if(e.configuration.projectCwd===null)throw new be("This command can only be run from within a Yarn project");let t=[x.resolve(e.cwd,e.configuration.get("cacheFolder")),x.resolve(e.cwd,e.configuration.get("installStatePath")),x.resolve(e.cwd,e.configuration.get("lockfileFilename")),x.resolve(e.cwd,e.configuration.get("virtualFolder"))];await e.configuration.triggerHook(o=>o.populateYarnPaths,e,o=>{o!=null&&t.push(o)});let i=await Uae(e.configuration.projectCwd);if(i==null)throw new be("This command can only be run on Git repositories");let n=await Hae(i,{baseRefs:typeof r=="string"?[r]:e.configuration.get("changesetBaseRefs")}),s=await Gae(i,{base:n.hash,project:e});return new Set(Ie.mapAndFilter(s,o=>{let a=e.tryWorkspaceByFilePath(o);return a===null?Ie.mapAndFilter.skip:t.some(l=>o.startsWith(l))?Ie.mapAndFilter.skip:a}))}async function lO(r,e,t,{configuration:i,normalizedRepoUrl:n}){try{return await Cr.execvp("git",e,{...t,strict:!0})}catch(s){if(!(s instanceof Cr.ExecError))throw s;let o=s.reportExtra,a=s.stderr.toString();throw new at(1,`Failed ${r}`,l=>{l.reportError(1,`  ${ee.prettyField(i,{label:"Repository URL",value:ee.tuple(ee.Type.URL,n)})}`);for(let c of a.matchAll(/^(.+?): (.*)$/gm)){let[,u,g]=c;u=u.toLowerCase();let f=u==="error"?"Error":`${(0,Oae.default)(u)} Error`;l.reportError(1,`  ${ee.prettyField(i,{label:f,value:ee.tuple(ee.Type.NO_HINT,g)})}`)}o==null||o(l)})}}var RQ=class{supports(e,t){return Zh(e.reference)}getLocalPath(e,t){return null}async fetch(e,t){let i=t.checksums.get(e.locatorHash)||null,n=uO(e),s=new Map(t.checksums);s.set(n.locatorHash,i);let o={...t,checksums:s},a=await this.downloadHosted(n,o);if(a!==null)return a;let[l,c,u]=await t.cache.fetchPackageFromCache(e,i,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,`${P.prettyLocator(t.project.configuration,e)} can't be found in the cache and will be fetched from the remote repository`),loader:()=>this.cloneFromRemote(n,o),skipIntegrityCheck:t.skipIntegrityCheck,...t.cacheOptions});return{packageFs:l,releaseFs:c,prefixPath:P.getIdentVendorPath(e),checksum:u}}async downloadHosted(e,t){return t.project.configuration.reduceHook(i=>i.fetchHostedRepository,null,e,t)}async cloneFromRemote(e,t){let i=await fO(e.reference,t.project.configuration),n=Jm(e.reference),s=x.join(i,"package.tgz");await Wt.prepareExternalProject(i,s,{configuration:t.project.configuration,report:t.report,workspace:n.extra.workspace,locator:e});let o=await M.readFilePromise(s);return await Ie.releaseAfterUseAsync(async()=>await mi.convertToZip(o,{compressionLevel:t.project.configuration.get("compressionLevel"),prefixPath:P.getIdentVendorPath(e),stripComponents:1}))}};var FQ=class{supportsDescriptor(e,t){return Zh(e.range)}supportsLocator(e,t){return Zh(e.reference)}shouldPersistResolution(e,t){return!0}bindDescriptor(e,t,i){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,i){let n=await gO(e.range,i.project.configuration);return[P.makeLocator(e,n)]}async getSatisfying(e,t,i){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let i=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),n=await Ie.releaseAfterUseAsync(async()=>await ot.find(i.prefixPath,{baseFs:i.packageFs}),i.releaseFs);return{...e,version:n.version||"0.0.0",languageName:n.languageName||t.project.configuration.get("defaultLanguageName"),linkType:"HARD",conditions:n.getConditions(),dependencies:n.dependencies,peerDependencies:n.peerDependencies,dependenciesMeta:n.dependenciesMeta,peerDependenciesMeta:n.peerDependenciesMeta,bin:n.bin}}};var i3e={configuration:{changesetBaseRefs:{description:"The base git refs that the current HEAD is compared against when detecting changes. Supports git branches, tags, and commits.",type:"STRING",isArray:!0,isNullable:!1,default:["master","origin/master","upstream/master","main","origin/main","upstream/main"]},changesetIgnorePatterns:{description:"Array of glob patterns; files matching them will be ignored when fetching the changed files",type:"STRING",default:[],isArray:!0},cloneConcurrency:{description:"Maximal number of concurrent clones",type:"NUMBER",default:2}},fetchers:[RQ],resolvers:[FQ]};var n3e=i3e;var Fu=class extends De{constructor(){super(...arguments);this.since=z.String("--since",{description:"Only include workspaces that have been changed since the specified ref.",tolerateBoolean:!0});this.recursive=z.Boolean("-R,--recursive",!1,{description:"Find packages via dependencies/devDependencies instead of using the workspaces field"});this.noPrivate=z.Boolean("--no-private",{description:"Exclude workspaces that have the private field set to true"});this.verbose=z.Boolean("-v,--verbose",!1,{description:"Also return the cross-dependencies between workspaces"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i}=await je.find(t,this.context.cwd);return(await Ge.start({configuration:t,json:this.json,stdout:this.context.stdout},async s=>{let o=this.since?await aA.fetchChangedWorkspaces({ref:this.since,project:i}):i.workspaces,a=new Set(o);if(this.recursive)for(let l of[...o].map(c=>c.getRecursiveWorkspaceDependents()))for(let c of l)a.add(c);for(let l of a){let{manifest:c}=l;if(c.private&&this.noPrivate)continue;let u;if(this.verbose){let g=new Set,f=new Set;for(let h of ot.hardDependencies)for(let[p,C]of c.getForScope(h)){let y=i.tryWorkspaceByDescriptor(C);y===null?i.workspacesByIdent.has(p)&&f.add(C):g.add(y)}u={workspaceDependencies:Array.from(g).map(h=>h.relativeCwd),mismatchedWorkspaceDependencies:Array.from(f).map(h=>P.stringifyDescriptor(h))}}s.reportInfo(null,`${l.relativeCwd}`),s.reportJson({location:l.relativeCwd,name:c.name?P.stringifyIdent(c.name):null,...u})}})).exitCode()}};Fu.paths=[["workspaces","list"]],Fu.usage=ve.Usage({category:"Workspace-related commands",description:"list all available workspaces",details:"\n      This command will print the list of all workspaces in the project.\n\n      - If `--since` is set, Yarn will only list workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the `changesetBaseRefs` configuration option.\n\n      - If `-R,--recursive` is set, Yarn will find workspaces to run the command on by recursively evaluating `dependencies` and `devDependencies` fields, instead of looking at the `workspaces` fields.\n\n      - If `--no-private` is set, Yarn will not list any workspaces that have the `private` field set to `true`.\n\n      - If both the `-v,--verbose` and `--json` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).\n    "});var Nu=class extends De{constructor(){super(...arguments);this.workspaceName=z.String();this.commandName=z.String();this.args=z.Proxy()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);let s=i.workspaces,o=new Map(s.map(l=>[P.stringifyIdent(l.locator),l])),a=o.get(this.workspaceName);if(a===void 0){let l=Array.from(o.keys()).sort();throw new be(`Workspace '${this.workspaceName}' not found. Did you mean any of the following:
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`).join("")}`,{unqualifiedPath:ne,extensions:le})}}function ke(oe,le,we){var Ae;if(!le)throw new Error("Assertion failed: An issuer is required to resolve private import mappings");let fe=ile({name:oe,base:(0,rp.pathToFileURL)(K.fromPortablePath(le)),conditions:(Ae=we.conditions)!=null?Ae:D,readFileSyncFn:O});if(fe instanceof rp.URL)return he(K.toPortablePath((0,rp.fileURLToPath)(fe)),{extensions:we.extensions});if(fe.startsWith("#"))throw new Error("Mapping from one private import to another isn't allowed");return Fe(fe,le,we)}function Fe(oe,le,we={}){try{if(oe.startsWith("#"))return ke(oe,le,we);let{considerBuiltins:fe,extensions:Ae,conditions:qe}=we,ne=F(oe,le,{considerBuiltins:fe});if(oe==="pnpapi")return ne;if(ne===null)return null;let Y=()=>le!==null?V(le):!1,pe=(!fe||!eb(oe))&&!Y()?ue(oe,ne,qe):ne;return he(pe,{extensions:Ae})}catch(fe){throw Object.prototype.hasOwnProperty.call(fe,"pnpCode")&&Object.assign(fe.data,{request:fo(oe),issuer:le&&fo(le)}),fe}}function Ne(oe){let le=x.normalize(oe),we=Br.resolveVirtual(le);return we!==le?we:null}return{VERSIONS:W,topLevel:_,getLocator:(oe,le)=>Array.isArray(le)?{name:le[0],reference:le[1]}:{name:oe,reference:le},getDependencyTreeRoots:()=>[...r.dependencyTreeRoots],getAllLocators(){let oe=[];for(let[le,we]of f)for(let fe of we.keys())le!==null&&fe!==null&&oe.push({name:le,reference:fe});return oe},getPackageInformation:oe=>{let le=A(oe);if(le===null)return null;let we=K.fromPortablePath(le.packageLocation);return{...le,packageLocation:we}},findPackageLocator:oe=>re(K.toPortablePath(oe)),resolveToUnqualified:y("resolveToUnqualified",(oe,le,we)=>{let fe=le!==null?K.toPortablePath(le):null,Ae=F(K.toPortablePath(oe),fe,we);return Ae===null?null:K.fromPortablePath(Ae)}),resolveUnqualified:y("resolveUnqualified",(oe,le)=>K.fromPortablePath(he(K.toPortablePath(oe),le))),resolveRequest:y("resolveRequest",(oe,le,we)=>{let fe=le!==null?K.toPortablePath(le):null,Ae=Fe(K.toPortablePath(oe),fe,we);return Ae===null?null:K.fromPortablePath(Ae)}),resolveVirtual:y("resolveVirtual",oe=>{let le=Ne(K.toPortablePath(oe));return le!==null?K.fromPortablePath(le):null})}}var EBt=(0,fle.promisify)(gle.readFile);var hle=(r,e,t)=>{let i=rE(r),n=UO(i,{basePath:e}),s=K.join(e,xt.pnpCjs);return zO(n,{fakeFs:t,pnpapiResolution:s})};var XO=Pe(dle());var po={};ut(po,{checkAndReportManifestCompatibility:()=>mle,checkManifestCompatibility:()=>Cle,extractBuildScripts:()=>tb,getExtractHint:()=>ZO,hasBindingGyp:()=>_O});function Cle(r){return P.isPackageCompatible(r,Is.getArchitectureSet())}function mle(r,e,{configuration:t,report:i}){return Cle(r)?!0:(i==null||i.reportWarningOnce(76,`${P.prettyLocator(t,r)} The ${Is.getArchitectureName()} architecture is incompatible with this package, ${e} skipped.`),!1)}function tb(r,e,t,{configuration:i,report:n}){let s=[];for(let a of["preinstall","install","postinstall"])e.manifest.scripts.has(a)&&s.push([0,a]);return!e.manifest.scripts.has("install")&&e.misc.hasBindingGyp&&s.push([1,"node-gyp rebuild"]),s.length===0?[]:r.linkType!=="HARD"?(n==null||n.reportWarningOnce(6,`${P.prettyLocator(i,r)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`),[]):t&&t.built===!1?(n==null||n.reportInfoOnce(5,`${P.prettyLocator(i,r)} lists build scripts, but its build has been explicitly disabled through configuration.`),[]):!i.get("enableScripts")&&!t.built?(n==null||n.reportWarningOnce(4,`${P.prettyLocator(i,r)} lists build scripts, but all build scripts have been disabled.`),[]):mle(r,"build",{configuration:i,report:n})?s:[]}var oze=new Set([".exe",".h",".hh",".hpp",".c",".cc",".cpp",".java",".jar",".node"]);function ZO(r){return r.packageFs.getExtractHint({relevantExtensions:oze})}function _O(r){let e=x.join(r.prefixPath,"binding.gyp");return r.packageFs.existsSync(e)}var cE={};ut(cE,{getUnpluggedPath:()=>lE});function lE(r,{configuration:e}){return x.resolve(e.get("pnpUnpluggedFolder"),P.slugifyLocator(r))}var aze=new Set([P.makeIdent(null,"open").identHash,P.makeIdent(null,"opn").identHash]),ml=class{constructor(){this.mode="strict";this.pnpCache=new Map}supportsPackage(e,t){return this.isEnabled(t)}async findPackageLocation(e,t){if(!this.isEnabled(t))throw new Error("Assertion failed: Expected the PnP linker to be enabled");let i=El(t.project).cjs;if(!M.existsSync(i))throw new be(`The project in ${ee.pretty(t.project.configuration,`${t.project.cwd}/package.json`,ee.Type.PATH)} doesn't seem to have been installed - running an install there might help`);let n=Ie.getFactoryWithDefault(this.pnpCache,i,()=>Ie.dynamicRequire(i,{cachingStrategy:Ie.CachingStrategy.FsTime})),s={name:P.stringifyIdent(e),reference:e.reference},o=n.getPackageInformation(s);if(!o)throw new be(`Couldn't find ${P.prettyLocator(t.project.configuration,e)} in the currently installed PnP map - running an install might help`);return K.toPortablePath(o.packageLocation)}async findPackageLocator(e,t){if(!this.isEnabled(t))return null;let i=El(t.project).cjs;if(!M.existsSync(i))return null;let s=Ie.getFactoryWithDefault(this.pnpCache,i,()=>Ie.dynamicRequire(i,{cachingStrategy:Ie.CachingStrategy.FsTime})).findPackageLocator(K.fromPortablePath(e));return s?P.makeLocator(P.parseIdent(s.name),s.reference):null}makeInstaller(e){return new Uu(e)}isEnabled(e){return!(e.project.configuration.get("nodeLinker")!=="pnp"||e.project.configuration.get("pnpMode")!==this.mode)}},Uu=class{constructor(e){this.opts=e;this.mode="strict";this.asyncActions=new Ie.AsyncActions(10);this.packageRegistry=new Map;this.virtualTemplates=new Map;this.isESMLoaderRequired=!1;this.customData={store:new Map};this.unpluggedPaths=new Set;this.opts=e}getCustomDataKey(){return JSON.stringify({name:"PnpInstaller",version:2})}attachCustomData(e){this.customData=e}async installPackage(e,t,i){let n=P.stringifyIdent(e),s=e.reference,o=!!this.opts.project.tryWorkspaceByLocator(e),a=P.isVirtualLocator(e),l=e.peerDependencies.size>0&&!a,c=!l&&!o,u=!l&&e.linkType!=="SOFT",g,f;if(c||u){let D=a?P.devirtualizeLocator(e):e;g=this.customData.store.get(D.locatorHash),typeof g>"u"&&(g=await Aze(t),e.linkType==="HARD"&&this.customData.store.set(D.locatorHash,g)),g.manifest.type==="module"&&(this.isESMLoaderRequired=!0),f=this.opts.project.getDependencyMeta(D,e.version)}let h=c?tb(e,g,f,{configuration:this.opts.project.configuration,report:this.opts.report}):[],p=u?await this.unplugPackageIfNeeded(e,g,t,f,i):t.packageFs;if(x.isAbsolute(t.prefixPath))throw new Error(`Assertion failed: Expected the prefix path (${t.prefixPath}) to be relative to the parent`);let C=x.resolve(p.getRealPath(),t.prefixPath),y=$O(this.opts.project.cwd,C),B=new Map,v=new Set;if(a){for(let D of e.peerDependencies.values())B.set(P.stringifyIdent(D),null),v.add(P.stringifyIdent(D));if(!o){let D=P.devirtualizeLocator(e);this.virtualTemplates.set(D.locatorHash,{location:$O(this.opts.project.cwd,Br.resolveVirtual(C)),locator:D})}}return Ie.getMapWithDefault(this.packageRegistry,n).set(s,{packageLocation:y,packageDependencies:B,packagePeers:v,linkType:e.linkType,discardFromLookup:t.discardFromLookup||!1}),{packageLocation:C,buildDirective:h.length>0?h:null}}async attachInternalDependencies(e,t){let i=this.getPackageInformation(e);for(let[n,s]of t){let o=P.areIdentsEqual(n,s)?s.reference:[P.stringifyIdent(s),s.reference];i.packageDependencies.set(P.stringifyIdent(n),o)}}async attachExternalDependents(e,t){for(let i of t)this.getDiskInformation(i).packageDependencies.set(P.stringifyIdent(e),e.reference)}async finalizeInstall(){if(this.opts.project.configuration.get("pnpMode")!==this.mode)return;let e=El(this.opts.project);if(M.existsSync(e.cjsLegacy)&&(this.opts.report.reportWarning(0,`Removing the old ${ee.pretty(this.opts.project.configuration,xt.pnpJs,ee.Type.PATH)} file. You might need to manually update existing references to reference the new ${ee.pretty(this.opts.project.configuration,xt.pnpCjs,ee.Type.PATH)} file. If you use Editor SDKs, you'll have to rerun ${ee.pretty(this.opts.project.configuration,"yarn sdks",ee.Type.CODE)}.`),await M.removePromise(e.cjsLegacy)),this.isEsmEnabled()||await M.removePromise(e.esmLoader),this.opts.project.configuration.get("nodeLinker")!=="pnp"){await M.removePromise(e.cjs),await M.removePromise(this.opts.project.configuration.get("pnpDataPath")),await M.removePromise(e.esmLoader),await M.removePromise(this.opts.project.configuration.get("pnpUnpluggedFolder"));return}for(let{locator:u,location:g}of this.virtualTemplates.values())Ie.getMapWithDefault(this.packageRegistry,P.stringifyIdent(u)).set(u.reference,{packageLocation:g,packageDependencies:new Map,packagePeers:new Set,linkType:"SOFT",discardFromLookup:!1});this.packageRegistry.set(null,new Map([[null,this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)]]));let t=this.opts.project.configuration.get("pnpFallbackMode"),i=this.opts.project.workspaces.map(({anchoredLocator:u})=>({name:P.stringifyIdent(u),reference:u.reference})),n=t!=="none",s=[],o=new Map,a=Ie.buildIgnorePattern([".yarn/sdks/**",...this.opts.project.configuration.get("pnpIgnorePatterns")]),l=this.packageRegistry,c=this.opts.project.configuration.get("pnpShebang");if(t==="dependencies-only")for(let u of this.opts.project.storedPackages.values())this.opts.project.tryWorkspaceByLocator(u)&&s.push({name:P.stringifyIdent(u),reference:u.reference});return await this.asyncActions.wait(),await this.finalizeInstallWithPnp({dependencyTreeRoots:i,enableTopLevelFallback:n,fallbackExclusionList:s,fallbackPool:o,ignorePattern:a,packageRegistry:l,shebang:c}),{customData:this.customData}}async transformPnpSettings(e){}isEsmEnabled(){if(this.opts.project.configuration.sources.has("pnpEnableEsmLoader"))return this.opts.project.configuration.get("pnpEnableEsmLoader");if(this.isESMLoaderRequired)return!0;for(let e of this.opts.project.workspaces)if(e.manifest.type==="module")return!0;return!1}async finalizeInstallWithPnp(e){let t=El(this.opts.project),i=this.opts.project.configuration.get("pnpDataPath"),n=await this.locateNodeModules(e.ignorePattern);if(n.length>0){this.opts.report.reportWarning(31,"One or more node_modules have been detected and will be removed. This operation may take some time.");for(let o of n)await M.removePromise(o)}if(await this.transformPnpSettings(e),this.opts.project.configuration.get("pnpEnableInlining")){let o=HAe(e);await M.changeFilePromise(t.cjs,o,{automaticNewlines:!0,mode:493}),await M.removePromise(i)}else{let o=x.relative(x.dirname(t.cjs),i),{dataFile:a,loaderFile:l}=GAe({...e,dataLocation:o});await M.changeFilePromise(t.cjs,l,{automaticNewlines:!0,mode:493}),await M.changeFilePromise(i,a,{automaticNewlines:!0,mode:420})}this.isEsmEnabled()&&(this.opts.report.reportWarning(0,"ESM support for PnP uses the experimental loader API and is therefore experimental"),await M.changeFilePromise(t.esmLoader,(0,XO.default)(),{automaticNewlines:!0,mode:420}));let s=this.opts.project.configuration.get("pnpUnpluggedFolder");if(this.unpluggedPaths.size===0)await M.removePromise(s);else for(let o of await M.readdirPromise(s)){let a=x.resolve(s,o);this.unpluggedPaths.has(a)||await M.removePromise(a)}}async locateNodeModules(e){let t=[],i=e?new RegExp(e):null;for(let n of this.opts.project.workspaces){let s=x.join(n.cwd,"node_modules");if(i&&i.test(x.relative(this.opts.project.cwd,n.cwd))||!M.existsSync(s))continue;let o=await M.readdirPromise(s,{withFileTypes:!0}),a=o.filter(l=>!l.isDirectory()||l.name===".bin"||!l.name.startsWith("."));if(a.length===o.length)t.push(s);else for(let l of a)t.push(x.join(s,l.name))}return t}async unplugPackageIfNeeded(e,t,i,n,s){return this.shouldBeUnplugged(e,t,n)?this.unplugPackage(e,i,s):i.packageFs}shouldBeUnplugged(e,t,i){return typeof i.unplugged<"u"?i.unplugged:aze.has(e.identHash)||e.conditions!=null?!0:t.manifest.preferUnplugged!==null?t.manifest.preferUnplugged:!!(tb(e,t,i,{configuration:this.opts.project.configuration}).length>0||t.misc.extractHint)}async unplugPackage(e,t,i){let n=lE(e,{configuration:this.opts.project.configuration});return this.opts.project.disabledLocators.has(e.locatorHash)?new bo(n,{baseFs:t.packageFs,pathUtils:x}):(this.unpluggedPaths.add(n),i.holdFetchResult(this.asyncActions.set(e.locatorHash,async()=>{let s=x.join(n,t.prefixPath,".ready");await M.existsPromise(s)||(this.opts.project.storedBuildState.delete(e.locatorHash),await M.mkdirPromise(n,{recursive:!0}),await M.copyPromise(n,Oe.dot,{baseFs:t.packageFs,overwrite:!1}),await M.writeFilePromise(s,""))})),new qt(n))}getPackageInformation(e){let t=P.stringifyIdent(e),i=e.reference,n=this.packageRegistry.get(t);if(!n)throw new Error(`Assertion failed: The package information store should have been available (for ${P.prettyIdent(this.opts.project.configuration,e)})`);let s=n.get(i);if(!s)throw new Error(`Assertion failed: The package information should have been available (for ${P.prettyLocator(this.opts.project.configuration,e)})`);return s}getDiskInformation(e){let t=Ie.getMapWithDefault(this.packageRegistry,"@@disk"),i=$O(this.opts.project.cwd,e);return Ie.getFactoryWithDefault(t,i,()=>({packageLocation:i,packageDependencies:new Map,packagePeers:new Set,linkType:"SOFT",discardFromLookup:!1}))}};function $O(r,e){let t=x.relative(r,e);return t.match(/^\.{0,2}\//)||(t=`./${t}`),t.replace(/\/?$/,"/")}async function Aze(r){var i;let e=(i=await ot.tryFind(r.prefixPath,{baseFs:r.packageFs}))!=null?i:new ot,t=new Set(["preinstall","install","postinstall"]);for(let n of e.scripts.keys())t.has(n)||e.scripts.delete(n);return{manifest:{scripts:e.scripts,preferUnplugged:e.preferUnplugged,type:e.type},misc:{extractHint:ZO(r),hasBindingGyp:_O(r)}}}var Ele=Pe(yn());var Hu=class extends De{constructor(){super(...arguments);this.all=z.Boolean("-A,--all",!1,{description:"Unplug direct dependencies from the entire project"});this.recursive=z.Boolean("-R,--recursive",!1,{description:"Unplug both direct and transitive dependencies"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.patterns=z.Rest()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd),s=await Rt.find(t);if(!n)throw new ct(i.cwd,this.context.cwd);if(t.get("nodeLinker")!=="pnp")throw new be("This command can only be used if the `nodeLinker` option is set to `pnp`");await i.restoreInstallState();let o=new Set(this.patterns),a=this.patterns.map(h=>{let p=P.parseDescriptor(h),C=p.range!=="unknown"?p:P.makeDescriptor(p,"*");if(!vt.validRange(C.range))throw new be(`The range of the descriptor patterns must be a valid semver range (${P.prettyDescriptor(t,C)})`);return y=>{let B=P.stringifyIdent(y);return!Ele.default.isMatch(B,P.stringifyIdent(C))||y.version&&!vt.satisfiesWithPrereleases(y.version,C.range)?!1:(o.delete(h),!0)}}),l=()=>{let h=[];for(let p of i.storedPackages.values())!i.tryWorkspaceByLocator(p)&&!P.isVirtualLocator(p)&&a.some(C=>C(p))&&h.push(p);return h},c=h=>{let p=new Set,C=[],y=(B,v)=>{if(!p.has(B.locatorHash)&&(p.add(B.locatorHash),!i.tryWorkspaceByLocator(B)&&a.some(D=>D(B))&&C.push(B),!(v>0&&!this.recursive)))for(let D of B.dependencies.values()){let L=i.storedResolutions.get(D.descriptorHash);if(!L)throw new Error("Assertion failed: The resolution should have been registered");let H=i.storedPackages.get(L);if(!H)throw new Error("Assertion failed: The package should have been registered");y(H,v+1)}};for(let B of h){let v=i.storedPackages.get(B.anchoredLocator.locatorHash);if(!v)throw new Error("Assertion failed: The package should have been registered");y(v,0)}return C},u,g;if(this.all&&this.recursive?(u=l(),g="the project"):this.all?(u=c(i.workspaces),g="any workspace"):(u=c([n]),g="this workspace"),o.size>1)throw new be(`Patterns ${ee.prettyList(t,o,ee.Type.CODE)} don't match any packages referenced by ${g}`);if(o.size>0)throw new be(`Pattern ${ee.prettyList(t,o,ee.Type.CODE)} doesn't match any packages referenced by ${g}`);return u=Ie.sortMap(u,h=>P.stringifyLocator(h)),(await Ge.start({configuration:t,stdout:this.context.stdout,json:this.json},async h=>{var p;for(let C of u){let y=(p=C.version)!=null?p:"unknown",B=i.topLevelWorkspace.manifest.ensureDependencyMeta(P.makeDescriptor(C,y));B.unplugged=!0,h.reportInfo(0,`Will unpack ${P.prettyLocator(t,C)} to ${ee.pretty(t,lE(C,{configuration:t}),ee.Type.PATH)}`),h.reportJson({locator:P.stringifyLocator(C),version:y})}await i.topLevelWorkspace.persistManifest(),h.reportSeparator(),await i.install({cache:s,report:h})})).exitCode()}};Hu.paths=[["unplug"]],Hu.usage=ve.Usage({description:"force the unpacking of a list of packages",details:"\n      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.\n\n      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via `pnpUnpluggedFolder`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).\n\n      Running the command will set a persistent flag inside your top-level `package.json`, in the `dependenciesMeta` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run `yarn install` to apply the modification.\n\n      By default, only direct dependencies from the current workspace are affected. If `-A,--all` is set, direct dependencies from the entire project are affected. Using the `-R,--recursive` flag will affect transitive dependencies as well as direct ones.\n\n      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.\n    ",examples:[["Unplug the lodash dependency from the active workspace","yarn unplug lodash"],["Unplug all instances of lodash referenced by any workspace","yarn unplug lodash -A"],["Unplug all instances of lodash referenced by the active workspace and its dependencies","yarn unplug lodash -R"],["Unplug all instances of lodash, anywhere","yarn unplug lodash -AR"],["Unplug one specific version of lodash","yarn unplug lodash@1.2.3"],["Unplug all packages with the `@babel` scope","yarn unplug '@babel/*'"],["Unplug all packages (only for testing, not recommended)","yarn unplug -R '*'"]]});var El=r=>({cjs:x.join(r.cwd,xt.pnpCjs),cjsLegacy:x.join(r.cwd,xt.pnpJs),esmLoader:x.join(r.cwd,".pnp.loader.mjs")}),wle=r=>/\s/.test(r)?JSON.stringify(r):r;async function lze(r,e,t){let i=El(r),n=`--require ${wle(K.fromPortablePath(i.cjs))}`;if(M.existsSync(i.esmLoader)&&(n=`${n} --experimental-loader ${(0,yle.pathToFileURL)(K.fromPortablePath(i.esmLoader)).href}`),i.cjs.includes(" ")&&Ile.default.lt(process.versions.node,"12.0.0"))throw new Error(`Expected the build location to not include spaces when using Node < 12.0.0 (${process.versions.node})`);if(M.existsSync(i.cjs)){let s=e.NODE_OPTIONS||"",o=/\s*--require\s+\S*\.pnp\.c?js\s*/g,a=/\s*--experimental-loader\s+\S*\.pnp\.loader\.mjs\s*/;s=s.replace(o," ").replace(a," ").trim(),s=s?`${n} ${s}`:n,e.NODE_OPTIONS=s}}async function cze(r,e){let t=El(r);e(t.cjs),e(t.esmLoader),e(r.configuration.get("pnpDataPath")),e(r.configuration.get("pnpUnpluggedFolder"))}var uze={hooks:{populateYarnPaths:cze,setupScriptEnvironment:lze},configuration:{nodeLinker:{description:'The linker used for installing Node packages, one of: "pnp", "node-modules"',type:"STRING",default:"pnp"},pnpMode:{description:"If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.",type:"STRING",default:"strict"},pnpShebang:{description:"String to prepend to the generated PnP script",type:"STRING",default:"#!/usr/bin/env node"},pnpIgnorePatterns:{description:"Array of glob patterns; files matching them will use the classic resolution",type:"STRING",default:[],isArray:!0},pnpEnableEsmLoader:{description:"If true, Yarn will generate an ESM loader (`.pnp.loader.mjs`). If this is not explicitly set Yarn tries to automatically detect whether ESM support is required.",type:"BOOLEAN",default:!1},pnpEnableInlining:{description:"If true, the PnP data will be inlined along with the generated loader",type:"BOOLEAN",default:!0},pnpFallbackMode:{description:"If true, the generated PnP loader will follow the top-level fallback rule",type:"STRING",default:"dependencies-only"},pnpUnpluggedFolder:{description:"Folder where the unplugged packages must be stored",type:"ABSOLUTE_PATH",default:"./.yarn/unplugged"},pnpDataPath:{description:"Path of the file where the PnP data (used by the loader) must be written",type:"ABSOLUTE_PATH",default:"./.pnp.data.json"}},linkers:[ml],commands:[Hu]},gze=uze;var Dle=Pe(vle());var aM=Pe(J("crypto")),kle=Pe(J("fs")),Rle=1,kr="node_modules",rb=".bin",Fle=".yarn-state.yml",Pze=1e3;var ib=class{constructor(){this.installStateCache=new Map}supportsPackage(e,t){return this.isEnabled(t)}async findPackageLocation(e,t){if(!this.isEnabled(t))throw new Error("Assertion failed: Expected the node-modules linker to be enabled");let i=t.project.tryWorkspaceByLocator(e);if(i)return i.cwd;let n=await Ie.getFactoryWithDefault(this.installStateCache,t.project.cwd,async()=>await oM(t.project,{unrollAliases:!0}));if(n===null)throw new be("Couldn't find the node_modules state file - running an install might help (findPackageLocation)");let s=n.locatorMap.get(P.stringifyLocator(e));if(!s){let l=new be(`Couldn't find ${P.prettyLocator(t.project.configuration,e)} in the currently installed node_modules map - running an install might help`);throw l.code="LOCATOR_NOT_INSTALLED",l}let o=s.locations.sort((l,c)=>l.split(x.sep).length-c.split(x.sep).length),a=x.join(t.project.configuration.startingCwd,kr);return o.find(l=>x.contains(a,l))||s.locations[0]}async findPackageLocator(e,t){if(!this.isEnabled(t))return null;let i=await Ie.getFactoryWithDefault(this.installStateCache,t.project.cwd,async()=>await oM(t.project,{unrollAliases:!0}));if(i===null)return null;let{locationRoot:n,segments:s}=nb(x.resolve(e),{skipPrefix:t.project.cwd}),o=i.locationTree.get(n);if(!o)return null;let a=o.locator;for(let l of s){if(o=o.children.get(l),!o)break;a=o.locator||a}return P.parseLocator(a)}makeInstaller(e){return new sM(e)}isEnabled(e){return e.project.configuration.get("nodeLinker")==="node-modules"}},sM=class{constructor(e){this.opts=e;this.localStore=new Map;this.realLocatorChecksums=new Map;this.customData={store:new Map}}getCustomDataKey(){return JSON.stringify({name:"NodeModulesInstaller",version:2})}attachCustomData(e){this.customData=e}async installPackage(e,t){var u;let i=x.resolve(t.packageFs.getRealPath(),t.prefixPath),n=this.customData.store.get(e.locatorHash);if(typeof n>"u"&&(n=await Dze(e,t),e.linkType==="HARD"&&this.customData.store.set(e.locatorHash,n)),!P.isPackageCompatible(e,this.opts.project.configuration.getSupportedArchitectures()))return{packageLocation:null,buildDirective:null};let s=new Map,o=new Set;s.has(P.stringifyIdent(e))||s.set(P.stringifyIdent(e),e.reference);let a=e;if(P.isVirtualLocator(e)){a=P.devirtualizeLocator(e);for(let g of e.peerDependencies.values())s.set(P.stringifyIdent(g),null),o.add(P.stringifyIdent(g))}let l={packageLocation:`${K.fromPortablePath(i)}/`,packageDependencies:s,packagePeers:o,linkType:e.linkType,discardFromLookup:(u=t.discardFromLookup)!=null?u:!1};this.localStore.set(e.locatorHash,{pkg:e,customPackageData:n,dependencyMeta:this.opts.project.getDependencyMeta(e,e.version),pnpNode:l});let c=t.checksum?t.checksum.substring(t.checksum.indexOf("/")+1):null;return this.realLocatorChecksums.set(a.locatorHash,c),{packageLocation:i,buildDirective:null}}async attachInternalDependencies(e,t){let i=this.localStore.get(e.locatorHash);if(typeof i>"u")throw new Error("Assertion failed: Expected information object to have been registered");for(let[n,s]of t){let o=P.areIdentsEqual(n,s)?s.reference:[P.stringifyIdent(s),s.reference];i.pnpNode.packageDependencies.set(P.stringifyIdent(n),o)}}async attachExternalDependents(e,t){throw new Error("External dependencies haven't been implemented for the node-modules linker")}async finalizeInstall(){if(this.opts.project.configuration.get("nodeLinker")!=="node-modules")return;let e=new Br({baseFs:new On({libzip:await sn(),maxOpenFiles:80,readOnlyArchives:!0})}),t=await oM(this.opts.project),i=this.opts.project.configuration.get("nmMode");(t===null||i!==t.nmMode)&&(this.opts.project.storedBuildState.clear(),t={locatorMap:new Map,binSymlinks:new Map,locationTree:new Map,nmMode:i,mtimeMs:0});let n=new Map(this.opts.project.workspaces.map(f=>{var p,C;let h=this.opts.project.configuration.get("nmHoistingLimits");try{h=Ie.validateEnum($m,(C=(p=f.manifest.installConfig)==null?void 0:p.hoistingLimits)!=null?C:h)}catch{let B=P.prettyWorkspace(this.opts.project.configuration,f);this.opts.report.reportWarning(57,`${B}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values($m).join(", ")}, using default: "${h}"`)}return[f.relativeCwd,h]})),s=new Map(this.opts.project.workspaces.map(f=>{var p,C;let h=this.opts.project.configuration.get("nmSelfReferences");return h=(C=(p=f.manifest.installConfig)==null?void 0:p.selfReferences)!=null?C:h,[f.relativeCwd,h]})),o={VERSIONS:{std:1},topLevel:{name:null,reference:null},getLocator:(f,h)=>Array.isArray(h)?{name:h[0],reference:h[1]}:{name:f,reference:h},getDependencyTreeRoots:()=>this.opts.project.workspaces.map(f=>{let h=f.anchoredLocator;return{name:P.stringifyIdent(f.locator),reference:h.reference}}),getPackageInformation:f=>{let h=f.reference===null?this.opts.project.topLevelWorkspace.anchoredLocator:P.makeLocator(P.parseIdent(f.name),f.reference),p=this.localStore.get(h.locatorHash);if(typeof p>"u")throw new Error("Assertion failed: Expected the package reference to have been registered");return p.pnpNode},findPackageLocator:f=>{let h=this.opts.project.tryWorkspaceByCwd(K.toPortablePath(f));if(h!==null){let p=h.anchoredLocator;return{name:P.stringifyIdent(p),reference:p.reference}}throw new Error("Assertion failed: Unimplemented")},resolveToUnqualified:()=>{throw new Error("Assertion failed: Unimplemented")},resolveUnqualified:()=>{throw new Error("Assertion failed: Unimplemented")},resolveRequest:()=>{throw new Error("Assertion failed: Unimplemented")},resolveVirtual:f=>K.fromPortablePath(Br.resolveVirtual(K.toPortablePath(f)))},{tree:a,errors:l,preserveSymlinksRequired:c}=eE(o,{pnpifyFs:!1,validateExternalSoftLinks:!0,hoistingLimitsByCwd:n,project:this.opts.project,selfReferencesByCwd:s});if(!a){for(let{messageName:f,text:h}of l)this.opts.report.reportError(f,h);return}let u=MO(a);await Tze(t,u,{baseFs:e,project:this.opts.project,report:this.opts.report,realLocatorChecksums:this.realLocatorChecksums,loadManifest:async f=>{let h=P.parseLocator(f),p=this.localStore.get(h.locatorHash);if(typeof p>"u")throw new Error("Assertion failed: Expected the slot to exist");return p.customPackageData.manifest}});let g=[];for(let[f,h]of u.entries()){if(Ole(f))continue;let p=P.parseLocator(f),C=this.localStore.get(p.locatorHash);if(typeof C>"u")throw new Error("Assertion failed: Expected the slot to exist");if(this.opts.project.tryWorkspaceByLocator(C.pkg))continue;let y=po.extractBuildScripts(C.pkg,C.customPackageData,C.dependencyMeta,{configuration:this.opts.project.configuration,report:this.opts.report});y.length!==0&&g.push({buildLocations:h.locations,locatorHash:p.locatorHash,buildDirective:y})}return c&&this.opts.report.reportWarning(72,`The application uses portals and that's why ${ee.pretty(this.opts.project.configuration,"--preserve-symlinks",ee.Type.CODE)} Node option is required for launching it`),{customData:this.customData,records:g}}};async function Dze(r,e){var n;let t=(n=await ot.tryFind(e.prefixPath,{baseFs:e.packageFs}))!=null?n:new ot,i=new Set(["preinstall","install","postinstall"]);for(let s of t.scripts.keys())i.has(s)||t.scripts.delete(s);return{manifest:{bin:t.bin,scripts:t.scripts},misc:{extractHint:po.getExtractHint(e),hasBindingGyp:po.hasBindingGyp(e)}}}async function kze(r,e,t,i,{installChangedByUser:n}){let s="";s+=`# Warning: This file is automatically generated. Removing it is fine, but will
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`),i}function Ab(r){var e,t;if(((e=r.originalError)==null?void 0:e.name)!=="HTTPError")return!1;try{return((t=r.originalError)==null?void 0:t.response.headers["www-authenticate"].split(/,\s*/).map(n=>n.toLowerCase())).includes("otp")}catch{return!1}}function sp(r){return{["npm-otp"]:r}}var lb=class{supports(e,t){if(!e.reference.startsWith(gr))return!1;let{selector:i,params:n}=P.parseRange(e.reference);return!(!Yle.default.valid(i)||n===null||typeof n.__archiveUrl!="string")}getLocalPath(e,t){return null}async fetch(e,t){let i=t.checksums.get(e.locatorHash)||null,[n,s,o]=await t.cache.fetchPackageFromCache(e,i,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,`${P.prettyLocator(t.project.configuration,e)} can't be found in the cache and will be fetched from the remote server`),loader:()=>this.fetchFromNetwork(e,t),skipIntegrityCheck:t.skipIntegrityCheck,...t.cacheOptions});return{packageFs:n,releaseFs:s,prefixPath:P.getIdentVendorPath(e),checksum:o}}async fetchFromNetwork(e,t){let{params:i}=P.parseRange(e.reference);if(i===null||typeof i.__archiveUrl!="string")throw new Error("Assertion failed: The archiveUrl querystring parameter should have been available");let n=await mo(i.__archiveUrl,{configuration:t.project.configuration,ident:e});return await mi.convertToZip(n,{compressionLevel:t.project.configuration.get("compressionLevel"),prefixPath:P.getIdentVendorPath(e),stripComponents:1})}};var cb=class{supportsDescriptor(e,t){return!(!e.range.startsWith(gr)||!P.tryParseDescriptor(e.range.slice(gr.length),!0))}supportsLocator(e,t){return!1}shouldPersistResolution(e,t){throw new Error("Unreachable")}bindDescriptor(e,t,i){return e}getResolutionDependencies(e,t){let i=P.parseDescriptor(e.range.slice(gr.length),!0);return t.resolver.getResolutionDependencies(i,t)}async getCandidates(e,t,i){let n=P.parseDescriptor(e.range.slice(gr.length),!0);return await i.resolver.getCandidates(n,t,i)}async getSatisfying(e,t,i){let n=P.parseDescriptor(e.range.slice(gr.length),!0);return i.resolver.getSatisfying(n,t,i)}resolve(e,t){throw new Error("Unreachable")}};var jle=Pe(Xr()),qle=J("url");var Ns=class{supports(e,t){if(!e.reference.startsWith(gr))return!1;let i=new qle.URL(e.reference);return!(!jle.default.valid(i.pathname)||i.searchParams.has("__archiveUrl"))}getLocalPath(e,t){return null}async fetch(e,t){let i=t.checksums.get(e.locatorHash)||null,[n,s,o]=await t.cache.fetchPackageFromCache(e,i,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,`${P.prettyLocator(t.project.configuration,e)} can't be found in the cache and will be fetched from the remote registry`),loader:()=>this.fetchFromNetwork(e,t),skipIntegrityCheck:t.skipIntegrityCheck,...t.cacheOptions});return{packageFs:n,releaseFs:s,prefixPath:P.getIdentVendorPath(e),checksum:o}}async fetchFromNetwork(e,t){let i;try{i=await mo(Ns.getLocatorUrl(e),{configuration:t.project.configuration,ident:e})}catch{i=await mo(Ns.getLocatorUrl(e).replace(/%2f/g,"/"),{configuration:t.project.configuration,ident:e})}return await mi.convertToZip(i,{compressionLevel:t.project.configuration.get("compressionLevel"),prefixPath:P.getIdentVendorPath(e),stripComponents:1})}static isConventionalTarballUrl(e,t,{configuration:i}){let n=uA(e.scope,{configuration:i}),s=Ns.getLocatorUrl(e);return t=t.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/,"https:$1"),n=n.replace(/^https:\/\/registry\.npmjs\.org($|\/)/,"https://registry.yarnpkg.com$1"),t=t.replace(/^https:\/\/registry\.npmjs\.org($|\/)/,"https://registry.yarnpkg.com$1"),t===n+s||t===n+s.replace(/%2f/g,"/")}static getLocatorUrl(e){let t=vt.clean(e.reference.slice(gr.length));if(t===null)throw new at(10,"The npm semver resolver got selected, but the version isn't semver");return`${yl(e)}/-/${e.name}-${t}.tgz`}};var Jle=Pe(Xr());var ub=P.makeIdent(null,"node-gyp"),Wze=/\b(node-gyp|prebuild-install)\b/,gb=class{supportsDescriptor(e,t){return e.range.startsWith(gr)?!!vt.validRange(e.range.slice(gr.length)):!1}supportsLocator(e,t){if(!e.reference.startsWith(gr))return!1;let{selector:i}=P.parseRange(e.reference);return!!Jle.default.valid(i)}shouldPersistResolution(e,t){return!0}bindDescriptor(e,t,i){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,i){let n=vt.validRange(e.range.slice(gr.length));if(n===null)throw new Error(`Expected a valid range, got ${e.range.slice(gr.length)}`);let s=await mo(yl(e),{configuration:i.project.configuration,ident:e,jsonResponse:!0}),o=Ie.mapAndFilter(Object.keys(s.versions),c=>{try{let u=new vt.SemVer(c);if(n.test(u))return u}catch{}return Ie.mapAndFilter.skip}),a=o.filter(c=>!s.versions[c.raw].deprecated),l=a.length>0?a:o;return l.sort((c,u)=>-c.compare(u)),l.map(c=>{let u=P.makeLocator(e,`${gr}${c.raw}`),g=s.versions[c.raw].dist.tarball;return Ns.isConventionalTarballUrl(u,g,{configuration:i.project.configuration})?u:P.bindLocator(u,{__archiveUrl:g})})}async getSatisfying(e,t,i){let n=vt.validRange(e.range.slice(gr.length));if(n===null)throw new Error(`Expected a valid range, got ${e.range.slice(gr.length)}`);return Ie.mapAndFilter(t,s=>{try{let{selector:o}=P.parseRange(s,{requireProtocol:gr}),a=new vt.SemVer(o);if(n.test(a))return{reference:s,version:a}}catch{}return Ie.mapAndFilter.skip}).sort((s,o)=>-s.version.compare(o.version)).map(({reference:s})=>P.makeLocator(e,s))}async resolve(e,t){let{selector:i}=P.parseRange(e.reference),n=vt.clean(i);if(n===null)throw new at(10,"The npm semver resolver got selected, but the version isn't semver");let s=await mo(yl(e),{configuration:t.project.configuration,ident:e,jsonResponse:!0});if(!Object.prototype.hasOwnProperty.call(s,"versions"))throw new at(15,'Registry returned invalid data for - missing "versions" field');if(!Object.prototype.hasOwnProperty.call(s.versions,n))throw new at(16,`Registry failed to return reference "${n}"`);let o=new ot;if(o.load(s.versions[n]),!o.dependencies.has(ub.identHash)&&!o.peerDependencies.has(ub.identHash)){for(let a of o.scripts.values())if(a.match(Wze)){o.dependencies.set(ub.identHash,P.makeDescriptor(ub,"latest")),t.report.reportWarningOnce(32,`${P.prettyLocator(t.project.configuration,e)}: Implicit dependencies on node-gyp are discouraged`);break}}if(typeof o.raw.deprecated=="string"&&o.raw.deprecated!==""){let a=P.prettyLocator(t.project.configuration,e),l=o.raw.deprecated.match(/\S/)?`${a} is deprecated: ${o.raw.deprecated}`:`${a} is deprecated`;t.report.reportWarningOnce(61,l)}return{...e,version:n,languageName:"node",linkType:"HARD",conditions:o.getConditions(),dependencies:o.dependencies,peerDependencies:o.peerDependencies,dependenciesMeta:o.dependenciesMeta,peerDependenciesMeta:o.peerDependenciesMeta,bin:o.bin}}};var fb=class{supportsDescriptor(e,t){return!(!e.range.startsWith(gr)||!Pf.test(e.range.slice(gr.length)))}supportsLocator(e,t){return!1}shouldPersistResolution(e,t){throw new Error("Unreachable")}bindDescriptor(e,t,i){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,i){let n=e.range.slice(gr.length),s=await mo(yl(e),{configuration:i.project.configuration,ident:e,jsonResponse:!0});if(!Object.prototype.hasOwnProperty.call(s,"dist-tags"))throw new at(15,'Registry returned invalid data - missing "dist-tags" field');let o=s["dist-tags"];if(!Object.prototype.hasOwnProperty.call(o,n))throw new at(16,`Registry failed to return tag "${n}"`);let a=o[n],l=P.makeLocator(e,`${gr}${a}`),c=s.versions[a].dist.tarball;return Ns.isConventionalTarballUrl(l,c,{configuration:i.project.configuration})?[l]:[P.bindLocator(l,{__archiveUrl:c})]}async getSatisfying(e,t,i){return null}async resolve(e,t){throw new Error("Unreachable")}};var dp={};ut(dp,{getGitHead:()=>qVe,makePublishBody:()=>jVe});var i1={};ut(i1,{default:()=>SVe,packUtils:()=>Aa});var Aa={};ut(Aa,{genPackList:()=>Tb,genPackStream:()=>r1,genPackageManifest:()=>Bue,hasPackScripts:()=>e1,prepareForPack:()=>t1});var $M=Pe(yn()),yue=Pe(Cue()),wue=J("zlib"),pVe=["/package.json","/readme","/readme.*","/license","/license.*","/licence","/licence.*","/changelog","/changelog.*"],dVe=["/package.tgz",".github",".git",".hg","node_modules",".npmignore",".gitignore",".#*",".DS_Store"];async function e1(r){return!!(Wt.hasWorkspaceScript(r,"prepack")||Wt.hasWorkspaceScript(r,"postpack"))}async function t1(r,{report:e},t){await Wt.maybeExecuteWorkspaceLifecycleScript(r,"prepack",{report:e});try{let i=x.join(r.cwd,ot.fileName);await M.existsPromise(i)&&await r.manifest.loadFile(i,{baseFs:M}),await t()}finally{await Wt.maybeExecuteWorkspaceLifecycleScript(r,"postpack",{report:e})}}async function r1(r,e){var s,o;typeof e>"u"&&(e=await Tb(r));let t=new Set;for(let a of(o=(s=r.manifest.publishConfig)==null?void 0:s.executableFiles)!=null?o:new Set)t.add(x.normalize(a));for(let a of r.manifest.bin.values())t.add(x.normalize(a));let i=yue.default.pack();process.nextTick(async()=>{for(let a of e){let l=x.normalize(a),c=x.resolve(r.cwd,l),u=x.join("package",l),g=await M.lstatPromise(c),f={name:u,mtime:new Date(xr.SAFE_TIME*1e3)},h=t.has(l)?493:420,p,C,y=new Promise((v,D)=>{p=v,C=D}),B=v=>{v?C(v):p()};if(g.isFile()){let v;l==="package.json"?v=Buffer.from(JSON.stringify(await Bue(r),null,2)):v=await M.readFilePromise(c),i.entry({...f,mode:h,type:"file"},v,B)}else g.isSymbolicLink()?i.entry({...f,mode:h,type:"symlink",linkname:await M.readlinkPromise(c)},B):B(new Error(`Unsupported file type ${g.mode} for ${K.fromPortablePath(l)}`));await y}i.finalize()});let n=(0,wue.createGzip)();return i.pipe(n),n}async function Bue(r){let e=JSON.parse(JSON.stringify(r.manifest.raw));return await r.project.configuration.triggerHook(t=>t.beforeWorkspacePacking,r,e),e}async function Tb(r){var g,f,h,p,C,y,B,v;let e=r.project,t=e.configuration,i={accept:[],reject:[]};for(let D of dVe)i.reject.push(D);for(let D of pVe)i.accept.push(D);i.reject.push(t.get("rcFilename"));let n=D=>{if(D===null||!D.startsWith(`${r.cwd}/`))return;let L=x.relative(r.cwd,D),H=x.resolve(Oe.root,L);i.reject.push(H)};n(x.resolve(e.cwd,t.get("lockfileFilename"))),n(t.get("cacheFolder")),n(t.get("globalFolder")),n(t.get("installStatePath")),n(t.get("virtualFolder")),n(t.get("yarnPath")),await t.triggerHook(D=>D.populateYarnPaths,e,D=>{n(D)});for(let D of e.workspaces){let L=x.relative(r.cwd,D.cwd);L!==""&&!L.match(/^(\.\.)?\//)&&i.reject.push(`/${L}`)}let s={accept:[],reject:[]},o=(f=(g=r.manifest.publishConfig)==null?void 0:g.main)!=null?f:r.manifest.main,a=(p=(h=r.manifest.publishConfig)==null?void 0:h.module)!=null?p:r.manifest.module,l=(y=(C=r.manifest.publishConfig)==null?void 0:C.browser)!=null?y:r.manifest.browser,c=(v=(B=r.manifest.publishConfig)==null?void 0:B.bin)!=null?v:r.manifest.bin;o!=null&&s.accept.push(x.resolve(Oe.root,o)),a!=null&&s.accept.push(x.resolve(Oe.root,a)),typeof l=="string"&&s.accept.push(x.resolve(Oe.root,l));for(let D of c.values())s.accept.push(x.resolve(Oe.root,D));if(l instanceof Map)for(let[D,L]of l.entries())s.accept.push(x.resolve(Oe.root,D)),typeof L=="string"&&s.accept.push(x.resolve(Oe.root,L));let u=r.manifest.files!==null;if(u){s.reject.push("/*");for(let D of r.manifest.files)Que(s.accept,D,{cwd:Oe.root})}return await CVe(r.cwd,{hasExplicitFileList:u,globalList:i,ignoreList:s})}async function CVe(r,{hasExplicitFileList:e,globalList:t,ignoreList:i}){let n=[],s=new So(r),o=[[Oe.root,[i]]];for(;o.length>0;){let[a,l]=o.pop(),c=await s.lstatPromise(a);if(!Eue(a,{globalList:t,ignoreLists:c.isDirectory()?null:l}))if(c.isDirectory()){let u=await s.readdirPromise(a),g=!1,f=!1;if(!e||a!==Oe.root)for(let C of u)g=g||C===".gitignore",f=f||C===".npmignore";let h=f?await mue(s,a,".npmignore"):g?await mue(s,a,".gitignore"):null,p=h!==null?[h].concat(l):l;Eue(a,{globalList:t,ignoreLists:l})&&(p=[...l,{accept:[],reject:["**/*"]}]);for(let C of u)o.push([x.resolve(a,C),p])}else(c.isFile()||c.isSymbolicLink())&&n.push(x.relative(Oe.root,a))}return n.sort()}async function mue(r,e,t){let i={accept:[],reject:[]},n=await r.readFilePromise(x.join(e,t),"utf8");for(let s of n.split(/\n/g))Que(i.reject,s,{cwd:e});return i}function mVe(r,{cwd:e}){let t=r[0]==="!";return t&&(r=r.slice(1)),r.match(/\.{0,1}\//)&&(r=x.resolve(e,r)),t&&(r=`!${r}`),r}function Que(r,e,{cwd:t}){let i=e.trim();i===""||i[0]==="#"||r.push(mVe(i,{cwd:t}))}function Eue(r,{globalList:e,ignoreLists:t}){let i=Lb(r,e.accept);if(i!==0)return i===2;let n=Lb(r,e.reject);if(n!==0)return n===1;if(t!==null)for(let s of t){let o=Lb(r,s.accept);if(o!==0)return o===2;let a=Lb(r,s.reject);if(a!==0)return a===1}return!1}function Lb(r,e){let t=e,i=[];for(let n=0;n<e.length;++n)e[n][0]!=="!"?t!==e&&t.push(e[n]):(t===e&&(t=e.slice(0,n)),i.push(e[n].slice(1)));return Iue(r,i)?2:Iue(r,t)?1:0}function Iue(r,e){let t=e,i=[];for(let n=0;n<e.length;++n)e[n].includes("/")?t!==e&&t.push(e[n]):(t===e&&(t=e.slice(0,n)),i.push(e[n]));return!!($M.default.isMatch(r,t,{dot:!0,nocase:!0})||$M.default.isMatch(r,i,{dot:!0,basename:!0,nocase:!0}))}var Ju=class extends De{constructor(){super(...arguments);this.installIfNeeded=z.Boolean("--install-if-needed",!1,{description:"Run a preliminary `yarn install` if the package contains build scripts"});this.dryRun=z.Boolean("-n,--dry-run",!1,{description:"Print the file paths without actually generating the package archive"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.out=z.String("-o,--out",{description:"Create the archive at the specified path"});this.filename=z.String("--filename",{hidden:!0})}async execute(){var l;let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);await e1(n)&&(this.installIfNeeded?await i.install({cache:await Rt.find(t),report:new ti}):await i.restoreInstallState());let s=(l=this.out)!=null?l:this.filename,o=typeof s<"u"?x.resolve(this.context.cwd,EVe(s,{workspace:n})):x.resolve(n.cwd,"package.tgz");return(await Ge.start({configuration:t,stdout:this.context.stdout,json:this.json},async c=>{await t1(n,{report:c},async()=>{c.reportJson({base:K.fromPortablePath(n.cwd)});let u=await Tb(n);for(let g of u)c.reportInfo(null,K.fromPortablePath(g)),c.reportJson({location:K.fromPortablePath(g)});if(!this.dryRun){let g=await r1(n,u),f=M.createWriteStream(o);g.pipe(f),await new Promise(h=>{f.on("finish",h)})}}),this.dryRun||(c.reportInfo(0,`Package archive generated in ${ee.pretty(t,o,ee.Type.PATH)}`),c.reportJson({output:K.fromPortablePath(o)}))})).exitCode()}};Ju.paths=[["pack"]],Ju.usage=ve.Usage({description:"generate a tarball from the active workspace",details:"\n      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (`package.tgz`).\n\n      If the `-o,---out` is set the archive will be created at the specified path. The `%s` and `%v` variables can be used within the path and will be respectively replaced by the package name and version.\n    ",examples:[["Create an archive from the active workspace","yarn pack"],["List the files that would be made part of the workspace's archive","yarn pack --dry-run"],["Name and output the archive in a dedicated folder","yarn pack --out /artifacts/%s-%v.tgz"]]});function EVe(r,{workspace:e}){let t=r.replace("%s",IVe(e)).replace("%v",yVe(e));return K.toPortablePath(t)}function IVe(r){return r.manifest.name!==null?P.slugifyIdent(r.manifest.name):"package"}function yVe(r){return r.manifest.version!==null?r.manifest.version:"unknown"}var wVe=["dependencies","devDependencies","peerDependencies"],BVe="workspace:",QVe=(r,e)=>{var i,n;e.publishConfig&&(e.publishConfig.type&&(e.type=e.publishConfig.type),e.publishConfig.main&&(e.main=e.publishConfig.main),e.publishConfig.browser&&(e.browser=e.publishConfig.browser),e.publishConfig.module&&(e.module=e.publishConfig.module),e.publishConfig.exports&&(e.exports=e.publishConfig.exports),e.publishConfig.imports&&(e.imports=e.publishConfig.imports),e.publishConfig.bin&&(e.bin=e.publishConfig.bin));let t=r.project;for(let s of wVe)for(let o of r.manifest.getForScope(s).values()){let a=t.tryWorkspaceByDescriptor(o),l=P.parseRange(o.range);if(l.protocol===BVe)if(a===null){if(t.tryWorkspaceByIdent(o)===null)throw new at(21,`${P.prettyDescriptor(t.configuration,o)}: No local workspace found for this range`)}else{let c;P.areDescriptorsEqual(o,a.anchoredDescriptor)||l.selector==="*"?c=(i=a.manifest.version)!=null?i:"0.0.0":l.selector==="~"||l.selector==="^"?c=`${l.selector}${(n=a.manifest.version)!=null?n:"0.0.0"}`:c=l.selector;let u=s==="dependencies"?P.makeDescriptor(o,"unknown"):null,g=u!==null&&r.manifest.ensureDependencyMeta(u).optional?"optionalDependencies":s;e[g][P.stringifyIdent(o)]=c}}},bVe={hooks:{beforeWorkspacePacking:QVe},commands:[Ju]},SVe=bVe;var Fue=J("crypto"),Nue=Pe(Rue()),Lue=J("url");async function jVe(r,e,{access:t,tag:i,registry:n,gitHead:s}){let o=r.project.configuration,a=r.manifest.name,l=r.manifest.version,c=P.stringifyIdent(a),u=(0,Fue.createHash)("sha1").update(e).digest("hex"),g=Nue.default.fromData(e).toString();typeof t>"u"&&(r.manifest.publishConfig&&typeof r.manifest.publishConfig.access=="string"?t=r.manifest.publishConfig.access:o.get("npmPublishAccess")!==null?t=o.get("npmPublishAccess"):a.scope?t="restricted":t="public");let f=await Aa.genPackageManifest(r),h=`${c}-${l}.tgz`,p=new Lue.URL(`${Co(n)}/${c}/-/${h}`);return{_id:c,_attachments:{[h]:{content_type:"application/octet-stream",data:e.toString("base64"),length:e.length}},name:c,access:t,["dist-tags"]:{[i]:l},versions:{[l]:{...f,_id:`${c}@${l}`,name:c,version:l,gitHead:s,dist:{shasum:u,integrity:g,tarball:p.toString()}}}}}async function qVe(r){try{let{stdout:e}=await Cr.execvp("git",["rev-parse","--revs-only","HEAD"],{cwd:r});return e.trim()===""?void 0:e.trim()}catch{return}}var a1={npmAlwaysAuth:{description:"URL of the selected npm registry (note: npm enterprise isn't supported)",type:"BOOLEAN",default:!1},npmAuthIdent:{description:"Authentication identity for the npm registry (_auth in npm and yarn v1)",type:"SECRET",default:null},npmAuthToken:{description:"Authentication token for the npm registry (_authToken in npm and yarn v1)",type:"SECRET",default:null}},Tue={npmAuditRegistry:{description:"Registry to query for audit reports",type:"STRING",default:null},npmPublishRegistry:{description:"Registry to push packages to",type:"STRING",default:null},npmRegistryServer:{description:"URL of the selected npm registry (note: npm enterprise isn't supported)",type:"STRING",default:"https://registry.yarnpkg.com"}},JVe={configuration:{...a1,...Tue,npmScopes:{description:"Settings per package scope",type:"MAP",valueDefinition:{description:"",type:"SHAPE",properties:{...a1,...Tue}}},npmRegistries:{description:"Settings per registry",type:"MAP",normalizeKeys:Co,valueDefinition:{description:"",type:"SHAPE",properties:{...a1}}}},fetchers:[lb,Ns],resolvers:[cb,gb,fb]},WVe=JVe;var g1={};ut(g1,{default:()=>i7e});var vE=Pe(yn());as();var Ob=(i=>(i.All="all",i.Production="production",i.Development="development",i))(Ob||{}),Mb=(s=>(s.Info="info",s.Low="low",s.Moderate="moderate",s.High="high",s.Critical="critical",s))(Mb||{});var SE=["info","low","moderate","high","critical"];function Mue(r,e){let t=[],i=new Set,n=o=>{i.has(o)||(i.add(o),t.push(o))};for(let o of e)n(o);let s=new Set;for(;t.length>0;){let o=t.shift(),a=r.storedResolutions.get(o);if(typeof a>"u")throw new Error("Assertion failed: Expected the resolution to have been registered");let l=r.storedPackages.get(a);if(!!l){s.add(o);for(let c of l.dependencies.values())n(c.descriptorHash)}}return s}function zVe(r,e){return new Set([...r].filter(t=>!e.has(t)))}function VVe(r,e,{all:t}){let i=t?r.workspaces:[e],n=i.map(f=>f.manifest),s=new Set(n.map(f=>[...f.dependencies].map(([h,p])=>h)).flat()),o=new Set(n.map(f=>[...f.devDependencies].map(([h,p])=>h)).flat()),a=i.map(f=>[...f.dependencies.values()]).flat(),l=a.filter(f=>s.has(f.identHash)).map(f=>f.descriptorHash),c=a.filter(f=>o.has(f.identHash)).map(f=>f.descriptorHash),u=Mue(r,l),g=Mue(r,c);return zVe(g,u)}function Kue(r){let e={};for(let t of r)e[P.stringifyIdent(t)]=P.parseRange(t.range).selector;return e}function Uue(r){if(typeof r>"u")return new Set(SE);let e=SE.indexOf(r),t=SE.slice(e);return new Set(t)}function XVe(r,e){let t=Uue(e),i={};for(let n of t)i[n]=r[n];return i}function Hue(r,e){var i;let t=XVe(r,e);for(let n of Object.keys(t))if((i=t[n])!=null?i:0>0)return!0;return!1}function Gue(r,e){var s;let t={},i={children:t},n=Object.values(r.advisories);if(e!=null){let o=Uue(e);n=n.filter(a=>o.has(a.severity))}for(let o of Ie.sortMap(n,a=>a.module_name))t[o.module_name]={label:o.module_name,value:ee.tuple(ee.Type.RANGE,o.findings.map(a=>a.version).join(", ")),children:{ID:{label:"ID",value:ee.tuple(ee.Type.NUMBER,o.id)},Issue:{label:"Issue",value:ee.tuple(ee.Type.NO_HINT,o.title)},URL:{label:"URL",value:ee.tuple(ee.Type.URL,o.url)},Severity:{label:"Severity",value:ee.tuple(ee.Type.NO_HINT,o.severity)},["Vulnerable Versions"]:{label:"Vulnerable Versions",value:ee.tuple(ee.Type.RANGE,o.vulnerable_versions)},["Patched Versions"]:{label:"Patched Versions",value:ee.tuple(ee.Type.RANGE,o.patched_versions)},Via:{label:"Via",value:ee.tuple(ee.Type.NO_HINT,Array.from(new Set(o.findings.map(a=>a.paths).flat().map(a=>a.split(">")[0]))).join(", "))},Recommendation:{label:"Recommendation",value:ee.tuple(ee.Type.NO_HINT,(s=o.recommendation)==null?void 0:s.replace(/\n/g," "))}}};return i}function Yue(r,e,{all:t,environment:i}){let n=t?r.workspaces:[e],s=["all","production"].includes(i),o=[];if(s)for(let c of n)for(let u of c.manifest.dependencies.values())o.push(u);let a=["all","development"].includes(i),l=[];if(a)for(let c of n)for(let u of c.manifest.devDependencies.values())l.push(u);return Kue([...o,...l].filter(c=>P.parseRange(c.range).protocol===null))}function jue(r,e,{all:t}){var s;let i=VVe(r,e,{all:t}),n={};for(let o of r.storedPackages.values())n[P.stringifyIdent(o)]={version:(s=o.version)!=null?s:"0.0.0",integrity:o.identHash,requires:Kue(o.dependencies.values()),dev:i.has(P.convertLocatorToDescriptor(o).descriptorHash)};return n}var Vu=class extends De{constructor(){super(...arguments);this.all=z.Boolean("-A,--all",!1,{description:"Audit dependencies from all workspaces"});this.recursive=z.Boolean("-R,--recursive",!1,{description:"Audit transitive dependencies as well"});this.environment=z.String("--environment","all",{description:"Which environments to cover",validator:Vi(Ob)});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.severity=z.String("--severity","info",{description:"Minimal severity requested for packages to be displayed",validator:Vi(Mb)});this.excludes=z.Array("--exclude",[],{description:"Array of glob patterns of packages to exclude from audit"});this.ignores=z.Array("--ignore",[],{description:"Array of glob patterns of advisory ID's to ignore in the audit report"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState();let s=Yue(i,n,{all:this.all,environment:this.environment}),o=jue(i,n,{all:this.all});if(!this.recursive)for(let C of Object.keys(o))Object.prototype.hasOwnProperty.call(s,C)?o[C].requires={}:delete o[C];let a=Array.from(new Set([...t.get("npmAuditExcludePackages"),...this.excludes]));if(a){for(let C of Object.keys(s))vE.default.isMatch(C,a)&&delete s[C];for(let C of Object.keys(o))vE.default.isMatch(C,a)&&delete o[C];for(let C of Object.keys(o))for(let y of Object.keys(o[C].requires))vE.default.isMatch(y,a)&&delete o[C].requires[y]}let l={requires:s,dependencies:o},c=or.getAuditRegistry(n.manifest,{configuration:t}),u,g=await ra.start({configuration:t,stdout:this.context.stdout},async()=>{u=await Mt.post("/-/npm/v1/security/audits/quick",l,{authType:Mt.AuthType.BEST_EFFORT,configuration:t,jsonResponse:!0,registry:c})});if(g.hasErrors())return g.exitCode();let f=Array.from(new Set([...t.get("npmAuditIgnoreAdvisories"),...this.ignores]));if(f){for(let C of Object.keys(u.advisories))if(vE.default.isMatch(C,f)){let y=u.advisories[C];u.metadata.vulnerabilities[y.severity]-=1,delete u.advisories[C]}}let h=Hue(u.metadata.vulnerabilities,this.severity);return!this.json&&h?(_n.emitTree(Gue(u,this.severity),{configuration:t,json:this.json,stdout:this.context.stdout,separators:2}),1):(await Ge.start({configuration:t,includeFooter:!1,json:this.json,stdout:this.context.stdout},async C=>{C.reportJson(u),h||C.reportInfo(1,"No audit suggestions")})).exitCode()}};Vu.paths=[["npm","audit"]],Vu.usage=ve.Usage({description:"perform a vulnerability audit against the installed packages",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m    `,examples:[["Checks for known security issues with the installed packages. The output is a list of known issues.","yarn npm audit"],["Audit dependencies in all workspaces","yarn npm audit --all"],["Limit auditing to `dependencies` (excludes `devDependencies`)","yarn npm audit --environment production"],["Show audit report as valid JSON","yarn npm audit --json"],["Audit all direct and transitive dependencies","yarn npm audit --recursive"],["Output moderate (or more severe) vulnerabilities","yarn npm audit --severity moderate"],["Exclude certain packages","yarn npm audit --exclude package1 --exclude package2"],["Ignore specific advisories","yarn npm audit --ignore 1234567 --ignore 7654321"]]});var l1=Pe(Xr()),c1=J("util"),Xu=class extends De{constructor(){super(...arguments);this.fields=z.String("-f,--fields",{description:"A comma-separated list of manifest fields that should be displayed"});this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.packages=z.Rest()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i}=await je.find(t,this.context.cwd),n=typeof this.fields<"u"?new Set(["name",...this.fields.split(/\s*,\s*/)]):null,s=[],o=!1,a=await Ge.start({configuration:t,includeFooter:!1,json:this.json,stdout:this.context.stdout},async l=>{for(let c of this.packages){let u;if(c==="."){let L=i.topLevelWorkspace;if(!L.manifest.name)throw new be(`Missing ${ee.pretty(t,"name",ee.Type.CODE)} field in ${K.fromPortablePath(x.join(L.cwd,xt.manifest))}`);u=P.makeDescriptor(L.manifest.name,"unknown")}else u=P.parseDescriptor(c);let g=Mt.getIdentUrl(u),f=u1(await Mt.get(g,{configuration:t,ident:u,jsonResponse:!0,customErrorMessage:Mt.customPackageError})),h=Object.keys(f.versions).sort(l1.default.compareLoose),C=f["dist-tags"].latest||h[h.length-1],y=vt.validRange(u.range);if(y){let L=l1.default.maxSatisfying(h,y);L!==null?C=L:(l.reportWarning(0,`Unmet range ${P.prettyRange(t,u.range)}; falling back to the latest version`),o=!0)}else Object.prototype.hasOwnProperty.call(f["dist-tags"],u.range)?C=f["dist-tags"][u.range]:u.range!=="unknown"&&(l.reportWarning(0,`Unknown tag ${P.prettyRange(t,u.range)}; falling back to the latest version`),o=!0);let B=f.versions[C],v={...f,...B,version:C,versions:h},D;if(n!==null){D={};for(let L of n){let H=v[L];if(typeof H<"u")D[L]=H;else{l.reportWarning(1,`The ${ee.pretty(t,L,ee.Type.CODE)} field doesn't exist inside ${P.prettyIdent(t,u)}'s information`),o=!0;continue}}}else this.json||(delete v.dist,delete v.readme,delete v.users),D=v;l.reportJson(D),this.json||s.push(D)}});c1.inspect.styles.name="cyan";for(let l of s)(l!==s[0]||o)&&this.context.stdout.write(`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m`);return a.exitCode()}};Xu.paths=[["npm","info"]],Xu.usage=ve.Usage({category:"Npm-related commands",description:"show information about a package",details:"\n      This command fetches information about a package from the npm registry and prints it in a tree format.\n\n      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).\n\n      Append `@<range>` to the package argument to provide information specific to the latest version that satisfies the range or to the corresponding tagged version. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.\n\n      If the `-f,--fields` option is set, it's a comma-separated list of fields which will be used to only display part of the package information.\n\n      By default, this command won't return the `dist`, `readme`, and `users` fields, since they are often very long. To explicitly request those fields, explicitly list them with the `--fields` flag or request the output in JSON mode.\n    ",examples:[["Show all available information about react (except the `dist`, `readme`, and `users` fields)","yarn npm info react"],["Show all available information about react as valid JSON (including the `dist`, `readme`, and `users` fields)","yarn npm info react --json"],["Show all available information about react@16.12.0","yarn npm info react@16.12.0"],["Show all available information about react@next","yarn npm info react@next"],["Show the description of react","yarn npm info react --fields description"],["Show all available versions of react","yarn npm info react --fields versions"],["Show the readme of react","yarn npm info react --fields readme"],["Show a few fields of react","yarn npm info react --fields homepage,repository"]]});function u1(r){if(Array.isArray(r)){let e=[];for(let t of r)t=u1(t),t&&e.push(t);return e}else if(typeof r=="object"&&r!==null){let e={};for(let t of Object.keys(r)){if(t.startsWith("_"))continue;let i=u1(r[t]);i&&(e[t]=i)}return e}else return r||null}var que=Pe(Om()),Zu=class extends De{constructor(){super(...arguments);this.scope=z.String("-s,--scope",{description:"Login to the registry configured for a given scope"});this.publish=z.Boolean("--publish",!1,{description:"Login to the publish registry"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),i=await Kb({configuration:t,cwd:this.context.cwd,publish:this.publish,scope:this.scope});return(await Ge.start({configuration:t,stdout:this.context.stdout,includeFooter:!1},async s=>{let o=await $Ve({configuration:t,registry:i,report:s,stdin:this.context.stdin,stdout:this.context.stdout}),a=`/-/user/org.couchdb.user:${encodeURIComponent(o.name)}`,l=await Mt.put(a,o,{attemptedAs:o.name,configuration:t,registry:i,jsonResponse:!0,authType:Mt.AuthType.NO_AUTH});return await _Ve(i,l.token,{configuration:t,scope:this.scope}),s.reportInfo(0,"Successfully logged in")})).exitCode()}};Zu.paths=[["npm","login"]],Zu.usage=ve.Usage({category:"Npm-related commands",description:"store new login info to access the npm registry",details:"\n      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.\n\n      Adding the `-s,--scope` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also `npmScopes`).\n\n      Adding the `--publish` flag will cause the authentication to be done against the registry used when publishing the package (see also `publishConfig.registry` and `npmPublishRegistry`).\n    ",examples:[["Login to the default registry","yarn npm login"],["Login to the registry linked to the @my-scope registry","yarn npm login --scope my-scope"],["Login to the publish registry for the current package","yarn npm login --publish"]]});async function Kb({scope:r,publish:e,configuration:t,cwd:i}){return r&&e?or.getScopeRegistry(r,{configuration:t,type:or.RegistryType.PUBLISH_REGISTRY}):r?or.getScopeRegistry(r,{configuration:t}):e?or.getPublishRegistry((await Mh(t,i)).manifest,{configuration:t}):or.getDefaultRegistry({configuration:t})}async function _Ve(r,e,{configuration:t,scope:i}){let n=o=>a=>{let l=Ie.isIndexableObject(a)?a:{},c=l[o],u=Ie.isIndexableObject(c)?c:{};return{...l,[o]:{...u,npmAuthToken:e}}},s=i?{npmScopes:n(i)}:{npmRegistries:n(r)};return await ye.updateHomeConfiguration(s)}async function $Ve({configuration:r,registry:e,report:t,stdin:i,stdout:n}){t.reportInfo(0,`Logging in to ${ee.pretty(r,e,ee.Type.URL)}`);let s=!1;if(e.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)&&(t.reportInfo(0,"You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions."),s=!0),t.reportSeparator(),process.env.YARN_IS_TEST_ENV)return{name:process.env.YARN_INJECT_NPM_USER||"",password:process.env.YARN_INJECT_NPM_PASSWORD||""};let{username:o,password:a}=await(0,que.prompt)([{type:"input",name:"username",message:"Username:",required:!0,onCancel:()=>process.exit(130),stdin:i,stdout:n},{type:"password",name:"password",message:s?"Token:":"Password:",required:!0,onCancel:()=>process.exit(130),stdin:i,stdout:n}]);return t.reportSeparator(),{name:o,password:a}}var Cp=new Set(["npmAuthIdent","npmAuthToken"]),_u=class extends De{constructor(){super(...arguments);this.scope=z.String("-s,--scope",{description:"Logout of the registry configured for a given scope"});this.publish=z.Boolean("--publish",!1,{description:"Logout of the publish registry"});this.all=z.Boolean("-A,--all",!1,{description:"Logout of all registries"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),i=async()=>{var c;let s=await Kb({configuration:t,cwd:this.context.cwd,publish:this.publish,scope:this.scope}),o=await ye.find(this.context.cwd,this.context.plugins),a=P.makeIdent((c=this.scope)!=null?c:null,"pkg");return!or.getAuthConfiguration(s,{configuration:o,ident:a}).get("npmAuthToken")};return(await Ge.start({configuration:t,stdout:this.context.stdout},async s=>{if(this.all&&(await t7e(),s.reportInfo(0,"Successfully logged out from everything")),this.scope){await Jue("npmScopes",this.scope),await i()?s.reportInfo(0,`Successfully logged out from ${this.scope}`):s.reportWarning(0,"Scope authentication settings removed, but some other ones settings still apply to it");return}let o=await Kb({configuration:t,cwd:this.context.cwd,publish:this.publish});await Jue("npmRegistries",o),await i()?s.reportInfo(0,`Successfully logged out from ${o}`):s.reportWarning(0,"Registry authentication settings removed, but some other ones settings still apply to it")})).exitCode()}};_u.paths=[["npm","logout"]],_u.usage=ve.Usage({category:"Npm-related commands",description:"logout of the npm registry",details:"\n      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.\n\n      Adding the `-s,--scope` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also `npmScopes`).\n\n      Adding the `--publish` flag will cause the deletion to be done against the registry used when publishing the package (see also `publishConfig.registry` and `npmPublishRegistry`).\n\n      Adding the `-A,--all` flag will cause the deletion to be done against all registries and scopes.\n    ",examples:[["Logout of the default registry","yarn npm logout"],["Logout of the @my-scope scope","yarn npm logout --scope my-scope"],["Logout of the publish registry for the current package","yarn npm logout --publish"],["Logout of all registries","yarn npm logout --all"]]});function e7e(r,e){let t=r[e];if(!Ie.isIndexableObject(t))return!1;let i=new Set(Object.keys(t));if([...Cp].every(s=>!i.has(s)))return!1;for(let s of Cp)i.delete(s);if(i.size===0)return r[e]=void 0,!0;let n={...t};for(let s of Cp)delete n[s];return r[e]=n,!0}async function t7e(){let r=e=>{let t=!1,i=Ie.isIndexableObject(e)?{...e}:{};i.npmAuthToken&&(delete i.npmAuthToken,t=!0);for(let n of Object.keys(i))e7e(i,n)&&(t=!0);if(Object.keys(i).length!==0)return t?i:e};return await ye.updateHomeConfiguration({npmRegistries:r,npmScopes:r})}async function Jue(r,e){return await ye.updateHomeConfiguration({[r]:t=>{let i=Ie.isIndexableObject(t)?t:{};if(!Object.prototype.hasOwnProperty.call(i,e))return t;let n=i[e],s=Ie.isIndexableObject(n)?n:{},o=new Set(Object.keys(s));if([...Cp].every(l=>!o.has(l)))return t;for(let l of Cp)o.delete(l);if(o.size===0)return Object.keys(i).length===1?void 0:{...i,[e]:void 0};let a={};for(let l of Cp)a[l]=void 0;return{...i,[e]:{...s,...a}}}})}var $u=class extends De{constructor(){super(...arguments);this.access=z.String("--access",{description:"The access for the published package (public or restricted)"});this.tag=z.String("--tag","latest",{description:"The tag on the registry that the package should be attached to"});this.tolerateRepublish=z.Boolean("--tolerate-republish",!1,{description:"Warn and exit when republishing an already existing version of a package"});this.otp=z.String("--otp",{description:"The OTP token to use with the command"})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);if(n.manifest.private)throw new be("Private workspaces cannot be published");if(n.manifest.name===null||n.manifest.version===null)throw new be("Workspaces must have valid names and versions to be published on an external registry");await i.restoreInstallState();let s=n.manifest.name,o=n.manifest.version,a=or.getPublishRegistry(n.manifest,{configuration:t});return(await Ge.start({configuration:t,stdout:this.context.stdout},async c=>{var u,g;if(this.tolerateRepublish)try{let f=await Mt.get(Mt.getIdentUrl(s),{configuration:t,registry:a,ident:s,jsonResponse:!0});if(!Object.prototype.hasOwnProperty.call(f,"versions"))throw new at(15,'Registry returned invalid data for - missing "versions" field');if(Object.prototype.hasOwnProperty.call(f.versions,o)){c.reportWarning(0,`Registry already knows about version ${o}; skipping.`);return}}catch(f){if(((g=(u=f.originalError)==null?void 0:u.response)==null?void 0:g.statusCode)!==404)throw f}await Wt.maybeExecuteWorkspaceLifecycleScript(n,"prepublish",{report:c}),await Aa.prepareForPack(n,{report:c},async()=>{let f=await Aa.genPackList(n);for(let B of f)c.reportInfo(null,B);let h=await Aa.genPackStream(n,f),p=await Ie.bufferStream(h),C=await dp.getGitHead(n.cwd),y=await dp.makePublishBody(n,p,{access:this.access,tag:this.tag,registry:a,gitHead:C});await Mt.put(Mt.getIdentUrl(s),y,{configuration:t,registry:a,ident:s,otp:this.otp,jsonResponse:!0})}),c.reportInfo(0,"Package archive published")})).exitCode()}};$u.paths=[["npm","publish"]],$u.usage=ve.Usage({category:"Npm-related commands",description:"publish the active workspace to the npm registry",details:'\n      This command will pack the active workspace into a fresh archive and upload it to the npm registry.\n\n      The package will by default be attached to the `latest` tag on the registry, but this behavior can be overriden by using the `--tag` option.\n\n      Note that for legacy reasons scoped packages are by default published with an access set to `restricted` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the `--access public` flag. This behavior can be enabled by default through the `npmPublishAccess` settings.\n    ',examples:[["Publish the active workspace","yarn npm publish"]]});var Wue=Pe(Xr());var eg=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.package=z.String({required:!1})}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd),s;if(typeof this.package<"u")s=P.parseIdent(this.package);else{if(!n)throw new ct(i.cwd,this.context.cwd);if(!n.manifest.name)throw new be(`Missing 'name' field in ${K.fromPortablePath(x.join(n.cwd,xt.manifest))}`);s=n.manifest.name}let o=await xE(s,t),l={children:Ie.sortMap(Object.entries(o),([c])=>c).map(([c,u])=>({value:ee.tuple(ee.Type.RESOLUTION,{descriptor:P.makeDescriptor(s,c),locator:P.makeLocator(s,u)})}))};return _n.emitTree(l,{configuration:t,json:this.json,stdout:this.context.stdout})}};eg.paths=[["npm","tag","list"]],eg.usage=ve.Usage({category:"Npm-related commands",description:"list all dist-tags of a package",details:`
[35m.yarn/releases/yarn-3.5.0.cjs[m[36m:[m${s}`);let o=t.startsWith("/")?a=>a.slice(1):a=>a;return n.replace(new RegExp(`(a|b)(${Ie.escapeRegExp(`/${o(t)}/`)})`,"g"),"$1/").replace(new RegExp(`(a|b)${Ie.escapeRegExp(`/${o(i)}/`)}`,"g"),"$1/").replace(new RegExp(Ie.escapeRegExp(`${t}/`),"g"),"").replace(new RegExp(Ie.escapeRegExp(`${i}/`),"g"),"")}function I1(r,e){let t=[];for(let{source:i}of r){if(i===null)continue;let n=PE(i);for(let s of n){let{semverExclusivity:o,...a}=s;o!==null&&e!==null&&!vt.satisfiesWithPrereleases(e,o)||t.push(JSON.stringify(a))}}return li.makeHash(`${3}`,...t).slice(0,6)}function tge(r,{configuration:e,report:t}){for(let i of r.parts)for(let n of i.lines)switch(i.type){case"context":t.reportInfo(null,`  ${ee.pretty(e,n,"grey")}`);break;case"deletion":t.reportError(28,`- ${ee.pretty(e,n,ee.Type.REMOVED)}`);break;case"insertion":t.reportError(28,`+ ${ee.pretty(e,n,ee.Type.ADDED)}`);break;default:Ie.assertNever(i.type)}}var Gb=class{supports(e,t){return!!e.reference.startsWith("patch:")}getLocalPath(e,t){return null}async fetch(e,t){let i=t.checksums.get(e.locatorHash)||null,[n,s,o]=await t.cache.fetchPackageFromCache(e,i,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,`${P.prettyLocator(t.project.configuration,e)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.patchPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck,...t.cacheOptions});return{packageFs:n,releaseFs:s,prefixPath:P.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:o}}async patchPackage(e,t){let{parentLocator:i,sourceLocator:n,sourceVersion:s,patchPaths:o}=kE(e),a=await RE(i,o,t),l=await M.mktempPromise(),c=x.join(l,"current.zip"),u=await t.fetcher.fetch(n,t),g=P.getIdentVendorPath(e),f=await sn(),h=new Wr(c,{libzip:f,create:!0,level:t.project.configuration.get("compressionLevel")});await Ie.releaseAfterUseAsync(async()=>{await h.copyPromise(g,u.prefixPath,{baseFs:u.packageFs,stableSort:!0})},u.releaseFs),h.saveAndClose();for(let{source:p,optional:C}of a){if(p===null)continue;let y=new Wr(c,{libzip:f,level:t.project.configuration.get("compressionLevel")}),B=new qt(x.resolve(Oe.root,g),{baseFs:y});try{await Hb(PE(p),{baseFs:B,version:s})}catch(v){if(!(v instanceof Ep))throw v;let D=t.project.configuration.get("enableInlineHunks"),L=!D&&!C?" (set enableInlineHunks for details)":"",H=`${P.prettyLocator(t.project.configuration,e)}: ${v.message}${L}`,j=$=>{!D||tge(v.hunk,{configuration:t.project.configuration,report:$})};if(y.discardAndClose(),C){t.report.reportWarningOnce(66,H,{reportExtra:j});continue}else throw new at(66,H,j)}y.saveAndClose()}return new Wr(c,{libzip:f,level:t.project.configuration.get("compressionLevel")})}};var Yb=class{supportsDescriptor(e,t){return!!e.range.startsWith("patch:")}supportsLocator(e,t){return!!e.reference.startsWith("patch:")}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,i){let{patchPaths:n}=DE(e);return n.every(s=>!C1(s))?e:P.bindDescriptor(e,{locator:P.stringifyLocator(t)})}getResolutionDependencies(e,t){let{sourceDescriptor:i}=DE(e);return[i]}async getCandidates(e,t,i){if(!i.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let{parentLocator:n,sourceDescriptor:s,patchPaths:o}=DE(e),a=await RE(n,o,i.fetchOptions),l=t.get(s.descriptorHash);if(typeof l>"u")throw new Error("Assertion failed: The dependency should have been resolved");let c=I1(a,l.version);return[d1(e,{parentLocator:n,sourcePackage:l,patchPaths:o,patchHash:c})]}async getSatisfying(e,t,i){return null}async resolve(e,t){let{sourceLocator:i}=kE(e);return{...await t.resolver.resolve(i,t),...e}}};var sg=class extends De{constructor(){super(...arguments);this.save=z.Boolean("-s,--save",!1,{description:"Add the patch to your resolution entries"});this.patchFolder=z.String()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd);if(!n)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState();let s=x.resolve(this.context.cwd,K.toPortablePath(this.patchFolder)),o=x.join(s,"../source"),a=x.join(s,"../.yarn-patch.json");if(!M.existsSync(o))throw new be("The argument folder didn't get created by 'yarn patch'");let l=await E1(o,s),c=await M.readJsonPromise(a),u=P.parseLocator(c.locator,!0);if(!i.storedPackages.has(u.locatorHash))throw new be("No package found in the project for the given locator");if(!this.save){this.context.stdout.write(l);return}let g=t.get("patchFolder"),f=x.join(g,`${P.slugifyLocator(u)}.patch`);await M.mkdirPromise(g,{recursive:!0}),await M.writeFilePromise(f,l);let h=new Map;for(let p of i.storedPackages.values()){if(P.isVirtualLocator(p))continue;let C=p.dependencies.get(u.identHash);if(!C)continue;let y=P.isVirtualDescriptor(C)?P.devirtualizeDescriptor(C):C,B=h1(y),v=i.storedResolutions.get(B.descriptorHash);if(!v)throw new Error("Assertion failed: Expected the resolution to have been registered");if(!i.storedPackages.get(v))throw new Error("Assertion failed: Expected the package to have been registered");let L=i.originalPackages.get(p.locatorHash);if(!L)throw new Error("Assertion failed: Expected the original package to have been registered");let H=L.dependencies.get(C.identHash);if(!H)throw new Error("Assertion failed: Expected the original dependency to have been registered");h.set(H.descriptorHash,H)}for(let p of h.values()){let C=p1(p,{parentLocator:null,sourceDescriptor:P.convertLocatorToDescriptor(u),sourceVersion:null,patchPaths:[`./${x.relative(i.cwd,f)}`]});i.topLevelWorkspace.manifest.resolutions.push({pattern:{descriptor:{fullName:P.stringifyIdent(C),description:p.range}},reference:C.range})}await i.persist()}};sg.paths=[["patch-commit"]],sg.usage=ve.Usage({description:"generate a patch out of a directory",details:"\n      By default, this will print a patchfile on stdout based on the diff between the folder passed in and the original version of the package. Such file is suitable for consumption with the `patch:` protocol.\n\n      With the `-s,--save` option set, the patchfile won't be printed on stdout anymore and will instead be stored within a local file (by default kept within `.yarn/patches`, but configurable via the `patchFolder` setting). A `resolutions` entry will also be added to your top-level manifest, referencing the patched package via the `patch:` protocol.\n\n      Note that only folders generated by `yarn patch` are accepted as valid input for `yarn patch-commit`.\n    "});var og=class extends De{constructor(){super(...arguments);this.json=z.Boolean("--json",!1,{description:"Format the output as[1;31m an N[mDJSON stream"});this.package=z.String()}async execute(){let t=await ye.find(this.context.cwd,this.context.plugins),{project:i,workspace:n}=await je.find(t,this.context.cwd),s=await Rt.find(t);if(!n)throw new ct(i.cwd,this.context.cwd);await i.restoreInstallState();let o=P.parseLocator(this.package);if(o.reference==="unknown"){let a=Ie.mapAndFilter([...i.storedPackages.values()],l=>l.identHash!==o.identHash?Ie.mapAndFilter.skip:P.isVirtualLocator(l)?Ie.mapAndFilter.skip:l);if(a.length===0)throw new be("No package found in the project for the given locator");if(a.length>1)throw new be(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):
[35mHISTORY.md[m[36m:[m  Additionally, hides `toastr` behind[1;31m an m[module to handle UI's toast notifications.
[35mHISTORY.md[m[36m:[m  When trying to create a discussion using the top left sidebar modal with[1;31m an r[mole that don't have the `view-other-user-channels ` permission, an empty list would be shown, which is a wrong behavior.
[35mHISTORY.md[m[36m:[m  Video showing an example of the setting being used and creating[1;31m an n[mew user with the default roles via API.
[35mHISTORY.md[m[36m:[m  Currently the Visitor Abandonment timer isn't affected when the chat is forwarded. However this is affecting the UX in certain situations like eg: A bot forwarding a chat to[1;31m an h[muman agent
[35mHISTORY.md[m[36m:[m- Allow username change if LDAP is enabled but their username is not linked to[1;31m an L[mDAP field ([#19381](https://github.com/RocketChat/Rocket.Chat/pull/19381) by [@robertfromont](https://github.com/robertfromont))
[35mapps/meteor/HISTORY.md[m[36m:[m  Additionally, hides `toastr` behind[1;31m an m[module to handle UI's toast notifications.
[35mapps/meteor/HISTORY.md[m[36m:[m  When trying to create a discussion using the top left sidebar modal with[1;31m an r[mole that don't have the `view-other-user-channels ` permission, an empty list would be shown, which is a wrong behavior.
[35mapps/meteor/HISTORY.md[m[36m:[m  Video showing an example of the setting being used and creating[1;31m an n[mew user with the default roles via API.
[35mapps/meteor/HISTORY.md[m[36m:[m  Currently the Visitor Abandonment timer isn't affected when the chat is forwarded. However this is affecting the UX in certain situations like eg: A bot forwarding a chat to[1;31m an h[muman agent
[35mapps/meteor/HISTORY.md[m[36m:[m- Allow username change if LDAP is enabled but their username is not linked to[1;31m an L[mDAP field ([#19381](https://github.com/RocketChat/Rocket.Chat/pull/19381) by [@robertfromont](https://github.com/robertfromont))
[35mapps/meteor/app/livechat/imports/server/rest/sms.ts[m[36m:[m// @ts-expect-error - this is[1;31m an s[mpecial endpoint that requires the return to not be wrapped as regular returns
[35mapps/meteor/app/meteor-accounts-saml/README.md[m[36m:[m* Check for better/alternative SAML profile. I have the impression that the SAML Web Browser SSO profile somewhat conflicts with Meteor's DDP/websocket approach. Eg when the browser issues[1;31m an H[mTTP request, Meteor apps don't necessarily know from which user/session this request comes from (ja, we could use cookies but that's not the the Meteor-way).
[35mapps/meteor/app/search/server/model/SearchProvider.ts[m[36m:[m	 * @param callback is used to return result[1;31m an c[man be called with (error,result)
[35mapps/meteor/app/search/server/model/SearchProvider.ts[m[36m:[m	 * @param callback is used to return result[1;31m an c[man be called with (error,result)
[35mapps/meteor/app/settings/server/CachedSettings.ts[m[36m:[m	 * - In development mode if you are trying to get the value of a setting that is not defined, it will give[1;31m an w[marning, in theory it makes sense, there no reason to do that
[35mapps/meteor/app/settings/server/CachedSettings.ts[m[36m:[m	 * - In development mode if you are trying to get the value of a setting that is not defined, it will give[1;31m an w[marning, in theory it makes sense, there no reason to do that
[35mapps/meteor/client/lib/voip/VoIPUser.ts[m[36m:[m	 * Sets up[1;31m an l[mistener handler for handling session's state change
[35mapps/meteor/client/views/omnichannel/currentChats/hooks/useCurrentChats.ts[m[36m:[m		// TODO: Update this to use[1;31m an s[mtream of room changes instead of polling
[35mapps/meteor/ee/tests/unit/server/federation/server/application/room/sender/RoomServiceSender.spec.ts[m[36m:[m		it('should create the user locally if the inviter was provided and he/she is[1;31m an m[moderator', async () => {
[35mapps/meteor/packages/meteor-restivus/lib/route.js[m[36m:[m		Respond to[1;31m an H[mTTP request
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Accounts_Password_Policy_MaxLength_Description": "Stellt sicher, dass Passwörter nicht mehr als diese Anzahl[1;31m an Z[meichen haben. Verwenden Sie \"-1\" zum Deaktivieren.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Accounts_Password_Policy_MinLength_Description": "Stellt sicher, dass Kennwörter mindestens diese Anzahl[1;31m an Z[meichen aufweisen müssen. Verwenden Sie \"-1\" zum Deaktivieren.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "API_Allow_Infinite_Count_Description": "Sollen Aufrufe[1;31m an d[mie REST-API in einem Aufruf zurückgegeben werden?",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "API_Enable_Direct_Message_History_EndPoint_Description": "Dies ermöglicht die Datei \"/ api / v1 / im.history.others\", die das Anzeigen von direkten Nachrichten ermöglicht, die von anderen Benutzern gesendet werden,[1;31m an d[menen der Anrufer nicht beteiligt ist.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Dry_run_description": "Es wird nur eine E-Mail[1;31m an d[mie selbe Adresse wie im Feld Absender geschickt. Die E-Mailadresse muss einem gültigen Benutzer gehören.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Iframe_Integration_receive_enable_Description": "Erlaube dem übergeordneten Fenster, Befehle[1;31m an R[mocket.Chat zu senden.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Iframe_Integration_send_enable_Description": "Senden Sie Ereignisse[1;31m an d[mas übergeordnete Fenster",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Iframe_Integration_send_target_origin_Description": "Ursprung mit Protokollpräfix, welche Befehle[1;31m an z[m.B. \"https: // localhost\" oder *, um das Senden an einen beliebigen Ort zu ermöglichen.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Integration_Outgoing_WebHook_History_Data_Passed_To_Trigger": "Daten[1;31m an d[mie Integration übergeben",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Integration_Retry_Failed_Url_Calls_Description": "Sollte die Integration einen angemessenen Zeitraum versuchen, wenn der Aufruf[1;31m an d[mie URL fehlschlägt?",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "IRC_Port": "Der Port zum Binden[1;31m an d[men IRC-Host-Server.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "LDAP_Encryption_Description": "Die Verschlüsselungsmethode für sichere Kommunikation mit dem LDAP-Server. Die Beispiele enthalten `plain` (keine Verschlüsselung), `SSL/LDAPS` (von Anfang[1;31m an v[merschlüsselt) und `StartTLS` (zur verschlüsselten Kommunikation wechseln, sobald verbunden)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Messages_that_are_sent_to_the_Incoming_WebHook_will_be_posted_here": "Nachrichten, die[1;31m an d[men eingehenden Webhook gesendet werden, werden hier veröffentlicht.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Query_description": "Zusätzliche Bedingungen für die Bestimmung,[1;31m an w[melche Benutzer die E-Mails gesendet werden sollen. Ausgetragene Benutzer werden automatisch aus der Abfrage entfernt. Es muss ein gültiger JSON sein. Beispiel: \"{\"createdAt\":{\"$gt\":{\"$date\": \"2015-01-01T00:00:00.000Z\"}}}\"",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_a_test_mail_to_my_user": "Eine Test-E-Mail[1;31m an d[mie Benutzer senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_a_test_push_to_my_user": "Eine Test-Push-Nachricht[1;31m an m[mich senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_invitation_email_success": "Sie haben erfolgreich eine Einladung[1;31m an f[molgende E-Mail-Adressen versendet:",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_request_on_agent_message": "Anfrage[1;31m an B[merater - Nachrichten senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_request_on_visitor_message": "Senden Sie eine Anfrage[1;31m an d[mie Besuchernachrichten",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Send_your_JSON_payloads_to_this_URL": "Senden Sie Ihre JSON-Nutzlasten[1;31m an d[miese URL.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "SlackBridge_Out_Channels_Description": "Wählen Sie, welche Kanäle Nachrichten[1;31m an S[mlack zurücksenden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "SlackBridge_Out_Enabled_Description": "Wählen Sie aus, ob SlackBridge Ihre Nachrichten auch[1;31m an S[mlack zurücksenden soll",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Smarsh_Email_Description": "Smarsh E-Mail-Adresse,[1;31m an d[mie die EML-Datei gesendet werden soll.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-AT.i18n.json[m[36m:[m  "Statistics_reporting": "Sende Statistiken[1;31m an R[mocket.Chat",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Accounts_Send_Email_When_Activating": "Eine E-Mail[1;31m an d[men Benutzer senden, wenn dieser aktiviert wurde. ",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Accounts_Send_Email_When_Deactivating": "Eine E-Mail[1;31m an d[men Benutzer senden, wenn dieser deaktiviert wurde. ",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "API_Enable_Direct_Message_History_EndPoint_Description": "Aktiviere `/api/v1/im.history.others`. Hierüber ist es möglich, Direktnachrichten einzusehen,[1;31m an d[menen der Benutzer nicht beteiligt ist.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "API_Enable_Rate_Limiter_Dev_Description": "Sollen die   Anfragen[1;31m an d[mie Endpunkte in der Entwicklungsumgebung begrenzt werden?",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "API_Enable_Rate_Limiter_Limit_Time_Default_Description": "Standardzeitlimit zum Begrenzen der Anzahl von Aufrufen[1;31m an j[medem Endpunkt der REST-API (in ms)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Broadcast_Connected_Instances": "Broadcast[1;31m an v[merbundene Instanzen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Cloud_address_to_send_registration_to": "Die Adresse,[1;31m an d[mie Deine Cloud-Registrierungs-E-Mail gesendet werden soll.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Dry_run_description": "Es wird nur eine E-Mail[1;31m an d[mie Adresse aus dem Feld \"Absender\" geschickt. Die E-Mail-Adresse muss zu einem gültigen Benutzer gehören.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "FEDERATION_Domain_Alert": "Nach dem Aktivieren dieser Funktion darf dieser Wert nicht geändert werden. Änderungen[1;31m an d[mer Domain können wir noch nicht verarbeiten.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "FileUpload_GoogleStorage_Proxy_Avatars_Description": "Der Zugriff auf alle Avatare erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "FileUpload_GoogleStorage_Proxy_Uploads_Description": "Der Zugriff auf alle hochgelanden Dateien erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "FileUpload_S3_Proxy_Avatars_Description": "Der Zugriff auf alle Avatare erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "FileUpload_S3_Proxy_Uploads_Description": "Der Zugriff auf alle hochgelanden Dateien erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "If_this_email_is_registered": "Wenn es sich um eine registrierte E-Mail-Adresse handelt, werden wir[1;31m an d[miese eine Anleitung zum Zurücksetzen des Passworts senden. Solltest Du zeitnah keine E-Mail erhalten, versuche es noch einmal.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Iframe_Integration_receive_enable_Description": "Erlaube dem übergeordneten Fenster (parent window) Befehle[1;31m an R[mocket.Chat zu senden.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Iframe_Integration_send_enable_Description": "Sende Events[1;31m an d[mas übergeordnete Fenster (parent window)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Iframe_Integration_send_target_origin": "URL des Ziels,[1;31m an d[mas gesendet werden soll",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Iframe_Integration_send_target_origin_Description": "Herkunfts-URL (inkl. Protokoll-Präfix),[1;31m an d[mie die Befehle gesendet werden sollen (bspw. `https://localhost`, oder *, um ein Senden nicht einzuschränken",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Integration_Outgoing_WebHook_History_Data_Passed_To_Trigger": "Daten, die[1;31m an d[mie Integration übergeben wurden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Integration_Outgoing_WebHook_History_Data_Passed_To_URL": "Daten, die[1;31m an d[mie URL gesendet wurden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "LDAP_Encryption_Description": "Die Verschlüsselungsmethode für sichere Kommunikation mit dem LDAP-Server. Bspw. `plain` (keine Verschlüsselung), `SSL/LDAPS` (von Anfang[1;31m an v[merschlüsselt) und `StartTLS` (zur verschlüsselten Kommunikation wechseln, sobald verbunden wurde)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Messages_that_are_sent_to_the_Incoming_WebHook_will_be_posted_here": "Nachrichten, die[1;31m an d[men eingehenden Webhook gesendet werden, werden hier veröffentlicht",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "No_available_agents_to_transfer": "Kein Agent verfügbar,[1;31m an d[men übergeben werden kann",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Push_Setting_Requires_Restart_Alert": "Änderungen[1;31m an d[mieser Einstellung erfordern einen Neustart von Rocket.Chat",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Query_description": "Zusätzliche Einschränkung,[1;31m an w[melche Benutzer die E-Mail gesendet werden soll. Benutzer, die nicht benachrichtigt werden wollen, werden automatisch aus der Abfrage entfernt. Es muss ein gültiges JSON sein. Beispiel: \"{\"createdAt\":{\"$gt\":{\"$date\": \"2015-01-01T00:00:00.000Z\"}}}\"",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Send_a_test_mail_to_my_user": "Eine Test-E-Mail[1;31m an m[mich senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Send_a_test_push_to_my_user": "Eine Test-Push-Nachricht[1;31m an m[mich senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Send_data_into_RocketChat_in_realtime": "Daten[1;31m an R[mocket.Chat in Echtzeit senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Send_invitation_email_success": "Du hast eine Einladung[1;31m an f[molgende E-Mail-Adressen versendet:",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Send_your_JSON_payloads_to_this_URL": "Sende Deine JSON-Payload[1;31m an d[miese URL",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "SlackBridge_Out_All": "Alles[1;31m an S[mlackBridge senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "SlackBridge_Out_Channels_Description": "Auswählen, welche Kanäle[1;31m an S[mlack gesendet werden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "SlackBridge_Out_Enabled_Description": "Ob die SlackBridge auch Nachrichten aus Rocket.Chat[1;31m an S[mlack zurücksenden soll",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Smarsh_Email_Description": "Smarsh E-Mail-Adresse,[1;31m an d[mie die .eml-Datei gesendet werden soll.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "Statistics_reporting": "Sende Statistiken[1;31m an R[mocket.Chat",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "TargetRoom_Description": "Der Raum,[1;31m an d[men Nachrichten gesendet werden, wenn dieses Ereignis eintritt. Nur ein existierender Raum kann angegeben werden.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de-IN.i18n.json[m[36m:[m  "We_have_sent_password_email": "Wir haben Dir eine Anleitung zum Zurücksetzen des Passworts[1;31m an D[meine E-Mail-Adresse gesendet. Wenn Du keine E-Mail erhalten hast, versuch es bitte noch einmal.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Accounts_Default_User_Preferences_alsoSendThreadToChannel_Description": "Erlauben Sie den Benutzern, das Verhalten \"Auch[1;31m an d[men Kanal senden\" auszuwählen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Accounts_Send_Email_When_Activating": "Eine E-Mail[1;31m an d[men Benutzer senden, wenn dieser aktiviert wurde",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Accounts_Send_Email_When_Deactivating": "Eine E-Mail[1;31m an d[men Benutzer senden, wenn dieser deaktiviert wurde",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Also_send_thread_message_to_channel_behavior": "Senden Sie auch eine Thread-Nachricht[1;31m an d[mas Kanalverhalten",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Also_send_to_channel": "Auch[1;31m an d[men übergeordneten Kanal senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "API_Enable_Direct_Message_History_EndPoint_Description": "Dies aktiviert die Datei \"/ api / v1 / im.history.others\", die das Anzeigen von direkten Nachrichten ermöglicht, die von anderen Benutzern gesendet werden,[1;31m an d[menen der Anrufer nicht beteiligt ist.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "API_Enable_Rate_Limiter_Limit_Time_Default_Description": "Standardzeitlimit zum Begrenzen der Anzahl von Aufrufen[1;31m an j[medem Endpunkt der REST-API (in ms)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Broadcast_Connected_Instances": "Broadcast[1;31m an v[merbundene Instanzen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Cloud_address_to_send_registration_to": "Die Adresse,[1;31m an d[mie Ihre Cloud-Registrierungs-E-Mail gesendet werden soll.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Discussion_Description": "Diskussionen sind eine zusätzliche Möglichkeit, Unterhaltungen zu organisieren, die es erlaubt, Benutzer von außerhalb einzuladen,[1;31m an b[mestimmten Unterhaltungen teilzunehmen.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Do_not_provide_this_code_to_anyone": "Gib diesen Code nicht[1;31m an D[mritte weiter.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Dry_run_description": "Es wird nur eine E-Mail[1;31m an d[mie Adresse aus dem Feld \"Absender\" geschickt. Die E-Mail-Adresse muss zu einem gültigen Benutzer gehören.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "error-forwarding-department-target-not-allowed": "Die Weiterleitung[1;31m an d[mie Zielabteilung ist nicht erlaubt.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "error-returning-inquiry": "Fehler beim Zurückgeben der Anfrage[1;31m an d[mie Warteschlange",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Fallback_forward_department_description": "Ermöglicht es Ihnen, eine Ersatzabteilung anzugeben, die die Chats empfängt, die[1;31m an d[miese Abteilung weitergeleitet werden, falls gerade kein Online-Agent verfügbar ist",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FEDERATION_Domain_Alert": "Nach dem Aktivieren dieser Funktion darf dieser Wert nicht geändert werden. Änderungen[1;31m an d[mer Domain können wir noch nicht verarbeiten.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FileUpload_Enable_json_web_token_for_files_description": "Hängt eine JWT[1;31m an d[mie URLs der hochgeladenen Dateien an",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FileUpload_GoogleStorage_Proxy_Avatars_Description": "Der Zugriff auf alle Avatare erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen                               ",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FileUpload_GoogleStorage_Proxy_Uploads_Description": "Der Zugriff auf alle hochgelanden Dateien erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FileUpload_S3_Proxy_Avatars_Description": "Der Zugriff auf alle Avatare erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "FileUpload_S3_Proxy_Uploads_Description": "Der Zugriff auf alle hochgelanden Dateien erfolgt über den Rocket.Chat Server als Proxy, anstatt direkt die Asset-URL[1;31m an d[men Client weiterzureichen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "If_this_email_is_registered": "Wenn es sich um eine registrierte E-Mail-Adresse handelt, werden wir[1;31m an d[miese eine Anleitung zum Zurücksetzen des Passworts senden. Sollten Sie in Kürzen keine E-Mail erhalten, kommen Sie wieder und versuchen Sie es noch einmal.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Iframe_Integration_receive_enable_Description": "Erlaube dem übergeordneten Fenster (parent window) Befehle[1;31m an R[mocket.Chat zu senden.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Iframe_Integration_send_enable_Description": "Events[1;31m an d[mas übergeordnete Fenster (parent window) senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Iframe_Integration_send_target_origin": "URL des Ziels,[1;31m an d[mas gesendet werden soll",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Iframe_Integration_send_target_origin_Description": "Herkunfts-URL (inkl. Protokoll-Präfix),[1;31m an d[mie die Befehle gesendet werden sollen (bspw. `https://localhost`, oder *, um ein Senden nicht einzuschränken",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Integration_Outgoing_WebHook_History_Data_Passed_To_Trigger": "Daten, die[1;31m an d[mie Integration übergeben wurden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Integration_Outgoing_WebHook_History_Data_Passed_To_URL": "Daten, die[1;31m an d[mie URL gesendet wurden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "LDAP_Encryption_Description": "Die Verschlüsselungsmethode für sichere Kommunikation mit dem LDAP-Server. Bspw. `plain` (keine Verschlüsselung), `SSL/LDAPS` (von Anfang[1;31m an v[merschlüsselt) und `StartTLS` (zur verschlüsselten Kommunikation wechseln, sobald verbunden wurde)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Livechat_transfer_to_department": "{{from}} hat den Chat[1;31m an d[mie Abteilung {{to}} übergetragen",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Livechat_transfer_to_department_with_a_comment": "{{from}} hat den Chat[1;31m an d[mie Abteilung {{to}}  mit einem Kommentar übertragen: {{comment}}",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Max_number_of_chats_per_agent_description": "Die maximale Anzahl der gleichzeitigen Chats,[1;31m an d[menen die Agenten teilnehmen können",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Messages_that_are_sent_to_the_Incoming_WebHook_will_be_posted_here": "Nachrichten, die[1;31m an d[men eingehenden Webhook gesendet werden, werden hier veröffentlicht",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Mobex_sms_gateway_from_number_desc": "Ursprungsadresse / Telefonnummer beim Senden einer neuen SMS[1;31m an d[men Livechat-Client",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "No_available_agents_to_transfer": "Kein Agent verfügbar,[1;31m an d[men übergeben werden kann",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Push_Setting_Requires_Restart_Alert": "Änderungen[1;31m an d[mieser Einstellung erfordern einen Neustart von Rocket.Chat",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Query_description": "Zusätzliche Einschränkung,[1;31m an w[melche Benutzer die E-Mail gesendet werden soll. Benutzer, die nicht benachrichtigt werden wollen, werden automatisch aus der Abfrage entfernt. Es muss ein gültiges JSON sein. Beispiel: \"{\"createdAt\":{\"$gt\":{\"$date\": \"2015-01-01T00:00:00.000Z\"}}}\"",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_a_test_mail_to_my_user": "Eine Test-E-Mail[1;31m an m[mich senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_a_test_push_to_my_user": "Eine Test-Push-Nachricht[1;31m an m[mich senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_data_into_RocketChat_in_realtime": "Daten[1;31m an R[mocket.Chat in Echtzeit senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_invitation_email_success": "Sie haben eine erfolgreich Einladung[1;31m an f[molgende E-Mail-Adressen versendet:",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_request_on_visitor_message": "Eine Anfrage[1;31m an d[mie Besuchernachrichten senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Send_your_JSON_payloads_to_this_URL": "Senden Sie Ihre JSON-Nutzlasten[1;31m an d[miese URL",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "SlackBridge_Out_All": "Alles[1;31m an S[mlackBridge senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "SlackBridge_Out_Channels_Description": "Auswählen, welche Channels[1;31m an S[mlack gesendet werden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "SlackBridge_Out_Enabled_Description": "Auswählen, ob die SlackBridge auch Nachrichten aus Rocket.Chat[1;31m an S[mlack zurücksenden soll",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Smarsh_Email_Description": "Smarsh-E-Mail-Adresse,[1;31m an d[mie die .eml-Datei gesendet werden soll.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "SMS_Default_Omnichannel_Department_Description": "Wenn diese Einstellung aktiv ist, werden alle neuen eingehenden Chats, die von dieser Integration initiiert wurden,[1;31m an d[miese Abteilung weitergeleitet.  \nDiese Einstellung kann überschrieben werden, indem Sie den Parameter für die Abteilungsabfrage in der Anforderung weitergeben.  \nz.B. `https://{{SERVER_URL}}/api/v1/livechat/sms-incoming/twilio?department={{Department Id or Name}}`.  \nHinweis: wenn Sie den Abteilungsnamen verwenden, muss dieser URL-sicher sein.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Statistics_reporting": "Statistiken[1;31m an R[mocket.Chat senden",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "TargetRoom_Description": "Der Raum,[1;31m an d[men Nachrichten gesendet werden, wenn dieses Ereignis eintritt. Nur ein existierender Raum kann angegeben werden.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "Troubleshoot_Disable_Instance_Broadcast_Alert": "Diese Einstellung sorgt dafür, dass die Rocket.Chat-Instanzen keine Ereignisse mehr[1;31m an d[mie anderen Instanzen senden. Es kann also zu Problemen bei der Synchronisierung und Fehlverhalten kommen!",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "User_joined_the_conversation": "nimmt[1;31m an d[mem Gespräch teil",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "registration.page.resetPassword.sent": "Wenn es sich um eine registrierte E-Mail-Adresse handelt, werden wir[1;31m an d[miese eine Anleitung zum Zurücksetzen des Passworts senden. Sollten Sie in Kürzen keine E-Mail erhalten, kommen Sie wieder und versuchen Sie es noch einmal.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/de.i18n.json[m[36m:[m  "onboarding.page.magicLinkEmail.subtitle": "Klicken Sie auf den Link, in der gerade[1;31m an S[mie versandten E-Mail, um sich bei Ihrem Arbeitsbereich anzumelden. <1>Der Link verfällt in 30 Minuten.</1>",
[35mapps/meteor/packages/rocketchat-i18n/i18n/en.i18n.json[m[36m:[m  "LDAP_BaseDN_Description": "The fully qualified Distinguished Name (DN) of[1;31m an L[mDAP subtree you want to search for users and groups. You can add as many as you like; however, each group must be defined in the same domain base as the users that belong to it. Example: `ou=Users+ou=Projects,dc=Example,dc=com`. If you specify restricted user groups, only users that belong to those groups will be in scope. We recommend that you specify the top level of your LDAP directory tree as your domain base and use search filter to control access.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/en.i18n.json[m[36m:[m  "Presence_broadcast_disabled_Description": "This shows if the presence broadcast has been disabled automatically. This can happen if you don't have[1;31m an P[mremium License and have more than 200 concurrent connections.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Accounts_Admin_Email_Approval_Needed_With_Reason_Default": "<p>Bikarhêner <b>[name] ([email])</b> qeydkirî ye.</p><p>Reason: <b>[reason]</b></p><p>Ji kerema xwe \"Rêveberiya -LH_HTML_END> Bikarhênerên\" kontrol bikin ku ji bo çalak bike[1;31m an j[mê hilbijêre.</p>",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Accounts_Enrollment_Email_Description": "Dibe ku tu [name], [fname] ji bo navê bikarhêner, nav[1;31m an p[maşnav, bi rêzê ve bi kar tînin, [lname].  \n  Dibe ku tu [email] ji bo email bikarhêner bi kar tînin.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Accounts_SetDefaultAvatar_Description": "Pêwîste ku avatar dahûreke danûstandinê li ser OAuth Account[1;31m an G[mravatar bi bingehîn",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Accounts_TwoFactorAuthentication_MaxDelta_Description": "Maximum Delta diyar dike ku çiqas li kîjan tikan têne derbas kirin. Tokens di her 30 saetan de têne çêkirin, û ji bo duyemîn (30 * Maximum Delta) derbasdar e.  \nVebijêr: Bi bi Maximum Delta ve di 10 de, herkotek dikare 300 saetan berî[1;31m an j[mî piştî demjimêra xwe bi kar tîne. Vê gava ku demjimêrê muwekîlê bi rêkûpêk bi rasterast nayê girêdan e.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Accounts_UserAddedEmail_Description": "Dibe ku divê tu guhêrbaran li jêr bi kar tînin:  \n -  `[name]`, `[fname]`, `[lname]` ji bo navê bikarhêner full, nav[1;31m an p[maşnav, bi rêzê ve.  \n -  [email] ji bo email bikarhêner.  \n -  [password] ji bo şîfreya bikarhêner.  \n -  [Site_Name] û `[Site_URL]` ji bo Name Application û URL rêzê.  ",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Analytics_features_rooms_Description": "Tracks bûyerên custom related to çalakiyên li ser kanala[1;31m an j[mî komeke (create, bihêle, delete).",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "API_EmbedIgnoredHosts_Description": "De bêhnok-cuda lîsteya ordiyan[1;31m an n[mavnîşanên CIDR, wek nimûne. localhost, 127.0.0.1, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Audio_Notification_Value_Description": "Dibe ku dengek hûrgelan an[1;31m an j[mî paşnavên berbiçav be: şê, şehlîn, ding, dûr, hûr, çiqas, seasons",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Avatar_url_invalid_or_error": "The url provided nederbasdar[1;31m an g[mihîştina wan ne e. Ji kerema xwe re dîsa biceribîne, lê bi a url cuda.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Custom_Emoji_Error_Name_Or_Alias_Already_In_Use": "Emojî û[1;31m an y[mek ji aliyên xwe yên berê bikar anîn.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "edit-other-user-active-status_description": "Destûra ku hesabên din bikar bînin[1;31m an j[mî asteng bike",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "edit-other-user-info_description": "Destnîşankirina navê navê bikarhênerê din, navnîşê[1;31m an n[mavnîşa e-nameyê.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "edit-room_description": "Destûra ku navê navekî odeya xwe biguherînî, mijara nimûne (cûreyek taybet[1;31m an j[mî dewleta gelemperî) û statuya (çalakî[1;31m an j[mî arşîvkirî)",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Enter_Behaviour_Description": "Ev guherîn heke kûçeya navnîşê bişîne peyamek bişîne[1;31m an j[mî rêzikek xilas bike",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Forgot_Password_Description": "Hûn dikarin li cihên jêrîn bikar bînin:  \n - [forg_Password_Url] ji bo şîfreya vegera şîfreyê.  \n - navê [`[name]`, `[fname]`, `[lname]` ji bo navê bikarhênerê, first name[1;31m an n[mavê paşîn, paşê.  \n - `[email]` bo e-nameya bikarhêner.  \n - `[Site_Name]` û `[Site_URL]` ji bo navê navekî û navnîşê ya serî.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Highlights_How_To": "To hên bê dema ku yekî behsa peyv[1;31m an j[mî komepeyva, li vir wergeran lê zêde bike. Hûn dikarin gotinên[1;31m an k[momepeyvên me yên bi cureyên cuda cuda. Words highlight bi nusinyan ne.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "LDAP_User_Search_Field_Description": "Çawaniya LDAP ku tê nasîn user LDAP ku hewldanên di naskirinê. Vî warî de divê `be sAMAccountName` ji bo avahîyên herî çalak Directory, lê dibe ku` uid` bo din çareseriyên LDAP, wek OpenLDAP. Tu dikarî `mail` ji bo diyarkirina by email[1;31m an j[mî her tiştê ku wesf û tu dixwazî ​​bi kar tînin.  \n  Tu dikarî nirxên multiple ji hev veqetîne de bêhnok bête bi rê bikarhênerên têkevim bikaranîna identifiers multiple wek bikarhêner[1;31m an j[mî email bi kar tînin.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Mail_Message_Missing_to": "Divê tu yek[1;31m an j[mî zêdetir bikarhênerên hilbijêre yan ne yek[1;31m an j[mî zêdetir navnîşanên email, ji hev biqetîne.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Mailer_body_tags": "Tu <b>divê</b> [unsubscribe] ji bo link unsubscription bi kar tînin. <br/> Dibe ku tu [name], [fname] ji bo navê bikarhêner, nav[1;31m an p[maşnav, bi rêzê ve bi kar tînin, [lname]. <br/> Dibe ku tu [email] ji bo email bikarhêner bi kar tînin.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Opens_a_channel_group_or_direct_message": "Peyamek, grûp[1;31m an p[meyamê yekser veke",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Placeholder_for_email_or_username_login_field": "Placeholder bo email[1;31m an l[mogin Username warê",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Scan_QR_code": "Bikaranîna an authenticator-ê wekî Google Authenticator, Destpêk[1;31m an D[muo bikar bîne, ji kodê QR-ê diaxive. Ew ê koda 6 kesan nîşan dide ku hûn hewce bike ku jêrîn.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Select_service_to_login": "Select a xizmetê ji bo têketinê Barkirina picture xwe[1;31m an j[mî barkirina yek rasterast ji we re dibe",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Smarsh_Enabled_Description": "Ma ku pêwendiya smarsh eml ve tête[1;31m an j[mî na (pêwîstî 'Ji Ji Îmêlê ve di nav e-nameyê - SMTP) de tête tije ye. \"",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Sorry_page_you_requested_does_not_exist_or_was_deleted": "Ji kerema xwe, rûpelê ku we daxwaza daxwaza we tune ye[1;31m an j[mî jêbirin!",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Start_with_s_for_user_or_s_for_channel_Eg_s_or_s": "Destpêk bi <code class=\"inline\">%s</code> ji bo bikarhêner[1;31m an j[mî <code class=\"inline\">%s</code> ji bo kanala. Eg: <code class=\"inline\">%s</code> an <code class=\"inline\">%s</code>",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Stream_Cast_Address_Description": "IP[1;31m an H[mosta xwe ya Rocket. Wekî `192.168.1.1: 3000` an` localhost: 4000`",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "The_image_resize_will_not_work_because_we_can_not_detect_ImageMagick_or_GraphicsMagick_installed_in_your_server": "Mezinahiyê image xebata wê ne ji ber ku em nikarin bi durustî .Pêşîn[1;31m an G[mraphicsMagick li ser server te sazkirin.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "User_or_channel_name": "User[1;31m an k[manala name",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "Verification_Description": "Hûn dikarin liverên jêrîn bikar bînin:  \n - `[Verification_Url]` ji bo pejirandinê URL.  \n - navê [`[name]`, `[fname]`, `[lname]` ji bo navê bikarhênerê, first name[1;31m an n[mavê paşîn, paşê.  \n - `[email]` bo e-nameya bikarhêner.  \n - `[Site_Name]` û `[Site_URL]` ji bo navê navekî û navnîşê ya serî. ",
[35mapps/meteor/packages/rocketchat-i18n/i18n/ku.i18n.json[m[36m:[m  "view-room-administration_description": "Destûra daneyên peyamê yên giştî, taybet û rasterast bibînin. Pêwîste kapasîteya danûstandinan[1;31m an j[mî arşîvan nabe",
[35mapps/meteor/packages/rocketchat-i18n/i18n/no.i18n.json[m[36m:[m  "Please_select_visibility": "Vennligst velg[1;31m an s[mynlighet",
[35mapps/meteor/packages/rocketchat-i18n/i18n/tr.i18n.json[m[36m:[m  "Accounts_Enrollment_Email_Default": "<h1><strong>[Site_Name]</strong> sitesine hoşgeldiniz!</h1><p><a href=\"[Site_URL]\">[Site_URL]</a> 'a gidin ve şu[1;31m an m[mevcut en iyi açık kaynak sohbet çözümünü deneyin! </p>",
[35mapps/meteor/packages/rocketchat-i18n/i18n/tr.i18n.json[m[36m:[m  "Accounts_UserAddedEmail_Default": "<h1><strong>[Site_Name]</strong> sitesine hoşgeldiniz!</h1><p><a href=\"[Site_URL]\">[Site_URL]</a> 'a gidin ve şu[1;31m an m[mevcut en iyi açık kaynak sohbet çözümünü deneyin! </p> <p> E-mail [email] ve Şifre: [password] 'nizi kullanarak giriş yapabilirsiniz. İlk girişinizden sonra bunları değiştirmeniz gerekebilir.",
[35mapps/meteor/packages/rocketchat-i18n/i18n/tr.i18n.json[m[36m:[m  "StatusMessage_Placeholder": "Şu[1;31m an n[me yapıyorsun?",
[35mapps/meteor/packages/rocketchat-i18n/i18n/vi-VN.i18n.json[m[36m:[m  "API_EmbedSafePorts": "Cổng[1;31m an t[moàn",
[35mapps/meteor/server/lib/ldap/Connection.ts[m[36m:[m		Create[1;31m an L[mDAP search filter based on the username
[35mapps/meteor/server/lib/ldap/Manager.ts[m[36m:[m		// If we're merging[1;31m an l[mdap user with a local user, then we need to sync the data even if 'update data on login' is off.
[35mapps/meteor/server/models/raw/FederationEvents.ts[m[36m:[m					// @ts-expect-error - Is this properly typed? parentIds seems to be[1;31m an s[mtring[] (and its used as a filter on an $in query)
[35mapps/meteor/tests/end-to-end/api/01-users.js[m[36m:[m		it('should return an error when the user try to update info of[1;31m an n[monexistent user', (done) => {
[35mapps/meteor/tests/end-to-end/api/02-channels.js[m[36m:[m		it('should return[1;31m an f[miltered array of members by channel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/09-rooms.js[m[36m:[m		before('create[1;31m an c[mhannel', async () => {
[35mapps/meteor/tests/end-to-end/api/10-subscriptions.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/10-subscriptions.js[m[36m:[m		it('create[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/10-subscriptions.js[m[36m:[m		it('should fail when there are no messages on[1;31m an c[mhannel', (done) => {
[35mapps/meteor/tests/end-to-end/api/livechat/05-inquiries.ts[m[36m:[m		it('should throw an error if inquiryId is not[1;31m an s[mtring', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/08-triggers.ts[m[36m:[m		it('should fail if name is not[1;31m an s[mtring', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/08-triggers.ts[m[36m:[m		it('should fail if description is not[1;31m an s[mtring', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/08-triggers.ts[m[36m:[m		it('should fail if enabled is not[1;31m an b[moolean', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/08-triggers.ts[m[36m:[m		it('should fail if runOnce is not[1;31m an b[moolean', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/11-livechat.ts[m[36m:[m		it('should fail if rid is not[1;31m an s[mtring', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/12-priorites.ts[m[36m:[m		it('should create, find and delete[1;31m an s[mla', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/12-priorites.ts[m[36m:[m		it('should update[1;31m an s[mla', async () => {
[35mapps/meteor/tests/end-to-end/api/livechat/12-priorites.ts[m[36m:[m		it('should delete[1;31m an s[mla', async () => {
[35mapps/meteor/tests/unit/client/lib/federation/Federation.test.ts[m[36m:[m		it('should return true if the current room is federated one, a public one but the user is[1;31m an m[moderator', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/federation/FederationAddServerProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an F[mederationAddServerProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/federation/FederationJoinExternalPublicRoomProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an F[mederationJoinExternalPublicRoomProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/federation/FederationPublicRoomsProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an F[mederationPublicRoomProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/federation/FederationRemoveServerProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an F[mederationRemoveServerProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/teams/TeamsUpdateProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an T[meamsUpdateProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/video-conference/VideoConfCancelProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an V[mideoConfCancelProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/video-conference/VideoConfInfoProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an V[mideoConfInfoProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/video-conference/VideoConfJoinProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an V[mideoConfJoinProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/video-conference/VideoConfListProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an V[mideoConfListProps', () => {
[35mapps/meteor/tests/unit/definition/rest/v1/video-conference/VideoConfStartProps.spec.ts[m[36m:[m		it('should return false when provided anything that is not[1;31m an V[mideoConfStartProps', () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with empty data when model call returns empty array', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data', async () => {
[35mapps/meteor/tests/unit/server/services/omnichannel-analytics/AgentData.tests.ts[m[36m:[m		it('should return[1;31m an C[monversationData object with data when model call returns data with multiple agents', async () => {
[35mpackages/server-fetch/CHANGELOG.md[m[36m:[m- 35363420f0: Fixed an issue where the payload of[1;31m an H[mTTP request made by an app wouldn't be correctly encoded in some cases
[35mpackages/server-fetch/CHANGELOG.md[m[36m:[m- 35363420f0: Fixed an issue where the payload of[1;31m an H[mTTP request made by an app wouldn't be correctly encoded in some cases
