{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/models/server/raw/Roles.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/models/server/raw/Roles.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/models/server/raw/Roles.ts","inputSourceMap":{"version":3,"file":"app/models/server/raw/Roles.ts","sourceRoot":"","sources":["app/models/server/raw/Roles.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n\tCollection,\n\tCursor,\n\tFilterQuery,\n\tFindOneOptions,\n\tInsertOneWriteOpResult,\n\tUpdateWriteOpResult,\n\tWithId,\n\tWithoutProjection,\n} from 'mongodb';\n\nimport { IRole, IUser } from '../../../../definition/IUser';\nimport type { IRoom } from '../../../../definition/IRoom';\nimport { BaseRaw } from './BaseRaw';\nimport { SubscriptionsRaw } from './Subscriptions';\nimport { UsersRaw } from './Users';\n\ntype ScopedModelRoles = {\n\tSubscriptions: SubscriptionsRaw;\n\tUsers: UsersRaw;\n};\n\nexport class RolesRaw extends BaseRaw<IRole> {\n\tconstructor(public readonly col: Collection<IRole>, private readonly models: ScopedModelRoles, trash?: Collection<IRole>) {\n\t\tsuper(col, trash);\n\t}\n\n\tfindByUpdatedDate(updatedAfterDate: Date, options?: FindOneOptions<IRole>): Cursor<IRole> {\n\t\tconst query = {\n\t\t\t_updatedAt: { $gte: new Date(updatedAfterDate) },\n\t\t};\n\n\t\treturn options ? this.find(query, options) : this.find(query);\n\t}\n\n\tasync addUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.addUserRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tif (!Array.isArray(roles)) {\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tprocess.env.NODE_ENV === 'development' && console.warn(`[WARN] RolesRaw.addUserRoles: role: ${roleId} not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tawait this.models.Subscriptions.addRolesByUserId(userId, [role._id], scope);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.addRolesByUserId(userId, [role._id]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync isUserInRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.isUserInRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tif (await this.models.Subscriptions.isUserInRole(userId, roleId, scope)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tif (await this.models.Users.isUserInRole(userId, roleId)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync removeUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.removeUserRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tscope && (await this.models.Subscriptions.removeRolesByUserId(userId, [roleId], scope));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.removeRolesByUserId(userId, [roleId]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync findOneByIdOrName(_idOrName: IRole['_id'] | IRole['name'], options?: undefined): Promise<IRole | null>;\n\n\tasync findOneByIdOrName(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: WithoutProjection<FindOneOptions<IRole>>,\n\t): Promise<IRole | null>;\n\n\tasync findOneByIdOrName<P>(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: FindOneOptions<P extends IRole ? IRole : P>,\n\t): Promise<P | null>;\n\n\tfindOneByIdOrName<P>(_idOrName: IRole['_id'] | IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t$or: [\n\t\t\t\t{\n\t\t\t\t\t_id: _idOrName,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: _idOrName,\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tasync findOneByName<P = IRole>(name: IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\tname,\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tfindInIds<P>(ids: IRole['_id'][], options?: FindOneOptions<IRole>): P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\tname: {\n\t\t\t\t$in: ids,\n\t\t\t},\n\t\t};\n\n\t\treturn this.find(query, options || {}) as P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole>;\n\t}\n\n\tfindAllExceptIds<P>(ids: IRole['_id'][], options?: FindOneOptions<IRole>): P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t_id: {\n\t\t\t\t$nin: ids,\n\t\t\t},\n\t\t};\n\n\t\treturn this.find(query, options || {}) as P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole>;\n\t}\n\n\tupdateById(\n\t\t_id: IRole['_id'],\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'],\n\t\tdescription: IRole['description'] = '',\n\t\tmandatory2fa: IRole['mandatory2fa'] = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id }, { $set: queryData }, { upsert: true });\n\t}\n\n\tfindUsersInRole(roleId: IRole['_id'], scope?: IRoom['_id']): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions: WithoutProjection<FindOneOptions<IUser>>,\n\t): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole<P>(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions: FindOneOptions<P extends IUser ? IUser : P>,\n\t): Promise<Cursor<P extends IUser ? IUser : P>>;\n\n\tasync findUsersInRole<P>(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions?: any | undefined,\n\t): Promise<Cursor<IUser> | Cursor<P>> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.findUsersInRole method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\tif (!role) {\n\t\t\tthrow new Error('RolesRaw.findUsersInRole: role not found');\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.findUsersInRoles([role._id], scope, options);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.findUsersInRoles([role._id], null, options);\n\t\t}\n\t}\n\n\tcreateWithRandomId(\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'] = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<InsertOneWriteOpResult<WithId<IRole>>> {\n\t\tconst role = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.insertOne(role);\n\t}\n\n\tasync canAddUserToRole(uid: IUser['_id'], roleId: IRole['_id'], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.canAddUserToRole method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tconst role = await this.findOne({ _id: roleId }, { fields: { scope: 1 } } as FindOneOptions<IRole>);\n\t\tif (!role) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.isUserInRoleScope(uid);\n\t\t}\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/models/server/raw/Roles.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/models/server/raw/Roles.ts"}},"code":"let _asyncIterator;\n\nmodule.link(\"@babel/runtime/helpers/asyncIterator\", {\n  default(v) {\n    _asyncIterator = v;\n  }\n\n}, 0);\nmodule.export({\n  RolesRaw: () => RolesRaw\n});\nlet BaseRaw;\nmodule.link(\"./BaseRaw\", {\n  BaseRaw(v) {\n    BaseRaw = v;\n  }\n\n}, 0);\n\nclass RolesRaw extends BaseRaw {\n  constructor(col, models, trash) {\n    super(col, trash);\n    this.col = void 0;\n    this.models = void 0;\n    this.col = col;\n    this.models = models;\n  }\n\n  findByUpdatedDate(updatedAfterDate, options) {\n    const query = {\n      _updatedAt: {\n        $gte: new Date(updatedAfterDate)\n      }\n    };\n    return options ? this.find(query, options) : this.find(query);\n  }\n\n  addUserRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n        throw new Error('Roles.addUserRoles method received a role scope instead of a scope value.');\n      }\n\n      if (!Array.isArray(roles)) {\n        roles = [roles];\n        process.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n      }\n\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(roles), _step; _iteratorAbruptCompletion = !(_step = Promise.await(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const roleId = _step.value;\n          const role = Promise.await(this.findOneById(roleId, {\n            projection: {\n              scope: 1\n            }\n          }));\n\n          if (!role) {\n            process.env.NODE_ENV === 'development' && console.warn(\"[WARN] RolesRaw.addUserRoles: role: \".concat(roleId, \" not found\"));\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              Promise.await(this.models.Subscriptions.addRolesByUserId(userId, [role._id], scope));\n              break;\n\n            case 'Users':\n            default:\n              Promise.await(this.models.Users.addRolesByUserId(userId, [role._id]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            Promise.await(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    });\n  }\n\n  isUserInRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n        throw new Error('Roles.isUserInRoles method received a role scope instead of a scope value.');\n      }\n\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(roles), _step2; _iteratorAbruptCompletion2 = !(_step2 = Promise.await(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n          const roleId = _step2.value;\n          const role = Promise.await(this.findOneById(roleId, {\n            projection: {\n              scope: 1\n            }\n          }));\n\n          if (!role) {\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              if (Promise.await(this.models.Subscriptions.isUserInRole(userId, roleId, scope))) {\n                return true;\n              }\n\n              break;\n\n            case 'Users':\n            default:\n              if (Promise.await(this.models.Users.isUserInRole(userId, roleId))) {\n                return true;\n              }\n\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            Promise.await(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return false;\n    });\n  }\n\n  removeUserRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n        throw new Error('Roles.removeUserRoles method received a role scope instead of a scope value.');\n      }\n\n      var _iteratorAbruptCompletion3 = false;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(roles), _step3; _iteratorAbruptCompletion3 = !(_step3 = Promise.await(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {\n          const roleId = _step3.value;\n          const role = Promise.await(this.findOneById(roleId, {\n            projection: {\n              scope: 1\n            }\n          }));\n\n          if (!role) {\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              scope && Promise.await(this.models.Subscriptions.removeRolesByUserId(userId, [roleId], scope));\n              break;\n\n            case 'Users':\n            default:\n              Promise.await(this.models.Users.removeRolesByUserId(userId, [roleId]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n            Promise.await(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return true;\n    });\n  }\n\n  findOneByIdOrName(_idOrName, options) {\n    const query = {\n      $or: [{\n        _id: _idOrName\n      }, {\n        name: _idOrName\n      }]\n    };\n    return this.findOne(query, options);\n  }\n\n  findOneByName(name, options) {\n    return Promise.asyncApply(() => {\n      const query = {\n        name\n      };\n      return this.findOne(query, options);\n    });\n  }\n\n  findInIds(ids, options) {\n    const query = {\n      name: {\n        $in: ids\n      }\n    };\n    return this.find(query, options || {});\n  }\n\n  findAllExceptIds(ids, options) {\n    const query = {\n      _id: {\n        $nin: ids\n      }\n    };\n    return this.find(query, options || {});\n  }\n\n  updateById(_id, name, scope) {\n    let description = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let mandatory2fa = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const queryData = {\n      name,\n      scope,\n      description,\n      mandatory2fa\n    };\n    return this.updateOne({\n      _id\n    }, {\n      $set: queryData\n    }, {\n      upsert: true\n    });\n  }\n\n  findUsersInRole(roleId, scope, options) {\n    return Promise.asyncApply(() => {\n      if (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n        throw new Error('Roles.findUsersInRole method received a role scope instead of a scope value.');\n      }\n\n      const role = Promise.await(this.findOneById(roleId, {\n        projection: {\n          scope: 1\n        }\n      }));\n\n      if (!role) {\n        throw new Error('RolesRaw.findUsersInRole: role not found');\n      }\n\n      switch (role.scope) {\n        case 'Subscriptions':\n          return this.models.Subscriptions.findUsersInRoles([role._id], scope, options);\n\n        case 'Users':\n        default:\n          return this.models.Users.findUsersInRoles([role._id], null, options);\n      }\n    });\n  }\n\n  createWithRandomId(name) {\n    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Users';\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let protectedRole = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let mandatory2fa = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const role = {\n      name,\n      scope,\n      description,\n      protected: protectedRole,\n      mandatory2fa\n    };\n    return this.insertOne(role);\n  }\n\n  canAddUserToRole(uid, roleId, scope) {\n    return Promise.asyncApply(() => {\n      if (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n        throw new Error('Roles.canAddUserToRole method received a role scope instead of a scope value.');\n      }\n\n      const role = Promise.await(this.findOne({\n        _id: roleId\n      }, {\n        fields: {\n          scope: 1\n        }\n      }));\n\n      if (!role) {\n        return false;\n      }\n\n      switch (role.scope) {\n        case 'Subscriptions':\n          return this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\n        case 'Users':\n        default:\n          return this.models.Users.isUserInRoleScope(uid);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["app/models/server/raw/Roles.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n\tCollection,\n\tCursor,\n\tFilterQuery,\n\tFindOneOptions,\n\tInsertOneWriteOpResult,\n\tUpdateWriteOpResult,\n\tWithId,\n\tWithoutProjection,\n} from 'mongodb';\n\nimport { IRole, IUser } from '../../../../definition/IUser';\nimport type { IRoom } from '../../../../definition/IRoom';\nimport { BaseRaw } from './BaseRaw';\nimport { SubscriptionsRaw } from './Subscriptions';\nimport { UsersRaw } from './Users';\n\ntype ScopedModelRoles = {\n\tSubscriptions: SubscriptionsRaw;\n\tUsers: UsersRaw;\n};\n\nexport class RolesRaw extends BaseRaw<IRole> {\n\tconstructor(public readonly col: Collection<IRole>, private readonly models: ScopedModelRoles, trash?: Collection<IRole>) {\n\t\tsuper(col, trash);\n\t}\n\n\tfindByUpdatedDate(updatedAfterDate: Date, options?: FindOneOptions<IRole>): Cursor<IRole> {\n\t\tconst query = {\n\t\t\t_updatedAt: { $gte: new Date(updatedAfterDate) },\n\t\t};\n\n\t\treturn options ? this.find(query, options) : this.find(query);\n\t}\n\n\tasync addUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.addUserRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tif (!Array.isArray(roles)) {\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tprocess.env.NODE_ENV === 'development' && console.warn(`[WARN] RolesRaw.addUserRoles: role: ${roleId} not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tawait this.models.Subscriptions.addRolesByUserId(userId, [role._id], scope);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.addRolesByUserId(userId, [role._id]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync isUserInRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.isUserInRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tif (await this.models.Subscriptions.isUserInRole(userId, roleId, scope)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tif (await this.models.Users.isUserInRole(userId, roleId)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync removeUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.removeUserRoles method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tfor await (const roleId of roles) {\n\t\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tscope && (await this.models.Subscriptions.removeRolesByUserId(userId, [roleId], scope));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.removeRolesByUserId(userId, [roleId]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync findOneByIdOrName(_idOrName: IRole['_id'] | IRole['name'], options?: undefined): Promise<IRole | null>;\n\n\tasync findOneByIdOrName(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: WithoutProjection<FindOneOptions<IRole>>,\n\t): Promise<IRole | null>;\n\n\tasync findOneByIdOrName<P>(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: FindOneOptions<P extends IRole ? IRole : P>,\n\t): Promise<P | null>;\n\n\tfindOneByIdOrName<P>(_idOrName: IRole['_id'] | IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t$or: [\n\t\t\t\t{\n\t\t\t\t\t_id: _idOrName,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: _idOrName,\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tasync findOneByName<P = IRole>(name: IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\tname,\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tfindInIds<P>(ids: IRole['_id'][], options?: FindOneOptions<IRole>): P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\tname: {\n\t\t\t\t$in: ids,\n\t\t\t},\n\t\t};\n\n\t\treturn this.find(query, options || {}) as P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole>;\n\t}\n\n\tfindAllExceptIds<P>(ids: IRole['_id'][], options?: FindOneOptions<IRole>): P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t_id: {\n\t\t\t\t$nin: ids,\n\t\t\t},\n\t\t};\n\n\t\treturn this.find(query, options || {}) as P extends Pick<IRole, '_id'> ? Cursor<P> : Cursor<IRole>;\n\t}\n\n\tupdateById(\n\t\t_id: IRole['_id'],\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'],\n\t\tdescription: IRole['description'] = '',\n\t\tmandatory2fa: IRole['mandatory2fa'] = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id }, { $set: queryData }, { upsert: true });\n\t}\n\n\tfindUsersInRole(roleId: IRole['_id'], scope?: IRoom['_id']): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions: WithoutProjection<FindOneOptions<IUser>>,\n\t): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole<P>(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions: FindOneOptions<P extends IUser ? IUser : P>,\n\t): Promise<Cursor<P extends IUser ? IUser : P>>;\n\n\tasync findUsersInRole<P>(\n\t\troleId: IRole['_id'],\n\t\tscope: IRoom['_id'] | undefined,\n\t\toptions?: any | undefined,\n\t): Promise<Cursor<IUser> | Cursor<P>> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.findUsersInRole method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tconst role = await this.findOneById<Pick<IRole, '_id' | 'scope'>>(roleId, { projection: { scope: 1 } });\n\n\t\tif (!role) {\n\t\t\tthrow new Error('RolesRaw.findUsersInRole: role not found');\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.findUsersInRoles([role._id], scope, options);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.findUsersInRoles([role._id], null, options);\n\t\t}\n\t}\n\n\tcreateWithRandomId(\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'] = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<InsertOneWriteOpResult<WithId<IRole>>> {\n\t\tconst role = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.insertOne(role);\n\t}\n\n\tasync canAddUserToRole(uid: IUser['_id'], roleId: IRole['_id'], scope?: IRoom['_id']): Promise<boolean> {\n\t\tif (process.env.NODE_ENV === 'development' && (scope === 'Users' || scope === 'Subscriptions')) {\n\t\t\tthrow new Error('Roles.canAddUserToRole method received a role scope instead of a scope value.');\n\t\t}\n\n\t\tconst role = await this.findOne({ _id: roleId }, { fields: { scope: 1 } } as FindOneOptions<IRole>);\n\t\tif (!role) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.isUserInRoleScope(uid);\n\t\t}\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"020b8ccee7929e78f797daad91f7bc09ea280ce9"}
