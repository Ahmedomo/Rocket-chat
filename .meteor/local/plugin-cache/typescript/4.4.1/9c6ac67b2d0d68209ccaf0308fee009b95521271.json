{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/CommandHandler.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"server/services/voip/connector/asterisk/CommandHandler.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/CommandHandler.ts","inputSourceMap":{"version":3,"file":"server/services/voip/connector/asterisk/CommandHandler.ts","sourceRoot":"","sources":["server/services/voip/connector/asterisk/CommandHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class for executing command.\n * @remarks\n * This class abstracts lower details such as interface, connection and command objects\n * from the consumers of this class.\n * Connectors can be to different call-servers. For each call server, there will be\n * a multiple interfaces. e.g in case of asterisk, there are 3 types of interfaces.\n * Asterisk Gateway Interface (AGI) : Used for dialplan administration and manipulation\n * Asterisk Rest Interface (ARI) : Used for managing asterisk resources to build own application.\n * One of the use-case of ARI is for dynamically creating endpoints or listing existing recordings.\n * Asterisk Manager Interface (AMI) : Used for querying the information from asterisk.\n *\n * We shall be using only AMI interface in the for now. Other interfaces will be\n * added as and when required.\n */\nimport { Db } from 'mongodb';\n\nimport { Commands } from './Commands';\nimport { IConnection } from './IConnection';\nimport { Logger } from '../../../../lib/logger/Logger';\nimport { Command, CommandType } from './Command';\nimport { AMIConnection } from './ami/AMIConnection';\nimport { CommandFactory } from './ami/CommandFactory';\nimport { IVoipConnectorResult } from '../../../../../definition/IVoipConnectorResult';\nimport { IManagementConfigData, ServerType } from '../../../../../definition/IVoipServerConfig';\nimport { IManagementServerConnectionStatus } from '../../../../../definition/IVoipServerConnectivityStatus';\nimport { WebsocketConnection } from '../websocket/WebsocketConnection';\nimport { getServerConfigDataFromSettings } from '../../lib/Helper';\n\nconst version = 'Asterisk Connector 1.0';\n\nexport class CommandHandler {\n\tprivate connections: Map<CommandType, IConnection>;\n\n\tprivate logger: Logger;\n\n\tprivate continuousMonitor: Command;\n\n\tprivate db: Db;\n\n\tconstructor(db: Db) {\n\t\tthis.logger = new Logger('CommandHandler');\n\t\tthis.connections = new Map<CommandType, IConnection>();\n\t\tthis.db = db;\n\t}\n\n\tasync initConnection(commandType: CommandType): Promise<void> {\n\t\t// Initialize available connections\n\t\t// const connection = new AMIConnection();\n\t\tconst connection = new AMIConnection();\n\t\tlet config: any = null;\n\t\tif (commandType === CommandType.AMI) {\n\t\t\tconfig = getServerConfigDataFromSettings(ServerType.MANAGEMENT);\n\t\t}\n\t\tif (!config) {\n\t\t\tthis.logger.warn('Management server configuration not found');\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t * If we have the same type of connection already established, close it\n\t\t * and remove it from the map.\n\t\t */\n\t\tif (this.connections.get(commandType)?.isConnected()) {\n\t\t\tthis.logger.error({ msg: 'connection exists. Closing the connection.' });\n\t\t\tthis.connections.get(commandType)?.closeConnection();\n\t\t\tthis.connections.delete(commandType);\n\t\t}\n\t\ttry {\n\t\t\tawait connection.connect(\n\t\t\t\tconfig.host,\n\t\t\t\t(config.configData as IManagementConfigData).port.toString(),\n\t\t\t\t(config.configData as IManagementConfigData).username,\n\t\t\t\t(config.configData as IManagementConfigData).password,\n\t\t\t);\n\t\t\tthis.connections.set(commandType, connection);\n\t\t\tthis.continuousMonitor = CommandFactory.getCommandObject(Commands.event_stream, this.db);\n\t\t\tthis.continuousMonitor.connection = this.connections.get(this.continuousMonitor.type) as IConnection;\n\t\t\tthis.continuousMonitor.initMonitor({});\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'Management server connection error', error });\n\t\t}\n\t}\n\n\t/* Executes |commandToExecute| on a particular command object\n\t * @remarks\n\t * CommandFactory is responsible for creating a |Command| object necessary\n\t * for executing an AMI command. Every concrete command object inherits\n\t * from class |Command|. Which overrides a method called executeCommand.\n\t * This function returns a promise. Caller can wait for the promise to resolve\n\t * or rejected.\n\t */\n\texecuteCommand(commandToExecute: Commands, commandData?: any): Promise<IVoipConnectorResult> {\n\t\tthis.logger.debug({ msg: `executeCommand() executing ${Commands[commandToExecute]}` });\n\t\tconst command = CommandFactory.getCommandObject(commandToExecute, this.db);\n\t\tconst connection = this.connections.get(command.type) as IConnection;\n\t\tif (!connection || !connection.isConnected()) {\n\t\t\tthrow Error('Connection error');\n\t\t}\n\t\tcommand.connection = this.connections.get(command.type) as IConnection;\n\t\treturn command.executeCommand(commandData);\n\t}\n\n\t// Get the version string\n\tgetVersion(): string {\n\t\treturn version;\n\t}\n\n\tasync checkManagementConnection(\n\t\thost: string,\n\t\tport: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t): Promise<IManagementServerConnectionStatus> {\n\t\tthis.logger.debug({ msg: 'checkManagementConnection()', host, port, userName });\n\t\tconst connection = new AMIConnection();\n\t\ttry {\n\t\t\tawait connection.connect(host, port, userName, password);\n\t\t\tif (connection.isConnected()) {\n\t\t\t\t// Just a second level of check to ensure that we are actually\n\t\t\t\t// connected and authenticated.\n\t\t\t\tconnection.closeConnection();\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'checkManagementConnection() Connected ' });\n\t\t\treturn {\n\t\t\t\tstatus: 'connected',\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'checkManagementConnection() Connection Error', error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync checkCallserverConnection(websocketUrl: string, protocol?: string): Promise<IManagementServerConnectionStatus> {\n\t\tthis.logger.debug({ msg: 'checkCallserverConnection()', websocketUrl });\n\t\tconst connection = new WebsocketConnection();\n\t\ttry {\n\t\t\tawait connection.connectWithUrl(websocketUrl, protocol);\n\t\t\tif (connection.isConnected()) {\n\t\t\t\t// Just a second level of check to ensure that we are actually\n\t\t\t\t// connected and authenticated.\n\t\t\t\tconnection.closeConnection();\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'checkManagementConnection() Connected ' });\n\t\t\treturn {\n\t\t\t\tstatus: 'connected',\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'checkManagementConnection() Connection Error', error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstop(): void {\n\t\tif (!this.continuousMonitor) {\n\t\t\t// service is already stopped or was never initialized\n\t\t\treturn;\n\t\t}\n\n\t\tthis.continuousMonitor.cleanMonitor();\n\t\tfor (const connection of this.connections.values()) {\n\t\t\tconnection.closeConnection();\n\t\t}\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/CommandHandler.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/services/voip/connector/asterisk/CommandHandler.ts"}},"code":"module.export({\n  CommandHandler: () => CommandHandler\n});\nlet Commands;\nmodule.link(\"./Commands\", {\n  Commands(v) {\n    Commands = v;\n  }\n\n}, 0);\nlet Logger;\nmodule.link(\"../../../../lib/logger/Logger\", {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 1);\nlet CommandType;\nmodule.link(\"./Command\", {\n  CommandType(v) {\n    CommandType = v;\n  }\n\n}, 2);\nlet AMIConnection;\nmodule.link(\"./ami/AMIConnection\", {\n  AMIConnection(v) {\n    AMIConnection = v;\n  }\n\n}, 3);\nlet CommandFactory;\nmodule.link(\"./ami/CommandFactory\", {\n  CommandFactory(v) {\n    CommandFactory = v;\n  }\n\n}, 4);\nlet ServerType;\nmodule.link(\"../../../../../definition/IVoipServerConfig\", {\n  ServerType(v) {\n    ServerType = v;\n  }\n\n}, 5);\nlet WebsocketConnection;\nmodule.link(\"../websocket/WebsocketConnection\", {\n  WebsocketConnection(v) {\n    WebsocketConnection = v;\n  }\n\n}, 6);\nlet getServerConfigDataFromSettings;\nmodule.link(\"../../lib/Helper\", {\n  getServerConfigDataFromSettings(v) {\n    getServerConfigDataFromSettings = v;\n  }\n\n}, 7);\nconst version = 'Asterisk Connector 1.0';\n\nclass CommandHandler {\n  constructor(db) {\n    this.connections = void 0;\n    this.logger = void 0;\n    this.continuousMonitor = void 0;\n    this.db = void 0;\n    this.logger = new Logger('CommandHandler');\n    this.connections = new Map();\n    this.db = db;\n  }\n\n  initConnection(commandType) {\n    return Promise.asyncApply(() => {\n      var _this$connections$get;\n\n      // Initialize available connections\n      // const connection = new AMIConnection();\n      const connection = new AMIConnection();\n      let config = null;\n\n      if (commandType === CommandType.AMI) {\n        config = getServerConfigDataFromSettings(ServerType.MANAGEMENT);\n      }\n\n      if (!config) {\n        this.logger.warn('Management server configuration not found');\n        return;\n      }\n      /**\n       * If we have the same type of connection already established, close it\n       * and remove it from the map.\n       */\n\n\n      if ((_this$connections$get = this.connections.get(commandType)) !== null && _this$connections$get !== void 0 && _this$connections$get.isConnected()) {\n        var _this$connections$get2;\n\n        this.logger.error({\n          msg: 'connection exists. Closing the connection.'\n        });\n        (_this$connections$get2 = this.connections.get(commandType)) === null || _this$connections$get2 === void 0 ? void 0 : _this$connections$get2.closeConnection();\n        this.connections.delete(commandType);\n      }\n\n      try {\n        Promise.await(connection.connect(config.host, config.configData.port.toString(), config.configData.username, config.configData.password));\n        this.connections.set(commandType, connection);\n        this.continuousMonitor = CommandFactory.getCommandObject(Commands.event_stream, this.db);\n        this.continuousMonitor.connection = this.connections.get(this.continuousMonitor.type);\n        this.continuousMonitor.initMonitor({});\n      } catch (error) {\n        this.logger.error({\n          msg: 'Management server connection error',\n          error\n        });\n      }\n    });\n  }\n  /* Executes |commandToExecute| on a particular command object\n   * @remarks\n   * CommandFactory is responsible for creating a |Command| object necessary\n   * for executing an AMI command. Every concrete command object inherits\n   * from class |Command|. Which overrides a method called executeCommand.\n   * This function returns a promise. Caller can wait for the promise to resolve\n   * or rejected.\n   */\n\n\n  executeCommand(commandToExecute, commandData) {\n    this.logger.debug({\n      msg: \"executeCommand() executing \".concat(Commands[commandToExecute])\n    });\n    const command = CommandFactory.getCommandObject(commandToExecute, this.db);\n    const connection = this.connections.get(command.type);\n\n    if (!connection || !connection.isConnected()) {\n      throw Error('Connection error');\n    }\n\n    command.connection = this.connections.get(command.type);\n    return command.executeCommand(commandData);\n  } // Get the version string\n\n\n  getVersion() {\n    return version;\n  }\n\n  checkManagementConnection(host, port, userName, password) {\n    return Promise.asyncApply(() => {\n      this.logger.debug({\n        msg: 'checkManagementConnection()',\n        host,\n        port,\n        userName\n      });\n      const connection = new AMIConnection();\n\n      try {\n        Promise.await(connection.connect(host, port, userName, password));\n\n        if (connection.isConnected()) {\n          // Just a second level of check to ensure that we are actually\n          // connected and authenticated.\n          connection.closeConnection();\n        }\n\n        this.logger.debug({\n          msg: 'checkManagementConnection() Connected '\n        });\n        return {\n          status: 'connected'\n        };\n      } catch (error) {\n        this.logger.error({\n          msg: 'checkManagementConnection() Connection Error',\n          error\n        });\n        throw error;\n      }\n    });\n  }\n\n  checkCallserverConnection(websocketUrl, protocol) {\n    return Promise.asyncApply(() => {\n      this.logger.debug({\n        msg: 'checkCallserverConnection()',\n        websocketUrl\n      });\n      const connection = new WebsocketConnection();\n\n      try {\n        Promise.await(connection.connectWithUrl(websocketUrl, protocol));\n\n        if (connection.isConnected()) {\n          // Just a second level of check to ensure that we are actually\n          // connected and authenticated.\n          connection.closeConnection();\n        }\n\n        this.logger.debug({\n          msg: 'checkManagementConnection() Connected '\n        });\n        return {\n          status: 'connected'\n        };\n      } catch (error) {\n        this.logger.error({\n          msg: 'checkManagementConnection() Connection Error',\n          error\n        });\n        throw error;\n      }\n    });\n  }\n\n  stop() {\n    if (!this.continuousMonitor) {\n      // service is already stopped or was never initialized\n      return;\n    }\n\n    this.continuousMonitor.cleanMonitor();\n\n    for (const connection of this.connections.values()) {\n      connection.closeConnection();\n    }\n  }\n\n}","map":{"version":3,"sources":["server/services/voip/connector/asterisk/CommandHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class for executing command.\n * @remarks\n * This class abstracts lower details such as interface, connection and command objects\n * from the consumers of this class.\n * Connectors can be to different call-servers. For each call server, there will be\n * a multiple interfaces. e.g in case of asterisk, there are 3 types of interfaces.\n * Asterisk Gateway Interface (AGI) : Used for dialplan administration and manipulation\n * Asterisk Rest Interface (ARI) : Used for managing asterisk resources to build own application.\n * One of the use-case of ARI is for dynamically creating endpoints or listing existing recordings.\n * Asterisk Manager Interface (AMI) : Used for querying the information from asterisk.\n *\n * We shall be using only AMI interface in the for now. Other interfaces will be\n * added as and when required.\n */\nimport { Db } from 'mongodb';\n\nimport { Commands } from './Commands';\nimport { IConnection } from './IConnection';\nimport { Logger } from '../../../../lib/logger/Logger';\nimport { Command, CommandType } from './Command';\nimport { AMIConnection } from './ami/AMIConnection';\nimport { CommandFactory } from './ami/CommandFactory';\nimport { IVoipConnectorResult } from '../../../../../definition/IVoipConnectorResult';\nimport { IManagementConfigData, ServerType } from '../../../../../definition/IVoipServerConfig';\nimport { IManagementServerConnectionStatus } from '../../../../../definition/IVoipServerConnectivityStatus';\nimport { WebsocketConnection } from '../websocket/WebsocketConnection';\nimport { getServerConfigDataFromSettings } from '../../lib/Helper';\n\nconst version = 'Asterisk Connector 1.0';\n\nexport class CommandHandler {\n\tprivate connections: Map<CommandType, IConnection>;\n\n\tprivate logger: Logger;\n\n\tprivate continuousMonitor: Command;\n\n\tprivate db: Db;\n\n\tconstructor(db: Db) {\n\t\tthis.logger = new Logger('CommandHandler');\n\t\tthis.connections = new Map<CommandType, IConnection>();\n\t\tthis.db = db;\n\t}\n\n\tasync initConnection(commandType: CommandType): Promise<void> {\n\t\t// Initialize available connections\n\t\t// const connection = new AMIConnection();\n\t\tconst connection = new AMIConnection();\n\t\tlet config: any = null;\n\t\tif (commandType === CommandType.AMI) {\n\t\t\tconfig = getServerConfigDataFromSettings(ServerType.MANAGEMENT);\n\t\t}\n\t\tif (!config) {\n\t\t\tthis.logger.warn('Management server configuration not found');\n\t\t\treturn;\n\t\t}\n\t\t/**\n\t\t * If we have the same type of connection already established, close it\n\t\t * and remove it from the map.\n\t\t */\n\t\tif (this.connections.get(commandType)?.isConnected()) {\n\t\t\tthis.logger.error({ msg: 'connection exists. Closing the connection.' });\n\t\t\tthis.connections.get(commandType)?.closeConnection();\n\t\t\tthis.connections.delete(commandType);\n\t\t}\n\t\ttry {\n\t\t\tawait connection.connect(\n\t\t\t\tconfig.host,\n\t\t\t\t(config.configData as IManagementConfigData).port.toString(),\n\t\t\t\t(config.configData as IManagementConfigData).username,\n\t\t\t\t(config.configData as IManagementConfigData).password,\n\t\t\t);\n\t\t\tthis.connections.set(commandType, connection);\n\t\t\tthis.continuousMonitor = CommandFactory.getCommandObject(Commands.event_stream, this.db);\n\t\t\tthis.continuousMonitor.connection = this.connections.get(this.continuousMonitor.type) as IConnection;\n\t\t\tthis.continuousMonitor.initMonitor({});\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'Management server connection error', error });\n\t\t}\n\t}\n\n\t/* Executes |commandToExecute| on a particular command object\n\t * @remarks\n\t * CommandFactory is responsible for creating a |Command| object necessary\n\t * for executing an AMI command. Every concrete command object inherits\n\t * from class |Command|. Which overrides a method called executeCommand.\n\t * This function returns a promise. Caller can wait for the promise to resolve\n\t * or rejected.\n\t */\n\texecuteCommand(commandToExecute: Commands, commandData?: any): Promise<IVoipConnectorResult> {\n\t\tthis.logger.debug({ msg: `executeCommand() executing ${Commands[commandToExecute]}` });\n\t\tconst command = CommandFactory.getCommandObject(commandToExecute, this.db);\n\t\tconst connection = this.connections.get(command.type) as IConnection;\n\t\tif (!connection || !connection.isConnected()) {\n\t\t\tthrow Error('Connection error');\n\t\t}\n\t\tcommand.connection = this.connections.get(command.type) as IConnection;\n\t\treturn command.executeCommand(commandData);\n\t}\n\n\t// Get the version string\n\tgetVersion(): string {\n\t\treturn version;\n\t}\n\n\tasync checkManagementConnection(\n\t\thost: string,\n\t\tport: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t): Promise<IManagementServerConnectionStatus> {\n\t\tthis.logger.debug({ msg: 'checkManagementConnection()', host, port, userName });\n\t\tconst connection = new AMIConnection();\n\t\ttry {\n\t\t\tawait connection.connect(host, port, userName, password);\n\t\t\tif (connection.isConnected()) {\n\t\t\t\t// Just a second level of check to ensure that we are actually\n\t\t\t\t// connected and authenticated.\n\t\t\t\tconnection.closeConnection();\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'checkManagementConnection() Connected ' });\n\t\t\treturn {\n\t\t\t\tstatus: 'connected',\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'checkManagementConnection() Connection Error', error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync checkCallserverConnection(websocketUrl: string, protocol?: string): Promise<IManagementServerConnectionStatus> {\n\t\tthis.logger.debug({ msg: 'checkCallserverConnection()', websocketUrl });\n\t\tconst connection = new WebsocketConnection();\n\t\ttry {\n\t\t\tawait connection.connectWithUrl(websocketUrl, protocol);\n\t\t\tif (connection.isConnected()) {\n\t\t\t\t// Just a second level of check to ensure that we are actually\n\t\t\t\t// connected and authenticated.\n\t\t\t\tconnection.closeConnection();\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'checkManagementConnection() Connected ' });\n\t\t\treturn {\n\t\t\t\tstatus: 'connected',\n\t\t\t};\n\t\t} catch (error: any) {\n\t\t\tthis.logger.error({ msg: 'checkManagementConnection() Connection Error', error });\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstop(): void {\n\t\tif (!this.continuousMonitor) {\n\t\t\t// service is already stopped or was never initialized\n\t\t\treturn;\n\t\t}\n\n\t\tthis.continuousMonitor.cleanMonitor();\n\t\tfor (const connection of this.connections.values()) {\n\t\t\tconnection.closeConnection();\n\t\t}\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"9c6ac67b2d0d68209ccaf0308fee009b95521271"}
