{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/server/services/omnichannel-voip/service.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"server/services/omnichannel-voip/service.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/omnichannel-voip/service.ts","inputSourceMap":{"version":3,"file":"server/services/omnichannel-voip/service.ts","sourceRoot":"","sources":["server/services/omnichannel-voip/service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Db, FindOneOptions } from 'mongodb';\nimport _ from 'underscore';\n\nimport { IOmnichannelVoipService } from '../../sdk/types/IOmnichannelVoipService';\nimport { ServiceClassInternal } from '../../sdk/types/ServiceClass';\nimport { IVoipExtensionBase, IVoipExtensionWithAgentInfo } from '../../../definition/IVoipExtension';\nimport { Logger } from '../../lib/logger/Logger';\nimport { Voip } from '../../sdk';\nimport { IAgentExtensionMap, IRoomCreationResponse } from '../../../definition/IOmnichannelVoipServiceResult';\nimport { UsersRaw } from '../../../app/models/server/raw/Users';\nimport { VoipRoomsRaw } from '../../../app/models/server/raw/VoipRooms';\nimport { IUser } from '../../../definition/IUser';\nimport { ILivechatVisitor, isILivechatVisitor } from '../../../definition/ILivechatVisitor';\nimport { IVoipRoom, IRoomClosingInfo, OmnichannelSourceType, isVoipRoom } from '../../../definition/IRoom';\nimport { PbxEventsRaw } from '../../../app/models/server/raw/PbxEvents';\nimport { sendMessage } from '../../../app/lib/server/functions/sendMessage';\nimport { VoipClientEvents } from '../../../definition/voip/VoipClientEvents';\nimport { PaginatedResult } from '../../../definition/rest/helpers/PaginatedResult';\nimport { FindVoipRoomsParams } from './internalTypes';\nimport { ILivechatAgent } from '../../../definition/ILivechatAgent';\nimport { Notifications } from '../../../app/notifications/server';\n\nexport class OmnichannelVoipService extends ServiceClassInternal implements IOmnichannelVoipService {\n\tprotected name = 'omnichannel-voip';\n\n\tprivate logger: Logger;\n\n\tprivate users: UsersRaw;\n\n\tprivate voipRoom: VoipRoomsRaw;\n\n\tprivate pbxEvents: PbxEventsRaw;\n\n\tconstructor(db: Db) {\n\t\tsuper();\n\t\tthis.users = new UsersRaw(db.collection('users'));\n\t\tthis.voipRoom = new VoipRoomsRaw(db.collection('rocketchat_room'));\n\t\tthis.logger = new Logger('OmnichannelVoipService');\n\t\tthis.pbxEvents = new PbxEventsRaw(db.collection('pbx_events'));\n\n\t\t// handle agent disconnections\n\t\tthis.onEvent('watch.pbxevents', async ({ data }) => {\n\t\t\tthis.logger.debug(`Get event watch.pbxevents on service`);\n\t\t\tconst extension = data.agentExtension;\n\t\t\tif (!extension) {\n\t\t\t\tthis.logger.debug(`No agent extension associated with the event. Skipping`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (data.event) {\n\t\t\t\tcase 'ContactStatus': {\n\t\t\t\t\treturn this.processAgentDisconnect(extension);\n\t\t\t\t}\n\t\t\t\tcase 'Hangup': {\n\t\t\t\t\treturn this.processCallerHangup(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async processCallerHangup(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing hangup event for call with agent on extension ${extension}`);\n\t\tconst agent = await this.users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.debug(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\treturn;\n\t\t}\n\t\tconst currentRoom = await this.voipRoom.findOneByAgentId(agent._id);\n\t\tif (!currentRoom) {\n\t\t\tthis.logger.debug(`No active call found for agent ${agent._id}`);\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug(`Notifying agent ${agent._id} of hangup on room ${currentRoom._id}`);\n\t\t// TODO evalute why this is 'notifyUserInThisInstance'\n\t\tNotifications.notifyUserInThisInstance(agent._id, 'call.callerhangup', { roomId: currentRoom._id });\n\t}\n\n\tprivate async processAgentDisconnect(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing disconnection event for agent with extension ${extension}`);\n\t\tconst agent = await this.users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.debug(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\t// this should not even be possible, but just in case\n\t\t\treturn;\n\t\t}\n\n\t\tconst openRooms = await this.voipRoom.findOpenByAgentId(agent._id).toArray();\n\t\tthis.logger.info(`Closing ${openRooms.length} for agent with extension ${extension}`);\n\t\t// In the best scenario, an agent would only have one active voip room\n\t\t// this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n\t\t// and multiple rooms are left opened for one single agent. Best case this will iterate once\n\t\tfor await (const room of openRooms) {\n\t\t\tawait this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n\t\t\tawait this.closeRoom(agent, room, agent, 'Agent disconnected abruptly', undefined, 'voip-call-ended-unexpectedly');\n\t\t}\n\t}\n\n\tprivate async createVoipRoom(\n\t\trid: string,\n\t\tname: string,\n\t\tagent: { agentId: string; username: string },\n\t\tguest: ILivechatVisitor,\n\t): Promise<string> {\n\t\tconst status = 'online';\n\t\tconst { _id, department: departmentId } = guest;\n\t\tconst newRoomAt = new Date();\n\n\t\tthis.logger.debug(`Creating Voip room for visitor ${_id}`);\n\n\t\t// Use latest queue caller join event\n\t\tconst callStartPbxEvent = await this.pbxEvents.findOne(\n\t\t\t{\n\t\t\t\tphone: guest?.phone?.[0]?.phoneNumber,\n\t\t\t\tevent: 'QueueCallerJoin',\n\t\t\t},\n\t\t\t{ sort: { ts: -1 } },\n\t\t);\n\n\t\tif (!callStartPbxEvent) {\n\t\t\tthis.logger.warn(`Call for visitor ${guest._id} is not associated with a pbx event`);\n\t\t}\n\n\t\tconst { queue = 'default', callUniqueId } = callStartPbxEvent || {};\n\n\t\tconst room: IVoipRoom = {\n\t\t\t_id: rid,\n\t\t\tmsgs: 0,\n\t\t\tusersCount: 1,\n\t\t\tlm: newRoomAt,\n\t\t\tfname: name,\n\t\t\tt: 'v',\n\t\t\tts: newRoomAt,\n\t\t\tdepartmentId,\n\t\t\tv: {\n\t\t\t\t_id,\n\t\t\t\ttoken: guest.token,\n\t\t\t\tstatus,\n\t\t\t\tphone: guest?.phone?.[0]?.phoneNumber,\n\t\t\t},\n\t\t\tservedBy: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tts: newRoomAt,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\topen: true,\n\t\t\twaitingResponse: true,\n\t\t\t// this should be overriden by extraRoomInfo when provided\n\t\t\t// in case it's not provided, we'll use this \"default\" type\n\t\t\tsource: {\n\t\t\t\ttype: OmnichannelSourceType.API,\n\t\t\t},\n\t\t\tqueuedAt: newRoomAt,\n\t\t\t// We assume room is created when call is started (there could be small delay)\n\t\t\tcallStarted: newRoomAt,\n\t\t\tqueue,\n\t\t\tcallUniqueId,\n\n\t\t\tuids: [],\n\t\t\tautoTranslateLanguage: '',\n\t\t\tresponseBy: '',\n\t\t\tlivechatData: '',\n\t\t\tpriorityId: '',\n\t\t\tu: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\t_updatedAt: newRoomAt,\n\t\t};\n\n\t\tthis.logger.debug(`Room created for visitor ${_id}`);\n\t\treturn (await this.voipRoom.insertOne(room)).insertedId;\n\t}\n\n\tprivate async getAllocatedExtesionAllocationData(projection: Partial<{ [P in keyof IUser]: number }>): Promise<IUser[]> {\n\t\tconst roles: string[] = ['livechat-agent', 'livechat-manager', 'admin'];\n\t\tconst options = {\n\t\t\tsort: {\n\t\t\t\tusername: 1,\n\t\t\t},\n\t\t\tprojection,\n\t\t};\n\n\t\tconst query = {\n\t\t\textension: { $exists: true },\n\t\t};\n\t\treturn this.users.findUsersInRolesWithQuery(roles, query, options).toArray();\n\t}\n\n\tasync getFreeExtensions(): Promise<string[]> {\n\t\tconst allExtensions = await Voip.getExtensionList();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t});\n\t\tconst filtered = _.difference(\n\t\t\t_.pluck(allExtensions.result as IVoipExtensionBase[], 'extension'),\n\t\t\t_.pluck(allocatedExtensions, 'extension'),\n\t\t) as string[];\n\t\treturn filtered;\n\t}\n\n\tasync getExtensionAllocationDetails(): Promise<IAgentExtensionMap[]> {\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\tusername: 1,\n\t\t\troles: 1,\n\t\t\textension: 1,\n\t\t});\n\t\treturn allocatedExtensions.map((user: any) => ({\n\t\t\t_id: user._id,\n\t\t\tagentName: user.username,\n\t\t\textension: user.extension,\n\t\t}));\n\t}\n\n\t/* Voip calls */\n\tasync getNewRoom(\n\t\tguest: ILivechatVisitor,\n\t\tagent: { agentId: string; username: string },\n\t\trid: string,\n\t\toptions: FindOneOptions<IVoipRoom> = {},\n\t): Promise<IRoomCreationResponse> {\n\t\tthis.logger.debug(`Attempting to find or create a room for visitor ${guest._id}`);\n\t\tlet room = await this.voipRoom.findOneById(rid, options);\n\t\tlet newRoom = false;\n\t\tif (room && !room.open) {\n\t\t\tthis.logger.debug(`Last room for visitor ${guest._id} closed. Creating new one`);\n\t\t\troom = null;\n\t\t}\n\t\tif (room == null) {\n\t\t\tconst name = guest.name || guest.username;\n\t\t\tconst roomId = await this.createVoipRoom(rid, name, agent, guest);\n\t\t\troom = await this.voipRoom.findOneVoipRoomById(roomId);\n\t\t\tnewRoom = true;\n\t\t\tthis.logger.debug(`Room obtained for visitor ${guest._id} -> ${room?._id}`);\n\t\t}\n\t\tif (!room) {\n\t\t\tthis.logger.debug(`Visitor ${guest._id} trying to access another visitor's room`);\n\t\t\tthrow new Error('cannot-access-room');\n\t\t}\n\t\treturn {\n\t\t\troom,\n\t\t\tnewRoom,\n\t\t};\n\t}\n\n\tasync findRoom(token: string, rid: string): Promise<IVoipRoom | null> {\n\t\tconst projection = {\n\t\t\tt: 1,\n\t\t\tdepartmentId: 1,\n\t\t\tservedBy: 1,\n\t\t\topen: 1,\n\t\t\tv: 1,\n\t\t\tts: 1,\n\t\t\tcallUniqueId: 1,\n\t\t};\n\t\tif (!rid) {\n\t\t\treturn this.voipRoom.findOneByVisitorToken(token, { projection });\n\t\t}\n\t\treturn this.voipRoom.findOneByIdAndVisitorToken(rid, token, { projection });\n\t}\n\n\tprivate async calculateOnHoldTimeForRoom(room: IVoipRoom, closedAt: Date): Promise<number> {\n\t\tif (!room || !room.callUniqueId) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst events = await this.pbxEvents.findByEvents(room.callUniqueId, ['Hold', 'Unhold']).toArray();\n\t\tif (!events.length) {\n\t\t\t// if there's no events, that means no hold time\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (events.length === 1 && events[0].event === 'Unhold') {\n\t\t\t// if the only event is an unhold event, something bad happened\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (events.length === 1 && events[0].event === 'Hold') {\n\t\t\t// if the only event is a hold event, the call was ended while on hold\n\t\t\t// hold time = room.closedAt - event.ts\n\t\t\treturn closedAt.getTime() - events[0].ts.getTime();\n\t\t}\n\n\t\tlet currentOnHoldTime = 0;\n\n\t\tfor (let i = 0; i < events.length; i += 2) {\n\t\t\tconst onHold = events[i].ts;\n\t\t\tconst unHold = events[i + 1]?.ts || closedAt;\n\n\t\t\tcurrentOnHoldTime += unHold.getTime() - onHold.getTime();\n\t\t}\n\n\t\treturn currentOnHoldTime;\n\t}\n\n\t// Comment can be used to store wrapup call data\n\tasync closeRoom(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tuser: IUser,\n\t\tcomment?: string,\n\t\ttags?: string[],\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly' = 'voip-call-wrapup',\n\t): Promise<boolean> {\n\t\tthis.logger.debug(`Attempting to close room ${room._id}`);\n\t\tif (!room || room.t !== 'v' || !room.open) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst now = new Date();\n\t\tconst { _id: rid } = room;\n\t\tconst closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n\t\tconst callTotalHoldTime = await this.calculateOnHoldTimeForRoom(room, now);\n\t\tconst closeData: IRoomClosingInfo = {\n\t\t\tclosedAt: now,\n\t\t\tcallDuration: now.getTime() - room.ts.getTime(),\n\t\t\tcloser,\n\t\t\tcallTotalHoldTime,\n\t\t\ttags,\n\t\t};\n\t\tthis.logger.debug(`Closing room ${room._id} by ${closer} ${closerParam._id}`);\n\t\tcloseData.closedBy = {\n\t\t\t_id: closerParam._id,\n\t\t\tusername: closerParam.username,\n\t\t};\n\n\t\tconst message = {\n\t\t\tt: sysMessageId,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false,\n\t\t};\n\n\t\tawait sendMessage(user, message, room);\n\t\t// There's a race condition between receiving the call and receiving the event\n\t\t// Sometimes it happens before the connection on client, sometimes it happens after\n\t\t// For now, this data will be appended as a metric on room closing\n\t\tawait this.setCallWaitingQueueTimers(room);\n\n\t\tthis.logger.debug(`Room ${room._id} closed and timers set`);\n\t\tthis.logger.debug(`Room ${room._id} was closed at ${closeData.closedAt} (duration ${closeData.callDuration})`);\n\t\tthis.voipRoom.closeByRoomId(rid, closeData);\n\t\treturn true;\n\t}\n\n\tprivate getQueuesForExt(\n\t\text: string,\n\t\tqueueInfo: {\n\t\t\tname: string;\n\t\t\tmembers: string[];\n\t\t}[],\n\t): string[] {\n\t\treturn queueInfo.reduce((acc: string[], queue: { name: string; members: string[] }) => {\n\t\t\tif (queue.members.includes(ext)) {\n\t\t\t\tacc.push(queue.name);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\tasync getExtensionListWithAgentData(): Promise<IVoipExtensionWithAgentInfo[]> {\n\t\tconst { result: extensions } = await Voip.getExtensionList();\n\t\tconst summary = await (await Voip.cachedQueueDetails())();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t\t_id: 1,\n\t\t\tusername: 1,\n\t\t\tname: 1,\n\t\t});\n\n\t\treturn (extensions as unknown as IVoipExtensionBase[]).map((ext) => {\n\t\t\tconst user = allocatedExtensions.find((ex) => ex.extension === ext.extension);\n\t\t\treturn {\n\t\t\t\tuserId: user?._id,\n\t\t\t\tusername: user?.username,\n\t\t\t\tname: user?.name,\n\t\t\t\tqueues: this.getQueuesForExt(ext.extension, summary),\n\t\t\t\t...ext,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync findVoipRooms({\n\t\tagents,\n\t\topen,\n\t\tcreatedAt,\n\t\tclosedAt,\n\t\tvisitorId,\n\t\ttags,\n\t\tqueue,\n\t\toptions: { offset = 0, count, fields, sort } = {},\n\t}: FindVoipRoomsParams): Promise<PaginatedResult<{ rooms: IVoipRoom[] }>> {\n\t\tconst cursor = this.voipRoom.findRoomsWithCriteria({\n\t\t\tagents,\n\t\t\topen,\n\t\t\tcreatedAt,\n\t\t\tclosedAt,\n\t\t\ttags,\n\t\t\tqueue,\n\t\t\tvisitorId,\n\t\t\toptions: {\n\t\t\t\tsort: sort || { ts: -1 },\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t\tfields,\n\t\t\t},\n\t\t});\n\n\t\tconst total = await cursor.count();\n\t\tconst rooms = await cursor.toArray();\n\n\t\treturn {\n\t\t\trooms,\n\t\t\tcount: rooms.length,\n\t\t\ttotal,\n\t\t\toffset,\n\t\t};\n\t}\n\n\tprivate async setCallWaitingQueueTimers(room: IVoipRoom): Promise<void> {\n\t\t// Fetch agent connected event for started call\n\t\tif (!room.callUniqueId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agentCalledEvent = await this.pbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n\t\t// Update room with the agentconnect event information (hold time => time call was in queue)\n\t\tawait this.voipRoom.updateOne(\n\t\t\t{ _id: room._id },\n\t\t\t{\n\t\t\t\t$set: {\n\t\t\t\t\t// holdtime is stored in seconds, so convert to millis\n\t\t\t\t\tcallWaitingTime: Number(agentCalledEvent?.holdTime) * 1000,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tasync handleEvent(event: VoipClientEvents, room: IVoipRoom, user: IUser, comment?: string): Promise<void> {\n\t\tconst message = {\n\t\t\tt: event,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false as const,\n\t\t\tvoipData: {\n\t\t\t\tcallDuration: Number(room.callDuration) || 0,\n\t\t\t\tcallStarted: room.callStarted?.toISOString() || new Date().toISOString(),\n\t\t\t},\n\t\t};\n\n\t\tthis.logger.debug(`Handling event ${event} on room ${room._id}`);\n\n\t\tif (\n\t\t\tisVoipRoom(room) &&\n\t\t\troom.open &&\n\t\t\troom.callUniqueId &&\n\t\t\t// Check if call exists by looking if we have pbx events of it\n\t\t\t(await this.pbxEvents.findOneByUniqueId(room.callUniqueId))\n\t\t) {\n\t\t\tthis.logger.debug(`Room is valid. Sending event ${event}`);\n\t\t\tawait sendMessage(user, message, room);\n\t\t} else {\n\t\t\tthis.logger.warn({ msg: 'Invalid room type or event type', type: room.t, event });\n\t\t}\n\t}\n\n\tasync getAvailableAgents(\n\t\tincludeExtension?: string,\n\t\ttext?: string,\n\t\tcount?: number,\n\t\toffset?: number,\n\t\tsort?: Record<string, unknown>,\n\t): Promise<{ agents: ILivechatAgent[]; total: number }> {\n\t\tconst cursor = this.users.getAvailableAgentsIncludingExt(includeExtension, text, { count, skip: offset, sort });\n\t\tconst agents = await cursor.toArray();\n\t\tconst total = await cursor.count();\n\n\t\treturn {\n\t\t\tagents,\n\t\t\ttotal,\n\t\t};\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/omnichannel-voip/service.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/services/omnichannel-voip/service.ts"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\n\nlet _asyncIterator;\n\nmodule.link(\"@babel/runtime/helpers/asyncIterator\", {\n  default(v) {\n    _asyncIterator = v;\n  }\n\n}, 1);\nmodule.export({\n  OmnichannelVoipService: () => OmnichannelVoipService\n});\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 0);\nlet ServiceClassInternal;\nmodule.link(\"../../sdk/types/ServiceClass\", {\n  ServiceClassInternal(v) {\n    ServiceClassInternal = v;\n  }\n\n}, 1);\nlet Logger;\nmodule.link(\"../../lib/logger/Logger\", {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 2);\nlet Voip;\nmodule.link(\"../../sdk\", {\n  Voip(v) {\n    Voip = v;\n  }\n\n}, 3);\nlet UsersRaw;\nmodule.link(\"../../../app/models/server/raw/Users\", {\n  UsersRaw(v) {\n    UsersRaw = v;\n  }\n\n}, 4);\nlet VoipRoomsRaw;\nmodule.link(\"../../../app/models/server/raw/VoipRooms\", {\n  VoipRoomsRaw(v) {\n    VoipRoomsRaw = v;\n  }\n\n}, 5);\nlet isILivechatVisitor;\nmodule.link(\"../../../definition/ILivechatVisitor\", {\n  isILivechatVisitor(v) {\n    isILivechatVisitor = v;\n  }\n\n}, 6);\nlet OmnichannelSourceType, isVoipRoom;\nmodule.link(\"../../../definition/IRoom\", {\n  OmnichannelSourceType(v) {\n    OmnichannelSourceType = v;\n  },\n\n  isVoipRoom(v) {\n    isVoipRoom = v;\n  }\n\n}, 7);\nlet PbxEventsRaw;\nmodule.link(\"../../../app/models/server/raw/PbxEvents\", {\n  PbxEventsRaw(v) {\n    PbxEventsRaw = v;\n  }\n\n}, 8);\nlet sendMessage;\nmodule.link(\"../../../app/lib/server/functions/sendMessage\", {\n  sendMessage(v) {\n    sendMessage = v;\n  }\n\n}, 9);\nlet VoipClientEvents;\nmodule.link(\"../../../definition/voip/VoipClientEvents\", {\n  VoipClientEvents(v) {\n    VoipClientEvents = v;\n  }\n\n}, 10);\nlet Notifications;\nmodule.link(\"../../../app/notifications/server\", {\n  Notifications(v) {\n    Notifications = v;\n  }\n\n}, 11);\n\nclass OmnichannelVoipService extends ServiceClassInternal {\n  constructor(db) {\n    super();\n    this.name = 'omnichannel-voip';\n    this.logger = void 0;\n    this.users = void 0;\n    this.voipRoom = void 0;\n    this.pbxEvents = void 0;\n    this.users = new UsersRaw(db.collection('users'));\n    this.voipRoom = new VoipRoomsRaw(db.collection('rocketchat_room'));\n    this.logger = new Logger('OmnichannelVoipService');\n    this.pbxEvents = new PbxEventsRaw(db.collection('pbx_events')); // handle agent disconnections\n\n    this.onEvent('watch.pbxevents', _ref => Promise.asyncApply(() => {\n      let {\n        data\n      } = _ref;\n      this.logger.debug(\"Get event watch.pbxevents on service\");\n      const extension = data.agentExtension;\n\n      if (!extension) {\n        this.logger.debug(\"No agent extension associated with the event. Skipping\");\n        return;\n      }\n\n      switch (data.event) {\n        case 'ContactStatus':\n          {\n            return this.processAgentDisconnect(extension);\n          }\n\n        case 'Hangup':\n          {\n            return this.processCallerHangup(extension);\n          }\n      }\n    }));\n  }\n\n  processCallerHangup(extension) {\n    return Promise.asyncApply(() => {\n      this.logger.info(\"Processing hangup event for call with agent on extension \".concat(extension));\n      const agent = Promise.await(this.users.findOneByExtension(extension));\n\n      if (!agent) {\n        this.logger.debug(\"No agent found with extension \".concat(extension, \". Event won't proceed\"));\n        return;\n      }\n\n      const currentRoom = Promise.await(this.voipRoom.findOneByAgentId(agent._id));\n\n      if (!currentRoom) {\n        this.logger.debug(\"No active call found for agent \".concat(agent._id));\n        return;\n      }\n\n      this.logger.debug(\"Notifying agent \".concat(agent._id, \" of hangup on room \").concat(currentRoom._id)); // TODO evalute why this is 'notifyUserInThisInstance'\n\n      Notifications.notifyUserInThisInstance(agent._id, 'call.callerhangup', {\n        roomId: currentRoom._id\n      });\n    });\n  }\n\n  processAgentDisconnect(extension) {\n    return Promise.asyncApply(() => {\n      this.logger.info(\"Processing disconnection event for agent with extension \".concat(extension));\n      const agent = Promise.await(this.users.findOneByExtension(extension));\n\n      if (!agent) {\n        this.logger.debug(\"No agent found with extension \".concat(extension, \". Event won't proceed\")); // this should not even be possible, but just in case\n\n        return;\n      }\n\n      const openRooms = Promise.await(this.voipRoom.findOpenByAgentId(agent._id).toArray());\n      this.logger.info(\"Closing \".concat(openRooms.length, \" for agent with extension \").concat(extension)); // In the best scenario, an agent would only have one active voip room\n      // this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n      // and multiple rooms are left opened for one single agent. Best case this will iterate once\n\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(openRooms), _step; _iteratorAbruptCompletion = !(_step = Promise.await(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const room = _step.value;\n          Promise.await(this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly'));\n          Promise.await(this.closeRoom(agent, room, agent, 'Agent disconnected abruptly', undefined, 'voip-call-ended-unexpectedly'));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            Promise.await(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n  }\n\n  createVoipRoom(rid, name, agent, guest) {\n    return Promise.asyncApply(() => {\n      var _guest$phone, _guest$phone$, _guest$phone2, _guest$phone2$;\n\n      const status = 'online';\n      const {\n        _id,\n        department: departmentId\n      } = guest;\n      const newRoomAt = new Date();\n      this.logger.debug(\"Creating Voip room for visitor \".concat(_id)); // Use latest queue caller join event\n\n      const callStartPbxEvent = Promise.await(this.pbxEvents.findOne({\n        phone: guest === null || guest === void 0 ? void 0 : (_guest$phone = guest.phone) === null || _guest$phone === void 0 ? void 0 : (_guest$phone$ = _guest$phone[0]) === null || _guest$phone$ === void 0 ? void 0 : _guest$phone$.phoneNumber,\n        event: 'QueueCallerJoin'\n      }, {\n        sort: {\n          ts: -1\n        }\n      }));\n\n      if (!callStartPbxEvent) {\n        this.logger.warn(\"Call for visitor \".concat(guest._id, \" is not associated with a pbx event\"));\n      }\n\n      const {\n        queue = 'default',\n        callUniqueId\n      } = callStartPbxEvent || {};\n      const room = {\n        _id: rid,\n        msgs: 0,\n        usersCount: 1,\n        lm: newRoomAt,\n        fname: name,\n        t: 'v',\n        ts: newRoomAt,\n        departmentId,\n        v: {\n          _id,\n          token: guest.token,\n          status,\n          phone: guest === null || guest === void 0 ? void 0 : (_guest$phone2 = guest.phone) === null || _guest$phone2 === void 0 ? void 0 : (_guest$phone2$ = _guest$phone2[0]) === null || _guest$phone2$ === void 0 ? void 0 : _guest$phone2$.phoneNumber\n        },\n        servedBy: {\n          _id: agent.agentId,\n          ts: newRoomAt,\n          username: agent.username\n        },\n        open: true,\n        waitingResponse: true,\n        // this should be overriden by extraRoomInfo when provided\n        // in case it's not provided, we'll use this \"default\" type\n        source: {\n          type: OmnichannelSourceType.API\n        },\n        queuedAt: newRoomAt,\n        // We assume room is created when call is started (there could be small delay)\n        callStarted: newRoomAt,\n        queue,\n        callUniqueId,\n        uids: [],\n        autoTranslateLanguage: '',\n        responseBy: '',\n        livechatData: '',\n        priorityId: '',\n        u: {\n          _id: agent.agentId,\n          username: agent.username\n        },\n        _updatedAt: newRoomAt\n      };\n      this.logger.debug(\"Room created for visitor \".concat(_id));\n      return Promise.await(this.voipRoom.insertOne(room)).insertedId;\n    });\n  }\n\n  getAllocatedExtesionAllocationData(projection) {\n    return Promise.asyncApply(() => {\n      const roles = ['livechat-agent', 'livechat-manager', 'admin'];\n      const options = {\n        sort: {\n          username: 1\n        },\n        projection\n      };\n      const query = {\n        extension: {\n          $exists: true\n        }\n      };\n      return this.users.findUsersInRolesWithQuery(roles, query, options).toArray();\n    });\n  }\n\n  getFreeExtensions() {\n    return Promise.asyncApply(() => {\n      const allExtensions = Promise.await(Voip.getExtensionList());\n      const allocatedExtensions = Promise.await(this.getAllocatedExtesionAllocationData({\n        extension: 1\n      }));\n\n      const filtered = _.difference(_.pluck(allExtensions.result, 'extension'), _.pluck(allocatedExtensions, 'extension'));\n\n      return filtered;\n    });\n  }\n\n  getExtensionAllocationDetails() {\n    return Promise.asyncApply(() => {\n      const allocatedExtensions = Promise.await(this.getAllocatedExtesionAllocationData({\n        username: 1,\n        roles: 1,\n        extension: 1\n      }));\n      return allocatedExtensions.map(user => ({\n        _id: user._id,\n        agentName: user.username,\n        extension: user.extension\n      }));\n    });\n  }\n  /* Voip calls */\n\n\n  getNewRoom(guest, agent, rid) {\n    return Promise.asyncApply(() => {\n      let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.logger.debug(\"Attempting to find or create a room for visitor \".concat(guest._id));\n      let room = Promise.await(this.voipRoom.findOneById(rid, options));\n      let newRoom = false;\n\n      if (room && !room.open) {\n        this.logger.debug(\"Last room for visitor \".concat(guest._id, \" closed. Creating new one\"));\n        room = null;\n      }\n\n      if (room == null) {\n        var _room;\n\n        const name = guest.name || guest.username;\n        const roomId = Promise.await(this.createVoipRoom(rid, name, agent, guest));\n        room = Promise.await(this.voipRoom.findOneVoipRoomById(roomId));\n        newRoom = true;\n        this.logger.debug(\"Room obtained for visitor \".concat(guest._id, \" -> \").concat((_room = room) === null || _room === void 0 ? void 0 : _room._id));\n      }\n\n      if (!room) {\n        this.logger.debug(\"Visitor \".concat(guest._id, \" trying to access another visitor's room\"));\n        throw new Error('cannot-access-room');\n      }\n\n      return {\n        room,\n        newRoom\n      };\n    });\n  }\n\n  findRoom(token, rid) {\n    return Promise.asyncApply(() => {\n      const projection = {\n        t: 1,\n        departmentId: 1,\n        servedBy: 1,\n        open: 1,\n        v: 1,\n        ts: 1,\n        callUniqueId: 1\n      };\n\n      if (!rid) {\n        return this.voipRoom.findOneByVisitorToken(token, {\n          projection\n        });\n      }\n\n      return this.voipRoom.findOneByIdAndVisitorToken(rid, token, {\n        projection\n      });\n    });\n  }\n\n  calculateOnHoldTimeForRoom(room, closedAt) {\n    return Promise.asyncApply(() => {\n      if (!room || !room.callUniqueId) {\n        return 0;\n      }\n\n      const events = Promise.await(this.pbxEvents.findByEvents(room.callUniqueId, ['Hold', 'Unhold']).toArray());\n\n      if (!events.length) {\n        // if there's no events, that means no hold time\n        return 0;\n      }\n\n      if (events.length === 1 && events[0].event === 'Unhold') {\n        // if the only event is an unhold event, something bad happened\n        return 0;\n      }\n\n      if (events.length === 1 && events[0].event === 'Hold') {\n        // if the only event is a hold event, the call was ended while on hold\n        // hold time = room.closedAt - event.ts\n        return closedAt.getTime() - events[0].ts.getTime();\n      }\n\n      let currentOnHoldTime = 0;\n\n      for (let i = 0; i < events.length; i += 2) {\n        var _events;\n\n        const onHold = events[i].ts;\n        const unHold = ((_events = events[i + 1]) === null || _events === void 0 ? void 0 : _events.ts) || closedAt;\n        currentOnHoldTime += unHold.getTime() - onHold.getTime();\n      }\n\n      return currentOnHoldTime;\n    });\n  } // Comment can be used to store wrapup call data\n\n\n  closeRoom(closerParam, room, user, comment, tags) {\n    return Promise.asyncApply(() => {\n      let sysMessageId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'voip-call-wrapup';\n      this.logger.debug(\"Attempting to close room \".concat(room._id));\n\n      if (!room || room.t !== 'v' || !room.open) {\n        return false;\n      }\n\n      const now = new Date();\n      const {\n        _id: rid\n      } = room;\n      const closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n      const callTotalHoldTime = Promise.await(this.calculateOnHoldTimeForRoom(room, now));\n      const closeData = {\n        closedAt: now,\n        callDuration: now.getTime() - room.ts.getTime(),\n        closer,\n        callTotalHoldTime,\n        tags\n      };\n      this.logger.debug(\"Closing room \".concat(room._id, \" by \").concat(closer, \" \").concat(closerParam._id));\n      closeData.closedBy = {\n        _id: closerParam._id,\n        username: closerParam.username\n      };\n      const message = {\n        t: sysMessageId,\n        msg: comment,\n        groupable: false\n      };\n      Promise.await(sendMessage(user, message, room)); // There's a race condition between receiving the call and receiving the event\n      // Sometimes it happens before the connection on client, sometimes it happens after\n      // For now, this data will be appended as a metric on room closing\n\n      Promise.await(this.setCallWaitingQueueTimers(room));\n      this.logger.debug(\"Room \".concat(room._id, \" closed and timers set\"));\n      this.logger.debug(\"Room \".concat(room._id, \" was closed at \").concat(closeData.closedAt, \" (duration \").concat(closeData.callDuration, \")\"));\n      this.voipRoom.closeByRoomId(rid, closeData);\n      return true;\n    });\n  }\n\n  getQueuesForExt(ext, queueInfo) {\n    return queueInfo.reduce((acc, queue) => {\n      if (queue.members.includes(ext)) {\n        acc.push(queue.name);\n      }\n\n      return acc;\n    }, []);\n  }\n\n  getExtensionListWithAgentData() {\n    return Promise.asyncApply(() => {\n      const {\n        result: extensions\n      } = Promise.await(Voip.getExtensionList());\n      const summary = Promise.await(Promise.await(Voip.cachedQueueDetails())());\n      const allocatedExtensions = Promise.await(this.getAllocatedExtesionAllocationData({\n        extension: 1,\n        _id: 1,\n        username: 1,\n        name: 1\n      }));\n      return extensions.map(ext => {\n        const user = allocatedExtensions.find(ex => ex.extension === ext.extension);\n        return _objectSpread({\n          userId: user === null || user === void 0 ? void 0 : user._id,\n          username: user === null || user === void 0 ? void 0 : user.username,\n          name: user === null || user === void 0 ? void 0 : user.name,\n          queues: this.getQueuesForExt(ext.extension, summary)\n        }, ext);\n      });\n    });\n  }\n\n  findVoipRooms(_ref2) {\n    return Promise.asyncApply(() => {\n      let {\n        agents,\n        open,\n        createdAt,\n        closedAt,\n        visitorId,\n        tags,\n        queue,\n        options: {\n          offset = 0,\n          count,\n          fields,\n          sort\n        } = {}\n      } = _ref2;\n      const cursor = this.voipRoom.findRoomsWithCriteria({\n        agents,\n        open,\n        createdAt,\n        closedAt,\n        tags,\n        queue,\n        visitorId,\n        options: {\n          sort: sort || {\n            ts: -1\n          },\n          offset,\n          count,\n          fields\n        }\n      });\n      const total = Promise.await(cursor.count());\n      const rooms = Promise.await(cursor.toArray());\n      return {\n        rooms,\n        count: rooms.length,\n        total,\n        offset\n      };\n    });\n  }\n\n  setCallWaitingQueueTimers(room) {\n    return Promise.asyncApply(() => {\n      // Fetch agent connected event for started call\n      if (!room.callUniqueId) {\n        return;\n      }\n\n      const agentCalledEvent = Promise.await(this.pbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect')); // Update room with the agentconnect event information (hold time => time call was in queue)\n\n      Promise.await(this.voipRoom.updateOne({\n        _id: room._id\n      }, {\n        $set: {\n          // holdtime is stored in seconds, so convert to millis\n          callWaitingTime: Number(agentCalledEvent === null || agentCalledEvent === void 0 ? void 0 : agentCalledEvent.holdTime) * 1000\n        }\n      }));\n    });\n  }\n\n  handleEvent(event, room, user, comment) {\n    return Promise.asyncApply(() => {\n      var _room$callStarted;\n\n      const message = {\n        t: event,\n        msg: comment,\n        groupable: false,\n        voipData: {\n          callDuration: Number(room.callDuration) || 0,\n          callStarted: ((_room$callStarted = room.callStarted) === null || _room$callStarted === void 0 ? void 0 : _room$callStarted.toISOString()) || new Date().toISOString()\n        }\n      };\n      this.logger.debug(\"Handling event \".concat(event, \" on room \").concat(room._id));\n\n      if (isVoipRoom(room) && room.open && room.callUniqueId && // Check if call exists by looking if we have pbx events of it\n      Promise.await(this.pbxEvents.findOneByUniqueId(room.callUniqueId))) {\n        this.logger.debug(\"Room is valid. Sending event \".concat(event));\n        Promise.await(sendMessage(user, message, room));\n      } else {\n        this.logger.warn({\n          msg: 'Invalid room type or event type',\n          type: room.t,\n          event\n        });\n      }\n    });\n  }\n\n  getAvailableAgents(includeExtension, text, count, offset, sort) {\n    return Promise.asyncApply(() => {\n      const cursor = this.users.getAvailableAgentsIncludingExt(includeExtension, text, {\n        count,\n        skip: offset,\n        sort\n      });\n      const agents = Promise.await(cursor.toArray());\n      const total = Promise.await(cursor.count());\n      return {\n        agents,\n        total\n      };\n    });\n  }\n\n}","map":{"version":3,"sources":["server/services/omnichannel-voip/service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Db, FindOneOptions } from 'mongodb';\nimport _ from 'underscore';\n\nimport { IOmnichannelVoipService } from '../../sdk/types/IOmnichannelVoipService';\nimport { ServiceClassInternal } from '../../sdk/types/ServiceClass';\nimport { IVoipExtensionBase, IVoipExtensionWithAgentInfo } from '../../../definition/IVoipExtension';\nimport { Logger } from '../../lib/logger/Logger';\nimport { Voip } from '../../sdk';\nimport { IAgentExtensionMap, IRoomCreationResponse } from '../../../definition/IOmnichannelVoipServiceResult';\nimport { UsersRaw } from '../../../app/models/server/raw/Users';\nimport { VoipRoomsRaw } from '../../../app/models/server/raw/VoipRooms';\nimport { IUser } from '../../../definition/IUser';\nimport { ILivechatVisitor, isILivechatVisitor } from '../../../definition/ILivechatVisitor';\nimport { IVoipRoom, IRoomClosingInfo, OmnichannelSourceType, isVoipRoom } from '../../../definition/IRoom';\nimport { PbxEventsRaw } from '../../../app/models/server/raw/PbxEvents';\nimport { sendMessage } from '../../../app/lib/server/functions/sendMessage';\nimport { VoipClientEvents } from '../../../definition/voip/VoipClientEvents';\nimport { PaginatedResult } from '../../../definition/rest/helpers/PaginatedResult';\nimport { FindVoipRoomsParams } from './internalTypes';\nimport { ILivechatAgent } from '../../../definition/ILivechatAgent';\nimport { Notifications } from '../../../app/notifications/server';\n\nexport class OmnichannelVoipService extends ServiceClassInternal implements IOmnichannelVoipService {\n\tprotected name = 'omnichannel-voip';\n\n\tprivate logger: Logger;\n\n\tprivate users: UsersRaw;\n\n\tprivate voipRoom: VoipRoomsRaw;\n\n\tprivate pbxEvents: PbxEventsRaw;\n\n\tconstructor(db: Db) {\n\t\tsuper();\n\t\tthis.users = new UsersRaw(db.collection('users'));\n\t\tthis.voipRoom = new VoipRoomsRaw(db.collection('rocketchat_room'));\n\t\tthis.logger = new Logger('OmnichannelVoipService');\n\t\tthis.pbxEvents = new PbxEventsRaw(db.collection('pbx_events'));\n\n\t\t// handle agent disconnections\n\t\tthis.onEvent('watch.pbxevents', async ({ data }) => {\n\t\t\tthis.logger.debug(`Get event watch.pbxevents on service`);\n\t\t\tconst extension = data.agentExtension;\n\t\t\tif (!extension) {\n\t\t\t\tthis.logger.debug(`No agent extension associated with the event. Skipping`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (data.event) {\n\t\t\t\tcase 'ContactStatus': {\n\t\t\t\t\treturn this.processAgentDisconnect(extension);\n\t\t\t\t}\n\t\t\t\tcase 'Hangup': {\n\t\t\t\t\treturn this.processCallerHangup(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async processCallerHangup(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing hangup event for call with agent on extension ${extension}`);\n\t\tconst agent = await this.users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.debug(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\treturn;\n\t\t}\n\t\tconst currentRoom = await this.voipRoom.findOneByAgentId(agent._id);\n\t\tif (!currentRoom) {\n\t\t\tthis.logger.debug(`No active call found for agent ${agent._id}`);\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug(`Notifying agent ${agent._id} of hangup on room ${currentRoom._id}`);\n\t\t// TODO evalute why this is 'notifyUserInThisInstance'\n\t\tNotifications.notifyUserInThisInstance(agent._id, 'call.callerhangup', { roomId: currentRoom._id });\n\t}\n\n\tprivate async processAgentDisconnect(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing disconnection event for agent with extension ${extension}`);\n\t\tconst agent = await this.users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.debug(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\t// this should not even be possible, but just in case\n\t\t\treturn;\n\t\t}\n\n\t\tconst openRooms = await this.voipRoom.findOpenByAgentId(agent._id).toArray();\n\t\tthis.logger.info(`Closing ${openRooms.length} for agent with extension ${extension}`);\n\t\t// In the best scenario, an agent would only have one active voip room\n\t\t// this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n\t\t// and multiple rooms are left opened for one single agent. Best case this will iterate once\n\t\tfor await (const room of openRooms) {\n\t\t\tawait this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n\t\t\tawait this.closeRoom(agent, room, agent, 'Agent disconnected abruptly', undefined, 'voip-call-ended-unexpectedly');\n\t\t}\n\t}\n\n\tprivate async createVoipRoom(\n\t\trid: string,\n\t\tname: string,\n\t\tagent: { agentId: string; username: string },\n\t\tguest: ILivechatVisitor,\n\t): Promise<string> {\n\t\tconst status = 'online';\n\t\tconst { _id, department: departmentId } = guest;\n\t\tconst newRoomAt = new Date();\n\n\t\tthis.logger.debug(`Creating Voip room for visitor ${_id}`);\n\n\t\t// Use latest queue caller join event\n\t\tconst callStartPbxEvent = await this.pbxEvents.findOne(\n\t\t\t{\n\t\t\t\tphone: guest?.phone?.[0]?.phoneNumber,\n\t\t\t\tevent: 'QueueCallerJoin',\n\t\t\t},\n\t\t\t{ sort: { ts: -1 } },\n\t\t);\n\n\t\tif (!callStartPbxEvent) {\n\t\t\tthis.logger.warn(`Call for visitor ${guest._id} is not associated with a pbx event`);\n\t\t}\n\n\t\tconst { queue = 'default', callUniqueId } = callStartPbxEvent || {};\n\n\t\tconst room: IVoipRoom = {\n\t\t\t_id: rid,\n\t\t\tmsgs: 0,\n\t\t\tusersCount: 1,\n\t\t\tlm: newRoomAt,\n\t\t\tfname: name,\n\t\t\tt: 'v',\n\t\t\tts: newRoomAt,\n\t\t\tdepartmentId,\n\t\t\tv: {\n\t\t\t\t_id,\n\t\t\t\ttoken: guest.token,\n\t\t\t\tstatus,\n\t\t\t\tphone: guest?.phone?.[0]?.phoneNumber,\n\t\t\t},\n\t\t\tservedBy: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tts: newRoomAt,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\topen: true,\n\t\t\twaitingResponse: true,\n\t\t\t// this should be overriden by extraRoomInfo when provided\n\t\t\t// in case it's not provided, we'll use this \"default\" type\n\t\t\tsource: {\n\t\t\t\ttype: OmnichannelSourceType.API,\n\t\t\t},\n\t\t\tqueuedAt: newRoomAt,\n\t\t\t// We assume room is created when call is started (there could be small delay)\n\t\t\tcallStarted: newRoomAt,\n\t\t\tqueue,\n\t\t\tcallUniqueId,\n\n\t\t\tuids: [],\n\t\t\tautoTranslateLanguage: '',\n\t\t\tresponseBy: '',\n\t\t\tlivechatData: '',\n\t\t\tpriorityId: '',\n\t\t\tu: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\t_updatedAt: newRoomAt,\n\t\t};\n\n\t\tthis.logger.debug(`Room created for visitor ${_id}`);\n\t\treturn (await this.voipRoom.insertOne(room)).insertedId;\n\t}\n\n\tprivate async getAllocatedExtesionAllocationData(projection: Partial<{ [P in keyof IUser]: number }>): Promise<IUser[]> {\n\t\tconst roles: string[] = ['livechat-agent', 'livechat-manager', 'admin'];\n\t\tconst options = {\n\t\t\tsort: {\n\t\t\t\tusername: 1,\n\t\t\t},\n\t\t\tprojection,\n\t\t};\n\n\t\tconst query = {\n\t\t\textension: { $exists: true },\n\t\t};\n\t\treturn this.users.findUsersInRolesWithQuery(roles, query, options).toArray();\n\t}\n\n\tasync getFreeExtensions(): Promise<string[]> {\n\t\tconst allExtensions = await Voip.getExtensionList();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t});\n\t\tconst filtered = _.difference(\n\t\t\t_.pluck(allExtensions.result as IVoipExtensionBase[], 'extension'),\n\t\t\t_.pluck(allocatedExtensions, 'extension'),\n\t\t) as string[];\n\t\treturn filtered;\n\t}\n\n\tasync getExtensionAllocationDetails(): Promise<IAgentExtensionMap[]> {\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\tusername: 1,\n\t\t\troles: 1,\n\t\t\textension: 1,\n\t\t});\n\t\treturn allocatedExtensions.map((user: any) => ({\n\t\t\t_id: user._id,\n\t\t\tagentName: user.username,\n\t\t\textension: user.extension,\n\t\t}));\n\t}\n\n\t/* Voip calls */\n\tasync getNewRoom(\n\t\tguest: ILivechatVisitor,\n\t\tagent: { agentId: string; username: string },\n\t\trid: string,\n\t\toptions: FindOneOptions<IVoipRoom> = {},\n\t): Promise<IRoomCreationResponse> {\n\t\tthis.logger.debug(`Attempting to find or create a room for visitor ${guest._id}`);\n\t\tlet room = await this.voipRoom.findOneById(rid, options);\n\t\tlet newRoom = false;\n\t\tif (room && !room.open) {\n\t\t\tthis.logger.debug(`Last room for visitor ${guest._id} closed. Creating new one`);\n\t\t\troom = null;\n\t\t}\n\t\tif (room == null) {\n\t\t\tconst name = guest.name || guest.username;\n\t\t\tconst roomId = await this.createVoipRoom(rid, name, agent, guest);\n\t\t\troom = await this.voipRoom.findOneVoipRoomById(roomId);\n\t\t\tnewRoom = true;\n\t\t\tthis.logger.debug(`Room obtained for visitor ${guest._id} -> ${room?._id}`);\n\t\t}\n\t\tif (!room) {\n\t\t\tthis.logger.debug(`Visitor ${guest._id} trying to access another visitor's room`);\n\t\t\tthrow new Error('cannot-access-room');\n\t\t}\n\t\treturn {\n\t\t\troom,\n\t\t\tnewRoom,\n\t\t};\n\t}\n\n\tasync findRoom(token: string, rid: string): Promise<IVoipRoom | null> {\n\t\tconst projection = {\n\t\t\tt: 1,\n\t\t\tdepartmentId: 1,\n\t\t\tservedBy: 1,\n\t\t\topen: 1,\n\t\t\tv: 1,\n\t\t\tts: 1,\n\t\t\tcallUniqueId: 1,\n\t\t};\n\t\tif (!rid) {\n\t\t\treturn this.voipRoom.findOneByVisitorToken(token, { projection });\n\t\t}\n\t\treturn this.voipRoom.findOneByIdAndVisitorToken(rid, token, { projection });\n\t}\n\n\tprivate async calculateOnHoldTimeForRoom(room: IVoipRoom, closedAt: Date): Promise<number> {\n\t\tif (!room || !room.callUniqueId) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst events = await this.pbxEvents.findByEvents(room.callUniqueId, ['Hold', 'Unhold']).toArray();\n\t\tif (!events.length) {\n\t\t\t// if there's no events, that means no hold time\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (events.length === 1 && events[0].event === 'Unhold') {\n\t\t\t// if the only event is an unhold event, something bad happened\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (events.length === 1 && events[0].event === 'Hold') {\n\t\t\t// if the only event is a hold event, the call was ended while on hold\n\t\t\t// hold time = room.closedAt - event.ts\n\t\t\treturn closedAt.getTime() - events[0].ts.getTime();\n\t\t}\n\n\t\tlet currentOnHoldTime = 0;\n\n\t\tfor (let i = 0; i < events.length; i += 2) {\n\t\t\tconst onHold = events[i].ts;\n\t\t\tconst unHold = events[i + 1]?.ts || closedAt;\n\n\t\t\tcurrentOnHoldTime += unHold.getTime() - onHold.getTime();\n\t\t}\n\n\t\treturn currentOnHoldTime;\n\t}\n\n\t// Comment can be used to store wrapup call data\n\tasync closeRoom(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tuser: IUser,\n\t\tcomment?: string,\n\t\ttags?: string[],\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly' = 'voip-call-wrapup',\n\t): Promise<boolean> {\n\t\tthis.logger.debug(`Attempting to close room ${room._id}`);\n\t\tif (!room || room.t !== 'v' || !room.open) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst now = new Date();\n\t\tconst { _id: rid } = room;\n\t\tconst closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n\t\tconst callTotalHoldTime = await this.calculateOnHoldTimeForRoom(room, now);\n\t\tconst closeData: IRoomClosingInfo = {\n\t\t\tclosedAt: now,\n\t\t\tcallDuration: now.getTime() - room.ts.getTime(),\n\t\t\tcloser,\n\t\t\tcallTotalHoldTime,\n\t\t\ttags,\n\t\t};\n\t\tthis.logger.debug(`Closing room ${room._id} by ${closer} ${closerParam._id}`);\n\t\tcloseData.closedBy = {\n\t\t\t_id: closerParam._id,\n\t\t\tusername: closerParam.username,\n\t\t};\n\n\t\tconst message = {\n\t\t\tt: sysMessageId,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false,\n\t\t};\n\n\t\tawait sendMessage(user, message, room);\n\t\t// There's a race condition between receiving the call and receiving the event\n\t\t// Sometimes it happens before the connection on client, sometimes it happens after\n\t\t// For now, this data will be appended as a metric on room closing\n\t\tawait this.setCallWaitingQueueTimers(room);\n\n\t\tthis.logger.debug(`Room ${room._id} closed and timers set`);\n\t\tthis.logger.debug(`Room ${room._id} was closed at ${closeData.closedAt} (duration ${closeData.callDuration})`);\n\t\tthis.voipRoom.closeByRoomId(rid, closeData);\n\t\treturn true;\n\t}\n\n\tprivate getQueuesForExt(\n\t\text: string,\n\t\tqueueInfo: {\n\t\t\tname: string;\n\t\t\tmembers: string[];\n\t\t}[],\n\t): string[] {\n\t\treturn queueInfo.reduce((acc: string[], queue: { name: string; members: string[] }) => {\n\t\t\tif (queue.members.includes(ext)) {\n\t\t\t\tacc.push(queue.name);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\tasync getExtensionListWithAgentData(): Promise<IVoipExtensionWithAgentInfo[]> {\n\t\tconst { result: extensions } = await Voip.getExtensionList();\n\t\tconst summary = await (await Voip.cachedQueueDetails())();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t\t_id: 1,\n\t\t\tusername: 1,\n\t\t\tname: 1,\n\t\t});\n\n\t\treturn (extensions as unknown as IVoipExtensionBase[]).map((ext) => {\n\t\t\tconst user = allocatedExtensions.find((ex) => ex.extension === ext.extension);\n\t\t\treturn {\n\t\t\t\tuserId: user?._id,\n\t\t\t\tusername: user?.username,\n\t\t\t\tname: user?.name,\n\t\t\t\tqueues: this.getQueuesForExt(ext.extension, summary),\n\t\t\t\t...ext,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync findVoipRooms({\n\t\tagents,\n\t\topen,\n\t\tcreatedAt,\n\t\tclosedAt,\n\t\tvisitorId,\n\t\ttags,\n\t\tqueue,\n\t\toptions: { offset = 0, count, fields, sort } = {},\n\t}: FindVoipRoomsParams): Promise<PaginatedResult<{ rooms: IVoipRoom[] }>> {\n\t\tconst cursor = this.voipRoom.findRoomsWithCriteria({\n\t\t\tagents,\n\t\t\topen,\n\t\t\tcreatedAt,\n\t\t\tclosedAt,\n\t\t\ttags,\n\t\t\tqueue,\n\t\t\tvisitorId,\n\t\t\toptions: {\n\t\t\t\tsort: sort || { ts: -1 },\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t\tfields,\n\t\t\t},\n\t\t});\n\n\t\tconst total = await cursor.count();\n\t\tconst rooms = await cursor.toArray();\n\n\t\treturn {\n\t\t\trooms,\n\t\t\tcount: rooms.length,\n\t\t\ttotal,\n\t\t\toffset,\n\t\t};\n\t}\n\n\tprivate async setCallWaitingQueueTimers(room: IVoipRoom): Promise<void> {\n\t\t// Fetch agent connected event for started call\n\t\tif (!room.callUniqueId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agentCalledEvent = await this.pbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n\t\t// Update room with the agentconnect event information (hold time => time call was in queue)\n\t\tawait this.voipRoom.updateOne(\n\t\t\t{ _id: room._id },\n\t\t\t{\n\t\t\t\t$set: {\n\t\t\t\t\t// holdtime is stored in seconds, so convert to millis\n\t\t\t\t\tcallWaitingTime: Number(agentCalledEvent?.holdTime) * 1000,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tasync handleEvent(event: VoipClientEvents, room: IVoipRoom, user: IUser, comment?: string): Promise<void> {\n\t\tconst message = {\n\t\t\tt: event,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false as const,\n\t\t\tvoipData: {\n\t\t\t\tcallDuration: Number(room.callDuration) || 0,\n\t\t\t\tcallStarted: room.callStarted?.toISOString() || new Date().toISOString(),\n\t\t\t},\n\t\t};\n\n\t\tthis.logger.debug(`Handling event ${event} on room ${room._id}`);\n\n\t\tif (\n\t\t\tisVoipRoom(room) &&\n\t\t\troom.open &&\n\t\t\troom.callUniqueId &&\n\t\t\t// Check if call exists by looking if we have pbx events of it\n\t\t\t(await this.pbxEvents.findOneByUniqueId(room.callUniqueId))\n\t\t) {\n\t\t\tthis.logger.debug(`Room is valid. Sending event ${event}`);\n\t\t\tawait sendMessage(user, message, room);\n\t\t} else {\n\t\t\tthis.logger.warn({ msg: 'Invalid room type or event type', type: room.t, event });\n\t\t}\n\t}\n\n\tasync getAvailableAgents(\n\t\tincludeExtension?: string,\n\t\ttext?: string,\n\t\tcount?: number,\n\t\toffset?: number,\n\t\tsort?: Record<string, unknown>,\n\t): Promise<{ agents: ILivechatAgent[]; total: number }> {\n\t\tconst cursor = this.users.getAvailableAgentsIncludingExt(includeExtension, text, { count, skip: offset, sort });\n\t\tconst agents = await cursor.toArray();\n\t\tconst total = await cursor.count();\n\n\t\treturn {\n\t\t\tagents,\n\t\t\ttotal,\n\t\t};\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"d7c779ad9ac4213f70449f56d80c8aaac56b2734"}
