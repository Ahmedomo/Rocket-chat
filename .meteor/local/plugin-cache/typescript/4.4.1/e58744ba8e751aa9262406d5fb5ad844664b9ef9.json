{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/app/lib/server/functions/getRoomsWithSingleOwner.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"app/lib/server/functions/getRoomsWithSingleOwner.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/app/lib/server/functions/getRoomsWithSingleOwner.ts","inputSourceMap":{"version":3,"file":"app/lib/server/functions/getRoomsWithSingleOwner.ts","sourceRoot":"","sources":["app/lib/server/functions/getRoomsWithSingleOwner.ts"],"names":[],"mappings":"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","sourcesContent":["import { Cursor } from 'mongodb';\n\nimport { subscriptionHasRole } from '../../../authorization/server';\nimport { Users, Subscriptions } from '../../../models/server';\nimport { IUser } from '../../../../definition/IUser';\nimport { ISubscription } from '../../../../definition/ISubscription';\n\nexport type SubscribedRoomsForUserWithDetails = {\n\trid: string;\n\tt: string;\n\tshouldBeRemoved: boolean;\n\tshouldChangeOwner: boolean;\n\tuserIsLastOwner: boolean;\n\tnewOwner: IUser['_id'] | null;\n};\n\nexport function shouldRemoveOrChangeOwner(subscribedRooms: SubscribedRoomsForUserWithDetails[]): boolean {\n\treturn subscribedRooms.some(({ shouldBeRemoved, shouldChangeOwner }) => shouldBeRemoved || shouldChangeOwner);\n}\n\nexport function getSubscribedRoomsForUserWithDetails(\n\tuserId: string,\n\tassignNewOwner = true,\n\troomIds: string[] = [],\n): SubscribedRoomsForUserWithDetails[] {\n\tconst subscribedRooms: SubscribedRoomsForUserWithDetails[] = [];\n\n\tconst cursor: Cursor<ISubscription> =\n\t\troomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n\n\t// Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\tcursor.forEach((subscription) => {\n\t\tconst roomData: SubscribedRoomsForUserWithDetails = {\n\t\t\trid: subscription.rid,\n\t\t\tt: subscription.t,\n\t\t\tshouldBeRemoved: false,\n\t\t\tshouldChangeOwner: false,\n\t\t\tuserIsLastOwner: false,\n\t\t\tnewOwner: null,\n\t\t};\n\n\t\tif (subscriptionHasRole(subscription, 'owner')) {\n\t\t\t// Fetch the number of owners\n\t\t\tconst numOwners = Subscriptions.findByRoomIdAndRoles(subscription.rid, ['owner']).count();\n\t\t\t// If it's only one, then this user is the only owner.\n\t\t\troomData.userIsLastOwner = numOwners === 1;\n\t\t\tif (numOwners === 1 && assignNewOwner) {\n\t\t\t\t// Let's check how many subscribers the room has.\n\t\t\t\tconst options = { projection: { 'u._id': 1 }, sort: { ts: 1 } };\n\t\t\t\tconst subscribersCursor: Cursor<ISubscription> = Subscriptions.findByRoomId(subscription.rid, options);\n\n\t\t\t\tsubscribersCursor.forEach(({ u: { _id: uid } }) => {\n\t\t\t\t\t// If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n\t\t\t\t\tif (roomData.shouldChangeOwner || uid === userId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst newOwner = Users.findOneActiveById(uid, { fields: { _id: 1 } });\n\t\t\t\t\tif (!newOwner) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\troomData.newOwner = uid;\n\t\t\t\t\troomData.shouldChangeOwner = true;\n\t\t\t\t});\n\n\t\t\t\t// If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\t\t\t\tif (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n\t\t\t\t\troomData.shouldBeRemoved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (roomData.t !== 'c') {\n\t\t\t// If the user is not an owner, remove the room if the user is the only subscriber\n\t\t\troomData.shouldBeRemoved = Subscriptions.findByRoomId(roomData.rid).count() === 1;\n\t\t}\n\n\t\tsubscribedRooms.push(roomData);\n\t});\n\n\treturn subscribedRooms;\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/app/lib/server/functions/getRoomsWithSingleOwner.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/lib/server/functions/getRoomsWithSingleOwner.ts"}},"code":"module.export({\n  shouldRemoveOrChangeOwner: () => shouldRemoveOrChangeOwner,\n  getSubscribedRoomsForUserWithDetails: () => getSubscribedRoomsForUserWithDetails\n});\nlet subscriptionHasRole;\nmodule.link(\"../../../authorization/server\", {\n  subscriptionHasRole(v) {\n    subscriptionHasRole = v;\n  }\n\n}, 0);\nlet Users, Subscriptions;\nmodule.link(\"../../../models/server\", {\n  Users(v) {\n    Users = v;\n  },\n\n  Subscriptions(v) {\n    Subscriptions = v;\n  }\n\n}, 1);\n\nfunction shouldRemoveOrChangeOwner(subscribedRooms) {\n  return subscribedRooms.some(_ref => {\n    let {\n      shouldBeRemoved,\n      shouldChangeOwner\n    } = _ref;\n    return shouldBeRemoved || shouldChangeOwner;\n  });\n}\n\nfunction getSubscribedRoomsForUserWithDetails(userId) {\n  let assignNewOwner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let roomIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const subscribedRooms = [];\n  const cursor = roomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd'); // Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\n  cursor.forEach(subscription => {\n    const roomData = {\n      rid: subscription.rid,\n      t: subscription.t,\n      shouldBeRemoved: false,\n      shouldChangeOwner: false,\n      userIsLastOwner: false,\n      newOwner: null\n    };\n\n    if (subscriptionHasRole(subscription, 'owner')) {\n      // Fetch the number of owners\n      const numOwners = Subscriptions.findByRoomIdAndRoles(subscription.rid, ['owner']).count(); // If it's only one, then this user is the only owner.\n\n      roomData.userIsLastOwner = numOwners === 1;\n\n      if (numOwners === 1 && assignNewOwner) {\n        // Let's check how many subscribers the room has.\n        const options = {\n          projection: {\n            'u._id': 1\n          },\n          sort: {\n            ts: 1\n          }\n        };\n        const subscribersCursor = Subscriptions.findByRoomId(subscription.rid, options);\n        subscribersCursor.forEach(_ref2 => {\n          let {\n            u: {\n              _id: uid\n            }\n          } = _ref2;\n\n          // If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n          if (roomData.shouldChangeOwner || uid === userId) {\n            return;\n          }\n\n          const newOwner = Users.findOneActiveById(uid, {\n            fields: {\n              _id: 1\n            }\n          });\n\n          if (!newOwner) {\n            return;\n          }\n\n          roomData.newOwner = uid;\n          roomData.shouldChangeOwner = true;\n        }); // If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\n        if (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n          roomData.shouldBeRemoved = true;\n        }\n      }\n    } else if (roomData.t !== 'c') {\n      // If the user is not an owner, remove the room if the user is the only subscriber\n      roomData.shouldBeRemoved = Subscriptions.findByRoomId(roomData.rid).count() === 1;\n    }\n\n    subscribedRooms.push(roomData);\n  });\n  return subscribedRooms;\n}","map":{"version":3,"sources":["app/lib/server/functions/getRoomsWithSingleOwner.ts"],"names":[],"mappings":"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","sourcesContent":["import { Cursor } from 'mongodb';\n\nimport { subscriptionHasRole } from '../../../authorization/server';\nimport { Users, Subscriptions } from '../../../models/server';\nimport { IUser } from '../../../../definition/IUser';\nimport { ISubscription } from '../../../../definition/ISubscription';\n\nexport type SubscribedRoomsForUserWithDetails = {\n\trid: string;\n\tt: string;\n\tshouldBeRemoved: boolean;\n\tshouldChangeOwner: boolean;\n\tuserIsLastOwner: boolean;\n\tnewOwner: IUser['_id'] | null;\n};\n\nexport function shouldRemoveOrChangeOwner(subscribedRooms: SubscribedRoomsForUserWithDetails[]): boolean {\n\treturn subscribedRooms.some(({ shouldBeRemoved, shouldChangeOwner }) => shouldBeRemoved || shouldChangeOwner);\n}\n\nexport function getSubscribedRoomsForUserWithDetails(\n\tuserId: string,\n\tassignNewOwner = true,\n\troomIds: string[] = [],\n): SubscribedRoomsForUserWithDetails[] {\n\tconst subscribedRooms: SubscribedRoomsForUserWithDetails[] = [];\n\n\tconst cursor: Cursor<ISubscription> =\n\t\troomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n\n\t// Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\tcursor.forEach((subscription) => {\n\t\tconst roomData: SubscribedRoomsForUserWithDetails = {\n\t\t\trid: subscription.rid,\n\t\t\tt: subscription.t,\n\t\t\tshouldBeRemoved: false,\n\t\t\tshouldChangeOwner: false,\n\t\t\tuserIsLastOwner: false,\n\t\t\tnewOwner: null,\n\t\t};\n\n\t\tif (subscriptionHasRole(subscription, 'owner')) {\n\t\t\t// Fetch the number of owners\n\t\t\tconst numOwners = Subscriptions.findByRoomIdAndRoles(subscription.rid, ['owner']).count();\n\t\t\t// If it's only one, then this user is the only owner.\n\t\t\troomData.userIsLastOwner = numOwners === 1;\n\t\t\tif (numOwners === 1 && assignNewOwner) {\n\t\t\t\t// Let's check how many subscribers the room has.\n\t\t\t\tconst options = { projection: { 'u._id': 1 }, sort: { ts: 1 } };\n\t\t\t\tconst subscribersCursor: Cursor<ISubscription> = Subscriptions.findByRoomId(subscription.rid, options);\n\n\t\t\t\tsubscribersCursor.forEach(({ u: { _id: uid } }) => {\n\t\t\t\t\t// If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n\t\t\t\t\tif (roomData.shouldChangeOwner || uid === userId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst newOwner = Users.findOneActiveById(uid, { fields: { _id: 1 } });\n\t\t\t\t\tif (!newOwner) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\troomData.newOwner = uid;\n\t\t\t\t\troomData.shouldChangeOwner = true;\n\t\t\t\t});\n\n\t\t\t\t// If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\t\t\t\tif (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n\t\t\t\t\troomData.shouldBeRemoved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (roomData.t !== 'c') {\n\t\t\t// If the user is not an owner, remove the room if the user is the only subscriber\n\t\t\troomData.shouldBeRemoved = Subscriptions.findByRoomId(roomData.rid).count() === 1;\n\t\t}\n\n\t\tsubscribedRooms.push(roomData);\n\t});\n\n\treturn subscribedRooms;\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"e58744ba8e751aa9262406d5fb5ad844664b9ef9"}
