{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/ami/AMIConnection.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"server/services/voip/connector/asterisk/ami/AMIConnection.ts","filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/ami/AMIConnection.ts","inputSourceMap":{"version":3,"file":"server/services/voip/connector/asterisk/ami/AMIConnection.ts","sourceRoot":"","sources":["server/services/voip/connector/asterisk/ami/AMIConnection.ts"],"names":[],"mappings":"AAYA,OAAO,EAAE,MAAM,EAAE,MAAM,kCAAkC,CAAC;AAI1D;;;;GAIG;AACH,8DAA8D;AAC9D,MAAM,OAAO,GAAG,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAE5C,SAAS,eAAe,CAAC,MAAc;IACtC,MAAM,CAAC,GAAG,GAAG,SAAS,GAAG,CAAC,GAAG,KAAY,IAAS,CAAC,CAAC;IACpD,MAAM,CAAC,KAAK,GAAG,SAAS,KAAK,CAAC,GAAG,KAAY,IAAS,CAAC,CAAC;IACxD,MAAM,CAAC,IAAI,GAAG,SAAS,IAAI,CAAC,GAAG,KAAY,IAAS,CAAC,CAAC;IACtD,MAAM,CAAC,KAAK,GAAG,SAAS,KAAK,CAAC,GAAG,KAAY,IAAS,CAAC,CAAC;IAExD,OAAO,MAAM,CAAC;AACf,CAAC;AAID,MAAM,OAAO,aAAa;IACzB,UAAU,CAA6B;IAEvC,eAAe,CAAkB;IAEjC,sBAAsB,CAAS;IAE/B,cAAc,CAAS;IAEvB,QAAQ,CAAS;IAEjB,QAAQ,CAAS;IAEjB,aAAa,CAAmB;IAExB,MAAM,CAAS;IAEvB,8FAA8F;IAC9F,2FAA2F;IAC3F,qFAAqF;IAC7E,SAAS,GAAG,KAAK,CAAC;IAE1B,yBAAyB,GAAG,CAAC,CAAC;IAE9B,0BAA0B,GAAG,CAAC,CAAC;IAE/B,wEAAwE;IACxE,wBAAwB,GAAG,IAAI,CAAC;IAEhC,iBAAiB,GAAG,KAAK,CAAC;IAE1B,6BAA6B;IAC7B,8CAA8C;IAC9C,iBAAiB,GAAG,KAAK,CAAC;IAE1B;QACC,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,eAAe,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAChE,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAA6B,CAAC;QAC1D,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;IAClC,CAAC;IAED,OAAO;QACN,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACrB,OAAO;SACP;QACD,IAAI,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,SAAS;QACR,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;YACjB,GAAG,EAAE,cAAc;YACnB,wBAAwB,EAAE,IAAI,CAAC,wBAAwB;YACvD,0BAA0B,EAAE,IAAI,CAAC,0BAA0B;SAC3D,CAAC,CAAC;QACH,IAAI,IAAI,CAAC,0BAA0B,KAAK,IAAI,CAAC,yBAAyB,EAAE;YACvE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,0CAA0C,EAAE,CAAC,CAAC;YACtE,8EAA8E;YAC9E,gCAAgC;YAChC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;YAC/B,OAAO;SACP;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,0BAA0B,CAAC;QACpH,UAAU,CAAC,KAAK,IAAI,EAAE;YACrB,IAAI;gBACH,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC/B;YAAC,OAAO,KAAc,EAAE;gBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,mDAAmD,EAAE,KAAK,EAAE,CAAC,CAAC;aACvF;QACF,CAAC,EAAE,WAAW,CAAC,CAAC;QAChB,IAAI,CAAC,0BAA0B,IAAI,CAAC,CAAC;IACtC,CAAC;IAED,cAAc,CAAC,MAAW,EAAE,KAAc;QACzC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,oCAAoC,EAAE,KAAK,EAAE,CAAC,CAAC;QACxE,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;QAC/B,IAAI,IAAI,CAAC,0BAA0B,KAAK,IAAI,CAAC,yBAAyB,EAAE;YACvE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qFAAqF,EAAE,CAAC,CAAC;YAClH,MAAM,CAAC,KAAK,CAAC,CAAC;SACd;aAAM;YACN,IAAI,CAAC,SAAS,EAAE,CAAC;SACjB;IACF,CAAC;IAED,gBAAgB,CAAC,QAAa,EAAE,OAAY;QAC3C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,wCAAwC,EAAE,CAAC,CAAC;QACrE,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;IAC1E,CAAC;IAED,cAAc,CAAC,OAAY,EAAE,MAAW,EAAE,KAAc;QACvD,IAAI,KAAK,EAAE;YACV,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,sFAAsF,EAAE,CAAC,CAAC;YACnH,4CAA4C;YAC5C,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,MAAM,CAAC,KAAK,CAAC,CAAC;SACd;aAAM;YACN,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;YACpC;;;;;;;;;;;;;;;eAeG;YACH,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;gBAC5B,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;aACzE;YACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qDAAqD,EAAE,CAAC,CAAC;YAClF,OAAO,EAAE,CAAC;SACV;IACF,CAAC;IAED,cAAc,CAAC,QAAiB;QAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,mBAAmB,EAAE,QAAQ,EAAE,CAAC,CAAC;QAC1D,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC5B,IAAI,CAAC,SAAS,EAAE,CAAC;SACjB;IACF,CAAC;IAED,gBAAgB;QACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qBAAqB,EAAE,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,iBAAiB;QACtB,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,UAAU,GAAG,IAAI,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,sBAAsB,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAE1G,MAAM,aAAa,GAAG,IAAI,OAAO,CAAO,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;YAC7D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;YACnF,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;YAErE,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAEhE,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;QACH,OAAO,aAAa,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,KAAK,CAAC,OAAO,CACZ,sBAA8B,EAC9B,cAAsB,EACtB,QAAgB,EAChB,QAAgB,EAChB,iBAAiB,GAAG,KAAK;QAEzB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,WAAW,EAAE,CAAC,CAAC;QACtC,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QACrD,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAChC,CAAC;IAED,WAAW;QACV,IAAI,IAAI,CAAC,UAAU,EAAE;YACpB,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;SACrC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAED,yDAAyD;IACzD,cAAc,CAAC,MAAc,EAAE,oBAAyB;QACvD,IAAI,IAAI,CAAC,eAAe,KAAK,eAAe,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,EAAE;YACpG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,gFAAgF,EAAE,CAAC,CAAC;YAC5G,MAAM,KAAK,CAAC,+DAA+D,CAAC,CAAC;SAC7E;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,kBAAkB,EAAE,CAAC,CAAC;QAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAAC;IACtD,CAAC;IAED,oBAAoB,CAAC,KAAU;QAC9B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,EAAE;YACvD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,4BAA4B,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACrE,OAAO;SACP;QACD,MAAM,QAAQ,GAAsB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;QACtF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,0CAA0C,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QACxF,2FAA2F;QAC3F,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC/B,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,uDAAuD,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;aACpG;iBAAM;gBACN,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;oBACjB,GAAG,EAAE,wDAAwD,KAAK,CAAC,QAAQ,EAAE;oBAC7E,KAAK,EAAE,KAAK,CAAC,KAAK;iBAClB,CAAC,CAAC;aACH;SACD;IACF,CAAC;IAED,EAAE,CAAC,KAAa,EAAE,eAAgC;QACjD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,yCAAyC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC7E,MAAM,KAAK,GAAsB,EAAE,CAAC;YACpC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SACrC;QACD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;IACtD,CAAC;IAED,GAAG,CAAC,KAAa,EAAE,OAAgB;QAClC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC;QACnC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACnC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,oCAAoC,KAAK,EAAE,EAAE,CAAC,CAAC;YACvE,OAAO;SACP;QACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qBAAqB,KAAK,EAAE,EAAE,CAAC,CAAC;QACzD,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,gCAAgC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC9E,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC/B,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBAC9C,SAAS;aACT;YACD,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAC,GAAG,KAAK,OAAO,CAAC,CAAC;YACnE,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;gBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,wBAAwB,KAAK,+BAA+B,EAAE,CAAC,CAAC;gBACzF,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACjC;iBAAM;gBACN,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;gBAC3C,MAAM;aACN;SACD;IACF,CAAC;IAED,eAAe;QACd,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,mBAAmB,EAAE,CAAC,CAAC;QAC/C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;QAC9B,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC;QAC7B,IAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;CACD","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\n/**\n * Class representing AMI connection.\n * @remarks\n * This class is based on https://github.com/pipobscure/NodeJS-AsteriskManager\n * which is internally based on https://github.com/mscdex/node-asterisk\n *\n * Asterisk AMI interface is a socket based interface. The AMI configuration\n * happens in /etc/asterisk/manager.conf file.\n *\n */\nimport { IConnection } from '../IConnection';\nimport { Logger } from '../../../../../lib/logger/Logger';\nimport { Command } from '../Command';\nimport { CallbackContext } from './CallbackContext';\n\n/**\n * Note : asterisk-manager does not provide any types.\n * We will have to write TS definitions to use import.\n * This shall be done in future.\n */\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst Manager = require('asterisk-manager');\n\nfunction makeLoggerDummy(logger: Logger): Logger {\n\tlogger.log = function log(..._args: any[]): void {};\n\tlogger.debug = function debug(..._args: any[]): void {};\n\tlogger.info = function info(..._args: any[]): void {};\n\tlogger.error = function error(..._args: any[]): void {};\n\n\treturn logger;\n}\n\ntype ConnectionState = 'UNKNOWN' | 'AUTHENTICATED' | 'ERROR';\n\nexport class AMIConnection implements IConnection {\n\tconnection: typeof Manager | undefined;\n\n\tconnectionState: ConnectionState;\n\n\tconnectionIpOrHostname: string;\n\n\tconnectionPort: string;\n\n\tuserName: string;\n\n\tpassword: string;\n\n\teventHandlers: Map<string, any>;\n\n\tprivate logger: Logger;\n\n\t// This class prints a ton of logs that are useful for debugging specific communication things\n\t// However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n\t// \"Print extended voip connection logs\" which will control classes' logging behavior\n\tprivate printLogs = false;\n\n\ttotalReconnectionAttempts = 5;\n\n\tcurrentReconnectionAttempt = 0;\n\n\t// Starting with 5 seconds of backoff time. increases with the attempts.\n\tinitialBackoffDurationMS = 5000;\n\n\tnearEndDisconnect = false;\n\n\t// if it is a test connection\n\t// Reconnectivity logic should not be applied.\n\tconnectivityCheck = false;\n\n\tconstructor() {\n\t\tconst logger = new Logger('AMIConnection');\n\t\tthis.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n\t\tthis.eventHandlers = new Map<string, CallbackContext[]>();\n\t\tthis.connectionState = 'UNKNOWN';\n\t}\n\n\tcleanup(): void {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tthis.connection.removeAllListeners();\n\t\tthis.connection = null;\n\t}\n\n\treconnect(): void {\n\t\tthis.logger.debug({\n\t\t\tmsg: 'reconnect ()',\n\t\t\tinitialBackoffDurationMS: this.initialBackoffDurationMS,\n\t\t\tcurrentReconnectionAttempt: this.currentReconnectionAttempt,\n\t\t});\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.info({ msg: 'reconnect () Not attempting to reconnect' });\n\t\t\t// We have exhausted the reconnection attempts or we have authentication error\n\t\t\t// We dont want to retry anymore\n\t\t\tthis.connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\t\tconst backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.attemptConnection();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tthis.logger.error({ msg: 'reconnect () attemptConnection() has thrown error', error });\n\t\t\t}\n\t\t}, backoffTime);\n\t\tthis.currentReconnectionAttempt += 1;\n\t}\n\n\tonManagerError(reject: any, error: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerError () Connection Error', error });\n\t\tthis.cleanup();\n\t\tthis.connectionState = 'ERROR';\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.error({ msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings' });\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerConnect(_resolve: any, _reject: any): void {\n\t\tthis.logger.debug({ msg: 'onManagerConnect () Connection Success' });\n\t\tthis.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n\t}\n\n\tonManagerLogin(resolve: any, reject: any, error: unknown): void {\n\t\tif (error) {\n\t\t\tthis.logger.error({ msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials' });\n\t\t\t// Do not reattempt if we have login failure\n\t\t\tthis.cleanup();\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.connectionState = 'AUTHENTICATED';\n\t\t\tthis.currentReconnectionAttempt = 0;\n\t\t\t/**\n\t\t\t * Note : There is no way to release a handler or cleanup the handlers.\n\t\t\t * Handlers are released only when the connection is closed.\n\t\t\t * Closing the connection and establishing it again for every command is an overhead.\n\t\t\t * To avoid that, we have taken a clean, though a bit complex approach.\n\t\t\t * We will register for all the manager event.\n\t\t\t *\n\t\t\t * Each command will register to AMIConnection to receive the events which it is\n\t\t\t * interested in. Once the processing is complete, it will unregister.\n\t\t\t *\n\t\t\t * Handled in this way will avoid disconnection of the connection to cleanup the\n\t\t\t * handlers.\n\t\t\t *\n\t\t\t * Furthermore, we do not want to initiate this when we are checking\n\t\t\t * the connectivity.\n\t\t\t */\n\t\t\tif (!this.connectivityCheck) {\n\t\t\t\tthis.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'onManagerLogin () Authentication Success, Connected' });\n\t\t\tresolve();\n\t\t}\n\t}\n\n\tonManagerClose(hadError: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerClose ()', hadError });\n\t\tthis.cleanup();\n\t\tif (!this.nearEndDisconnect) {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerTimeout(): void {\n\t\tthis.logger.debug({ msg: 'onManagerTimeout ()' });\n\t\tthis.cleanup();\n\t}\n\n\tasync attemptConnection(): Promise<void> {\n\t\tthis.connectionState = 'UNKNOWN';\n\t\tthis.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n\n\t\tconst returnPromise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n\t\t\tthis.connection.on('error', this.onManagerError.bind(this, _reject));\n\n\t\t\tthis.connection.on('close', this.onManagerClose.bind(this));\n\t\t\tthis.connection.on('timeout', this.onManagerTimeout.bind(this));\n\n\t\t\tthis.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n\t\t});\n\t\treturn returnPromise;\n\t}\n\n\t/**\n\t * connect: Connects to asterisk\n\t * description: This function initiates a connection to asterisk management interface\n\t * for receiving the various events. These events could be a result of action command sent over\n\t * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n\t * sends over the socket depends on the way permissions are given to the user in asterisk's\n\t * manager.conf file.\n\t * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n\t * The working of this library actually connects in the object creation. i.e\n\t * new Manager(port, connectionIpOrHostname, userName, password, true);\n\t * So it was noticed that if we call isConnected immediately after creating the object,\n\t * it returns false. Eventualy when the connection  and authentication succeeds\n\t * it will be set back to true.\n\t * To avoid this connection we have to explicitly create the Manager with undefined port value.\n\t * When done so, We will have to explicitly call connect and login functions.\n\t * These functions can give a callback where we can resolve the promises\n\t * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n\t * call is over.\n\t *\n\t * @param connectionIpOrHostname\n\t * @param connectionPort\n\t * @param userName\n\t * @param password\n\t */\n\tasync connect(\n\t\tconnectionIpOrHostname: string,\n\t\tconnectionPort: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t\tconnectivityCheck = false,\n\t): Promise<void> {\n\t\tthis.logger.log({ msg: 'connect()' });\n\t\tthis.connectionIpOrHostname = connectionIpOrHostname;\n\t\tthis.connectionPort = connectionPort;\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.connectivityCheck = connectivityCheck;\n\t\tawait this.attemptConnection();\n\t}\n\n\tisConnected(): boolean {\n\t\tif (this.connection) {\n\t\t\treturn this.connection.isConnected();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Executes an action on asterisk and returns the result.\n\texecuteCommand(action: object, actionResultCallback: any): void {\n\t\tif (this.connectionState !== 'AUTHENTICATED' || (this.connection && !this.connection.isConnected())) {\n\t\t\tthis.logger.warn({ msg: 'executeCommand() Cant execute command at this moment. Connection is not active' });\n\t\t\tthrow Error('Cant execute command at this moment. Connection is not active');\n\t\t}\n\t\tthis.logger.info({ msg: 'executeCommand()' });\n\t\tthis.connection.action(action, actionResultCallback);\n\t}\n\n\teventHandlerCallback(event: any): void {\n\t\tif (!this.eventHandlers.has(event.event.toLowerCase())) {\n\t\t\tthis.logger.info({ msg: `No event handler set for ${event.event}` });\n\t\t\treturn;\n\t\t}\n\t\tconst handlers: CallbackContext[] = this.eventHandlers.get(event.event.toLowerCase());\n\t\tthis.logger.debug({ msg: `eventHandlerCallback() Handler count = ${handlers.length}` });\n\t\t/* Go thru all the available handlers  and call each one of them if the actionid matches */\n\t\tfor (const handler of handlers) {\n\t\t\tif (handler.call(event)) {\n\t\t\t\tthis.logger.debug({ msg: `eventHandlerCallback() called callback for action = ${event.actionid}` });\n\t\t\t} else {\n\t\t\t\tthis.logger.debug({\n\t\t\t\t\tmsg: `eventHandlerCallback() No command found for action = ${event.actionid}`,\n\t\t\t\t\tevent: event.event,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\ton(event: string, callbackContext: CallbackContext): void {\n\t\tthis.logger.info({ msg: 'on()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.debug({ msg: `on() no existing handlers for event = ${event}` });\n\t\t\tconst array: CallbackContext[] = [];\n\t\t\tthis.eventHandlers.set(event, array);\n\t\t}\n\t\tthis.eventHandlers.get(event)?.push(callbackContext);\n\t}\n\n\toff(event: string, command: Command): void {\n\t\tthis.logger.info({ msg: 'off()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.warn({ msg: `off() No event handler found for ${event}` });\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug({ msg: `off() Event found ${event}` });\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tthis.logger.debug({ msg: `off() Handler array length = ${handlers.length}` });\n\t\tfor (const handler of handlers) {\n\t\t\tif (!handler.isValidContext(command.actionid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newHandlers = handlers.filter((obj: any) => obj !== handler);\n\t\t\tif (!newHandlers.length) {\n\t\t\t\tthis.logger.debug({ msg: `off() No handler for ${event} deleting event from the map.` });\n\t\t\t\tthis.eventHandlers.delete(event);\n\t\t\t} else {\n\t\t\t\tthis.eventHandlers.set(event, newHandlers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcloseConnection(): void {\n\t\tthis.logger.info({ msg: 'closeConnection()' });\n\t\tthis.nearEndDisconnect = true;\n\t\tthis.connection.disconnect();\n\t\tthis.cleanup();\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/weslley/Documents/projects/Rocket.Chat","root":"/home/weslley/Documents/projects/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/weslley/Documents/projects/Rocket.Chat/server/services/voip/connector/asterisk/ami/AMIConnection.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/services/voip/connector/asterisk/ami/AMIConnection.ts"}},"code":"module.export({\n  AMIConnection: () => AMIConnection\n});\nlet Logger;\nmodule.link(\"../../../../../lib/logger/Logger\", {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 0);\n\n/**\n * Note : asterisk-manager does not provide any types.\n * We will have to write TS definitions to use import.\n * This shall be done in future.\n */\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst Manager = require('asterisk-manager');\n\nfunction makeLoggerDummy(logger) {\n  logger.log = function log() {};\n\n  logger.debug = function debug() {};\n\n  logger.info = function info() {};\n\n  logger.error = function error() {};\n\n  return logger;\n}\n\nclass AMIConnection {\n  // This class prints a ton of logs that are useful for debugging specific communication things\n  // However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n  // \"Print extended voip connection logs\" which will control classes' logging behavior\n  // Starting with 5 seconds of backoff time. increases with the attempts.\n  // if it is a test connection\n  // Reconnectivity logic should not be applied.\n  constructor() {\n    this.connection = void 0;\n    this.connectionState = void 0;\n    this.connectionIpOrHostname = void 0;\n    this.connectionPort = void 0;\n    this.userName = void 0;\n    this.password = void 0;\n    this.eventHandlers = void 0;\n    this.logger = void 0;\n    this.printLogs = false;\n    this.totalReconnectionAttempts = 5;\n    this.currentReconnectionAttempt = 0;\n    this.initialBackoffDurationMS = 5000;\n    this.nearEndDisconnect = false;\n    this.connectivityCheck = false;\n    const logger = new Logger('AMIConnection');\n    this.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n    this.eventHandlers = new Map();\n    this.connectionState = 'UNKNOWN';\n  }\n\n  cleanup() {\n    if (!this.connection) {\n      return;\n    }\n\n    this.connection.removeAllListeners();\n    this.connection = null;\n  }\n\n  reconnect() {\n    this.logger.debug({\n      msg: 'reconnect ()',\n      initialBackoffDurationMS: this.initialBackoffDurationMS,\n      currentReconnectionAttempt: this.currentReconnectionAttempt\n    });\n\n    if (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n      this.logger.info({\n        msg: 'reconnect () Not attempting to reconnect'\n      }); // We have exhausted the reconnection attempts or we have authentication error\n      // We dont want to retry anymore\n\n      this.connectionState = 'ERROR';\n      return;\n    }\n\n    const backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n    setTimeout(() => Promise.asyncApply(() => {\n      try {\n        Promise.await(this.attemptConnection());\n      } catch (error) {\n        this.logger.error({\n          msg: 'reconnect () attemptConnection() has thrown error',\n          error\n        });\n      }\n    }), backoffTime);\n    this.currentReconnectionAttempt += 1;\n  }\n\n  onManagerError(reject, error) {\n    this.logger.error({\n      msg: 'onManagerError () Connection Error',\n      error\n    });\n    this.cleanup();\n    this.connectionState = 'ERROR';\n\n    if (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n      this.logger.error({\n        msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings'\n      });\n      reject(error);\n    } else {\n      this.reconnect();\n    }\n  }\n\n  onManagerConnect(_resolve, _reject) {\n    this.logger.debug({\n      msg: 'onManagerConnect () Connection Success'\n    });\n    this.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n  }\n\n  onManagerLogin(resolve, reject, error) {\n    if (error) {\n      this.logger.error({\n        msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials'\n      }); // Do not reattempt if we have login failure\n\n      this.cleanup();\n      reject(error);\n    } else {\n      this.connectionState = 'AUTHENTICATED';\n      this.currentReconnectionAttempt = 0;\n      /**\n       * Note : There is no way to release a handler or cleanup the handlers.\n       * Handlers are released only when the connection is closed.\n       * Closing the connection and establishing it again for every command is an overhead.\n       * To avoid that, we have taken a clean, though a bit complex approach.\n       * We will register for all the manager event.\n       *\n       * Each command will register to AMIConnection to receive the events which it is\n       * interested in. Once the processing is complete, it will unregister.\n       *\n       * Handled in this way will avoid disconnection of the connection to cleanup the\n       * handlers.\n       *\n       * Furthermore, we do not want to initiate this when we are checking\n       * the connectivity.\n       */\n\n      if (!this.connectivityCheck) {\n        this.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n      }\n\n      this.logger.debug({\n        msg: 'onManagerLogin () Authentication Success, Connected'\n      });\n      resolve();\n    }\n  }\n\n  onManagerClose(hadError) {\n    this.logger.error({\n      msg: 'onManagerClose ()',\n      hadError\n    });\n    this.cleanup();\n\n    if (!this.nearEndDisconnect) {\n      this.reconnect();\n    }\n  }\n\n  onManagerTimeout() {\n    this.logger.debug({\n      msg: 'onManagerTimeout ()'\n    });\n    this.cleanup();\n  }\n\n  attemptConnection() {\n    return Promise.asyncApply(() => {\n      this.connectionState = 'UNKNOWN';\n      this.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n      const returnPromise = new Promise((_resolve, _reject) => {\n        this.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n        this.connection.on('error', this.onManagerError.bind(this, _reject));\n        this.connection.on('close', this.onManagerClose.bind(this));\n        this.connection.on('timeout', this.onManagerTimeout.bind(this));\n        this.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n      });\n      return returnPromise;\n    });\n  }\n  /**\n   * connect: Connects to asterisk\n   * description: This function initiates a connection to asterisk management interface\n   * for receiving the various events. These events could be a result of action command sent over\n   * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n   * sends over the socket depends on the way permissions are given to the user in asterisk's\n   * manager.conf file.\n   * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n   * The working of this library actually connects in the object creation. i.e\n   * new Manager(port, connectionIpOrHostname, userName, password, true);\n   * So it was noticed that if we call isConnected immediately after creating the object,\n   * it returns false. Eventualy when the connection  and authentication succeeds\n   * it will be set back to true.\n   * To avoid this connection we have to explicitly create the Manager with undefined port value.\n   * When done so, We will have to explicitly call connect and login functions.\n   * These functions can give a callback where we can resolve the promises\n   * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n   * call is over.\n   *\n   * @param connectionIpOrHostname\n   * @param connectionPort\n   * @param userName\n   * @param password\n   */\n\n\n  connect(connectionIpOrHostname, connectionPort, userName, password) {\n    return Promise.asyncApply(() => {\n      let connectivityCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      this.logger.log({\n        msg: 'connect()'\n      });\n      this.connectionIpOrHostname = connectionIpOrHostname;\n      this.connectionPort = connectionPort;\n      this.userName = userName;\n      this.password = password;\n      this.connectivityCheck = connectivityCheck;\n      Promise.await(this.attemptConnection());\n    });\n  }\n\n  isConnected() {\n    if (this.connection) {\n      return this.connection.isConnected();\n    }\n\n    return false;\n  } // Executes an action on asterisk and returns the result.\n\n\n  executeCommand(action, actionResultCallback) {\n    if (this.connectionState !== 'AUTHENTICATED' || this.connection && !this.connection.isConnected()) {\n      this.logger.warn({\n        msg: 'executeCommand() Cant execute command at this moment. Connection is not active'\n      });\n      throw Error('Cant execute command at this moment. Connection is not active');\n    }\n\n    this.logger.info({\n      msg: 'executeCommand()'\n    });\n    this.connection.action(action, actionResultCallback);\n  }\n\n  eventHandlerCallback(event) {\n    if (!this.eventHandlers.has(event.event.toLowerCase())) {\n      this.logger.info({\n        msg: \"No event handler set for \".concat(event.event)\n      });\n      return;\n    }\n\n    const handlers = this.eventHandlers.get(event.event.toLowerCase());\n    this.logger.debug({\n      msg: \"eventHandlerCallback() Handler count = \".concat(handlers.length)\n    });\n    /* Go thru all the available handlers  and call each one of them if the actionid matches */\n\n    for (const handler of handlers) {\n      if (handler.call(event)) {\n        this.logger.debug({\n          msg: \"eventHandlerCallback() called callback for action = \".concat(event.actionid)\n        });\n      } else {\n        this.logger.debug({\n          msg: \"eventHandlerCallback() No command found for action = \".concat(event.actionid),\n          event: event.event\n        });\n      }\n    }\n  }\n\n  on(event, callbackContext) {\n    var _this$eventHandlers$g;\n\n    this.logger.info({\n      msg: 'on()'\n    });\n\n    if (!this.eventHandlers.has(event)) {\n      this.logger.debug({\n        msg: \"on() no existing handlers for event = \".concat(event)\n      });\n      const array = [];\n      this.eventHandlers.set(event, array);\n    }\n\n    (_this$eventHandlers$g = this.eventHandlers.get(event)) === null || _this$eventHandlers$g === void 0 ? void 0 : _this$eventHandlers$g.push(callbackContext);\n  }\n\n  off(event, command) {\n    this.logger.info({\n      msg: 'off()'\n    });\n\n    if (!this.eventHandlers.has(event)) {\n      this.logger.warn({\n        msg: \"off() No event handler found for \".concat(event)\n      });\n      return;\n    }\n\n    this.logger.debug({\n      msg: \"off() Event found \".concat(event)\n    });\n    const handlers = this.eventHandlers.get(event);\n    this.logger.debug({\n      msg: \"off() Handler array length = \".concat(handlers.length)\n    });\n\n    for (const handler of handlers) {\n      if (!handler.isValidContext(command.actionid)) {\n        continue;\n      }\n\n      const newHandlers = handlers.filter(obj => obj !== handler);\n\n      if (!newHandlers.length) {\n        this.logger.debug({\n          msg: \"off() No handler for \".concat(event, \" deleting event from the map.\")\n        });\n        this.eventHandlers.delete(event);\n      } else {\n        this.eventHandlers.set(event, newHandlers);\n        break;\n      }\n    }\n  }\n\n  closeConnection() {\n    this.logger.info({\n      msg: 'closeConnection()'\n    });\n    this.nearEndDisconnect = true;\n    this.connection.disconnect();\n    this.cleanup();\n  }\n\n}","map":{"version":3,"sources":["server/services/voip/connector/asterisk/ami/AMIConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\n/**\n * Class representing AMI connection.\n * @remarks\n * This class is based on https://github.com/pipobscure/NodeJS-AsteriskManager\n * which is internally based on https://github.com/mscdex/node-asterisk\n *\n * Asterisk AMI interface is a socket based interface. The AMI configuration\n * happens in /etc/asterisk/manager.conf file.\n *\n */\nimport { IConnection } from '../IConnection';\nimport { Logger } from '../../../../../lib/logger/Logger';\nimport { Command } from '../Command';\nimport { CallbackContext } from './CallbackContext';\n\n/**\n * Note : asterisk-manager does not provide any types.\n * We will have to write TS definitions to use import.\n * This shall be done in future.\n */\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst Manager = require('asterisk-manager');\n\nfunction makeLoggerDummy(logger: Logger): Logger {\n\tlogger.log = function log(..._args: any[]): void {};\n\tlogger.debug = function debug(..._args: any[]): void {};\n\tlogger.info = function info(..._args: any[]): void {};\n\tlogger.error = function error(..._args: any[]): void {};\n\n\treturn logger;\n}\n\ntype ConnectionState = 'UNKNOWN' | 'AUTHENTICATED' | 'ERROR';\n\nexport class AMIConnection implements IConnection {\n\tconnection: typeof Manager | undefined;\n\n\tconnectionState: ConnectionState;\n\n\tconnectionIpOrHostname: string;\n\n\tconnectionPort: string;\n\n\tuserName: string;\n\n\tpassword: string;\n\n\teventHandlers: Map<string, any>;\n\n\tprivate logger: Logger;\n\n\t// This class prints a ton of logs that are useful for debugging specific communication things\n\t// However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n\t// \"Print extended voip connection logs\" which will control classes' logging behavior\n\tprivate printLogs = false;\n\n\ttotalReconnectionAttempts = 5;\n\n\tcurrentReconnectionAttempt = 0;\n\n\t// Starting with 5 seconds of backoff time. increases with the attempts.\n\tinitialBackoffDurationMS = 5000;\n\n\tnearEndDisconnect = false;\n\n\t// if it is a test connection\n\t// Reconnectivity logic should not be applied.\n\tconnectivityCheck = false;\n\n\tconstructor() {\n\t\tconst logger = new Logger('AMIConnection');\n\t\tthis.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n\t\tthis.eventHandlers = new Map<string, CallbackContext[]>();\n\t\tthis.connectionState = 'UNKNOWN';\n\t}\n\n\tcleanup(): void {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tthis.connection.removeAllListeners();\n\t\tthis.connection = null;\n\t}\n\n\treconnect(): void {\n\t\tthis.logger.debug({\n\t\t\tmsg: 'reconnect ()',\n\t\t\tinitialBackoffDurationMS: this.initialBackoffDurationMS,\n\t\t\tcurrentReconnectionAttempt: this.currentReconnectionAttempt,\n\t\t});\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.info({ msg: 'reconnect () Not attempting to reconnect' });\n\t\t\t// We have exhausted the reconnection attempts or we have authentication error\n\t\t\t// We dont want to retry anymore\n\t\t\tthis.connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\t\tconst backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.attemptConnection();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tthis.logger.error({ msg: 'reconnect () attemptConnection() has thrown error', error });\n\t\t\t}\n\t\t}, backoffTime);\n\t\tthis.currentReconnectionAttempt += 1;\n\t}\n\n\tonManagerError(reject: any, error: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerError () Connection Error', error });\n\t\tthis.cleanup();\n\t\tthis.connectionState = 'ERROR';\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.error({ msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings' });\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerConnect(_resolve: any, _reject: any): void {\n\t\tthis.logger.debug({ msg: 'onManagerConnect () Connection Success' });\n\t\tthis.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n\t}\n\n\tonManagerLogin(resolve: any, reject: any, error: unknown): void {\n\t\tif (error) {\n\t\t\tthis.logger.error({ msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials' });\n\t\t\t// Do not reattempt if we have login failure\n\t\t\tthis.cleanup();\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.connectionState = 'AUTHENTICATED';\n\t\t\tthis.currentReconnectionAttempt = 0;\n\t\t\t/**\n\t\t\t * Note : There is no way to release a handler or cleanup the handlers.\n\t\t\t * Handlers are released only when the connection is closed.\n\t\t\t * Closing the connection and establishing it again for every command is an overhead.\n\t\t\t * To avoid that, we have taken a clean, though a bit complex approach.\n\t\t\t * We will register for all the manager event.\n\t\t\t *\n\t\t\t * Each command will register to AMIConnection to receive the events which it is\n\t\t\t * interested in. Once the processing is complete, it will unregister.\n\t\t\t *\n\t\t\t * Handled in this way will avoid disconnection of the connection to cleanup the\n\t\t\t * handlers.\n\t\t\t *\n\t\t\t * Furthermore, we do not want to initiate this when we are checking\n\t\t\t * the connectivity.\n\t\t\t */\n\t\t\tif (!this.connectivityCheck) {\n\t\t\t\tthis.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'onManagerLogin () Authentication Success, Connected' });\n\t\t\tresolve();\n\t\t}\n\t}\n\n\tonManagerClose(hadError: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerClose ()', hadError });\n\t\tthis.cleanup();\n\t\tif (!this.nearEndDisconnect) {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerTimeout(): void {\n\t\tthis.logger.debug({ msg: 'onManagerTimeout ()' });\n\t\tthis.cleanup();\n\t}\n\n\tasync attemptConnection(): Promise<void> {\n\t\tthis.connectionState = 'UNKNOWN';\n\t\tthis.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n\n\t\tconst returnPromise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n\t\t\tthis.connection.on('error', this.onManagerError.bind(this, _reject));\n\n\t\t\tthis.connection.on('close', this.onManagerClose.bind(this));\n\t\t\tthis.connection.on('timeout', this.onManagerTimeout.bind(this));\n\n\t\t\tthis.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n\t\t});\n\t\treturn returnPromise;\n\t}\n\n\t/**\n\t * connect: Connects to asterisk\n\t * description: This function initiates a connection to asterisk management interface\n\t * for receiving the various events. These events could be a result of action command sent over\n\t * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n\t * sends over the socket depends on the way permissions are given to the user in asterisk's\n\t * manager.conf file.\n\t * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n\t * The working of this library actually connects in the object creation. i.e\n\t * new Manager(port, connectionIpOrHostname, userName, password, true);\n\t * So it was noticed that if we call isConnected immediately after creating the object,\n\t * it returns false. Eventualy when the connection  and authentication succeeds\n\t * it will be set back to true.\n\t * To avoid this connection we have to explicitly create the Manager with undefined port value.\n\t * When done so, We will have to explicitly call connect and login functions.\n\t * These functions can give a callback where we can resolve the promises\n\t * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n\t * call is over.\n\t *\n\t * @param connectionIpOrHostname\n\t * @param connectionPort\n\t * @param userName\n\t * @param password\n\t */\n\tasync connect(\n\t\tconnectionIpOrHostname: string,\n\t\tconnectionPort: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t\tconnectivityCheck = false,\n\t): Promise<void> {\n\t\tthis.logger.log({ msg: 'connect()' });\n\t\tthis.connectionIpOrHostname = connectionIpOrHostname;\n\t\tthis.connectionPort = connectionPort;\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.connectivityCheck = connectivityCheck;\n\t\tawait this.attemptConnection();\n\t}\n\n\tisConnected(): boolean {\n\t\tif (this.connection) {\n\t\t\treturn this.connection.isConnected();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Executes an action on asterisk and returns the result.\n\texecuteCommand(action: object, actionResultCallback: any): void {\n\t\tif (this.connectionState !== 'AUTHENTICATED' || (this.connection && !this.connection.isConnected())) {\n\t\t\tthis.logger.warn({ msg: 'executeCommand() Cant execute command at this moment. Connection is not active' });\n\t\t\tthrow Error('Cant execute command at this moment. Connection is not active');\n\t\t}\n\t\tthis.logger.info({ msg: 'executeCommand()' });\n\t\tthis.connection.action(action, actionResultCallback);\n\t}\n\n\teventHandlerCallback(event: any): void {\n\t\tif (!this.eventHandlers.has(event.event.toLowerCase())) {\n\t\t\tthis.logger.info({ msg: `No event handler set for ${event.event}` });\n\t\t\treturn;\n\t\t}\n\t\tconst handlers: CallbackContext[] = this.eventHandlers.get(event.event.toLowerCase());\n\t\tthis.logger.debug({ msg: `eventHandlerCallback() Handler count = ${handlers.length}` });\n\t\t/* Go thru all the available handlers  and call each one of them if the actionid matches */\n\t\tfor (const handler of handlers) {\n\t\t\tif (handler.call(event)) {\n\t\t\t\tthis.logger.debug({ msg: `eventHandlerCallback() called callback for action = ${event.actionid}` });\n\t\t\t} else {\n\t\t\t\tthis.logger.debug({\n\t\t\t\t\tmsg: `eventHandlerCallback() No command found for action = ${event.actionid}`,\n\t\t\t\t\tevent: event.event,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\ton(event: string, callbackContext: CallbackContext): void {\n\t\tthis.logger.info({ msg: 'on()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.debug({ msg: `on() no existing handlers for event = ${event}` });\n\t\t\tconst array: CallbackContext[] = [];\n\t\t\tthis.eventHandlers.set(event, array);\n\t\t}\n\t\tthis.eventHandlers.get(event)?.push(callbackContext);\n\t}\n\n\toff(event: string, command: Command): void {\n\t\tthis.logger.info({ msg: 'off()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.warn({ msg: `off() No event handler found for ${event}` });\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug({ msg: `off() Event found ${event}` });\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tthis.logger.debug({ msg: `off() Handler array length = ${handlers.length}` });\n\t\tfor (const handler of handlers) {\n\t\t\tif (!handler.isValidContext(command.actionid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newHandlers = handlers.filter((obj: any) => obj !== handler);\n\t\t\tif (!newHandlers.length) {\n\t\t\t\tthis.logger.debug({ msg: `off() No handler for ${event} deleting event from the map.` });\n\t\t\t\tthis.eventHandlers.delete(event);\n\t\t\t} else {\n\t\t\t\tthis.eventHandlers.set(event, newHandlers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcloseConnection(): void {\n\t\tthis.logger.info({ msg: 'closeConnection()' });\n\t\tthis.nearEndDisconnect = true;\n\t\tthis.connection.disconnect();\n\t\tthis.cleanup();\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"c4468f01e335ced08e2daa3fa96dcb8cb37a0665"}
