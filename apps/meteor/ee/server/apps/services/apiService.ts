import * as util from 'util';

import type { RequestMethod } from '@rocket.chat/apps-engine/definition/accessors';
import type { IApiEndpoint, IApiRequest } from '@rocket.chat/apps-engine/definition/api';
import type { AppsApiServiceResponse, IAppsApiService, IRequestWithPrivateHash } from '@rocket.chat/core-services';
import { ServiceClass } from '@rocket.chat/core-services';
import type { Serialized } from '@rocket.chat/core-typings';
import type { Request, NextFunction } from 'express';
import { Router } from 'express';

import type { AppServerOrchestrator } from '../orchestrator';
import { OrchestratorFactory } from './orchestratorFactory';

/**
 * This type is used to replace the Express Response object, as in the service it won't be
 * possible to get an instance of the original Response generated by Express.
 *
 * We use the `resolve` function to return the response to the caller.
 */
type PromiseResponse = {
	resolve: (response: AppsApiServiceResponse) => void;
};

type IAppsApiRequestHandler = (req: IRequestWithPrivateHash, res: PromiseResponse, next: NextFunction) => void;

interface IAppsApiRouter {
	(req: Serialized<Request> | IRequestWithPrivateHash, res: PromiseResponse, next: NextFunction): void;
	all(path: string, ...handlers: IAppsApiRequestHandler[]): IAppsApiRouter;
}

export class AppsApiService extends ServiceClass implements IAppsApiService {
	protected name = 'apps-api';

	private apps: AppServerOrchestrator;

	protected appRouters: Map<string, IAppsApiRouter>;

	constructor() {
		super();
		this.appRouters = new Map();
		this.apps = OrchestratorFactory.getOrchestrator();
	}

	/* ---- ENDPOINT COMMUNICATION METHODS ---- */

	/**
	 * This method triggers the execution of a public route registered by an app.
	 *
	 * It is supposed to be called by the ENDPOINT COMMUNICATOR in the core, as it is
	 * the component that interfaces directly with the Express server.
	 *
	 * The returning promise will ALWAYS resolve, even if there's an error in the handler.
	 *
	 * The way we indicate an error to the caller is by returning a status code.
	 *
	 * We expect the caller to appropriately respond to their HTTP request based on
	 * the status code, headers and body returned
	 *
	 * @param req A dry request object, containing only information and no functions
	 * @returns A promise that resolve to AppsApiServiceResponse type
	 */
	public async handlePublicRequest(req: Serialized<Request>): Promise<AppsApiServiceResponse> {
		return new Promise<AppsApiServiceResponse>((resolve) => {
			const notFound = () => resolve({ statusCode: 404, body: 'Not found' });

			const router = this.appRouters.get(req.params.appId);

			if (router) {
				return router(req, { resolve }, notFound);
			}

			notFound();
		});
	}

	/**
	 * This method triggers the execution of a private route registered by an app.
	 *
	 * It is supposed to be called by the ENDPOINT COMMUNICATOR in the core, as it is
	 * the component that interfaces directly with the Express server.
	 *
	 * The returning promise will ALWAYS resolve, even if there's an error in the handler.
	 *
	 * The way we indicate an error to the caller is by returning a status code.
	 *
	 * We expect the caller to appropriately respond to their HTTP request based on
	 * the status code, headers and body returned
	 *
	 * @param req A dry request object, containing only information and no functions
	 * @returns A promise that resolves when the request is done
	 */
	public async handlePrivateRequest(req: IRequestWithPrivateHash): Promise<AppsApiServiceResponse> {
		return new Promise((resolve) => {
			const notFound = () => resolve({ statusCode: 404, body: 'Not found' });

			const router = this.appRouters.get(req.params.appId);

			if (router) {
				req._privateHash = req.params.hash;
				return router(req, { resolve }, notFound);
			}

			notFound();
		});
	}

	/* ---- BRIDGE METHODS ---- */

	public async registerApi(endpoint: IApiEndpoint, appId: string): Promise<void> {
		let router = this.appRouters.get(appId);

		if (!router) {
			// eslint-disable-next-line new-cap
			router = Router() as unknown as IAppsApiRouter;
			this.appRouters.set(appId, router);
		}

		const method = 'all';

		let routePath = endpoint.path.trim();
		if (!routePath.startsWith('/')) {
			routePath = `/${routePath}`;
		}

		if (router[method] instanceof Function) {
			router[method](routePath, this.authMiddleware(!!endpoint.authRequired), this._appApiExecutor(endpoint, appId));
		}
	}

	public async unregisterApi(appId: string): Promise<void> {
		this.appRouters.delete(appId);
	}

	/* ---- PRIVATE METHODS ---- */

	private authMiddleware(authRequired: boolean) {
		return (req: IRequestWithPrivateHash, res: PromiseResponse, next: NextFunction): void => {
			if (!req.user && authRequired) {
				return res.resolve({
					statusCode: 401,
					body: 'Unauthorized',
				});
			}

			next();
		};
	}

	private _appApiExecutor(endpoint: IApiEndpoint, appId: string) {
		return (req: IRequestWithPrivateHash, { resolve }: PromiseResponse): void => {
			// Microservice serializer converts Buffers to Uint8Arrays, so we need to convert it back
			const content = util.types.isTypedArray(req.body) ? Buffer.from(req.body) : req.body;

			const request: IApiRequest = {
				content,
				method: req.method.toLowerCase() as RequestMethod,
				headers: req.headers as { [key: string]: string },
				query: (req.query as { [key: string]: string }) || {},
				params: req.params || {},
				privateHash: req._privateHash,
				user: req.user && this.apps.getConverters()?.get('users')?.convertToApp(req.user),
			};

			this.apps
				.getManager()
				?.getApiManager()
				.executeApi(appId, endpoint.path, request)
				.then(({ status, headers = {}, content }) => {
					resolve({
						statusCode: status,
						headers,
						body: content,
					});
				})
				.catch((reason) => {
					// Should we handle this as an error?
					resolve({
						statusCode: 500,
						body: reason.message,
					});
				});
		};
	}
}
